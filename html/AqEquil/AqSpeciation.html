<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>AqEquil.AqSpeciation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AqEquil.AqSpeciation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import re
import sys
import shutil
import copy
import collections
import pickle

import warnings
from subprocess import Popen
import pkg_resources
import pandas as pd
import numpy as np
from plotnine import * # convert to matplotlib
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.cm as cm

with warnings.catch_warnings():
    warnings.simplefilter(&#34;ignore&#34;)
    import rpy2.robjects as ro
    from rpy2.robjects import pandas2ri
    pandas2ri.activate()

def load(filename, messages=True):
    &#34;&#34;&#34;
    Load a speciation file.

    Parameters
    ----------
    filename : str
        Name of the speciation file.

    Returns
    ----------
    An object of class `Speciation`.
    &#34;&#34;&#34;

    with open(filename, &#39;rb&#39;) as handle:
        speciation = pickle.load(handle)
        if messages:
            print(&#34;Loaded &#39;{}&#39;&#34;.format(filename))
        return speciation
    

def unique(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]


def convert_to_RVector(value, force_Rvec=True):
    
    &#34;&#34;&#34;
    Convert a value or list into an R vector of the appropriate type.
    
    Parameters
    ----------
    value : numeric or str, or list of numeric or str
        Value to be converted.
    
    force_Rvec : bool, default True
        If `value` is not a list, force conversion into a R vector?
        False will return an int, float, or str if value is non-list.
        True will always return an R vector.
    
    Returns
    -------
    int, float, str, or an rpy2 R vector
        A value or R vector of an appropriate data type.
    &#34;&#34;&#34;

    if not isinstance(value, list) and not force_Rvec:
        return value
    elif not isinstance(value, list) and force_Rvec:
        value = [value]
    else:
        pass

    if all(isinstance(x, bool) for x in value):
        return ro.BoolVector(value)
    elif all(isinstance(x, int) for x in value):
        return ro.IntVector(value)
    elif all(isinstance(x, float) or isinstance(x, int) for x in value):
        return ro.FloatVector(value)
    else:
        return ro.StrVector(value)


class Speciation(object):
    
    &#34;&#34;&#34;
    Stores the output of a speciation calculation.
    
    Attributes
    ----------
    input : pd.Dataframe
        Pandas dataframe containing user-supplied sample chemistry data.
    
    mass_contribution : pd.Dataframe
        Pandas dataframe containing basis species contributions to mass balance
        of aqueous species.
    
    batch_3o : rpy2 ListVector
        An rpy2 ListVector (R object) containing speciation results, in case
        analysis in R is preferred.
    
    report : pd.Dataframe
        Pandas dataframe reporting major results of speciation calculation in
        across all samples.
    
    report_divs : rpy2 ListVector
        An rpy2 ListVector of column names within the different sections of the
        speciation report.
    
    sample_data : dict
        Dictionary with sample names as keys and speciation results as values.
    
    &#34;&#34;&#34;
    
    def __init__(self, args):
        for k in args:
            setattr(self, k, args[k])

    def __getitem__(self, item):
         return getattr(self, item)
        
    def save(self, filename, messages=True):
        &#34;&#34;&#34;
        Save the speciation as a &#39;.speciation&#39; file to your current working
        directory. This file can be loaded with `AqEquil.load(filename)`.
        
        Parameters
        ----------
        filename : str
            The desired name of the file.
            
        messages : str
            Print a message confirming the save?
        &#34;&#34;&#34;
        
        if filename[-11:] != &#39;.speciation&#39;:
            filename = filename + &#39;.speciation&#39;
        
        with open(filename, &#39;wb&#39;) as handle:
            pickle.dump(self, handle, protocol=pickle.HIGHEST_PROTOCOL)
            if messages:
                print(&#34;Saved as &#39;{}&#39;&#34;.format(filename))
    
    
    @staticmethod
    def __get_unit_info(subheader):
        
        unit_name_dict = {
            &#34;pH&#34; : (&#34;&#34;, &#34;pH&#34;),
            &#34;ppm&#34; : (&#34;&#34;, &#34;ppm&#34;),
            &#34;ppb&#34; : (&#34;&#34;, &#34;ppb&#34;),
            &#34;mg/L&#34; : (&#34;&#34;, &#34;mg/L&#34;),
            &#34;degC&#34; : (&#34;temperature&#34;, &#34;°C&#34;),
            &#34;log_molality&#34; : (&#34;log molality&#34;, &#34;log(mol/kg)&#34;),
            &#34;Molality&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;molality&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;molal&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;log_activity&#34; : (&#34;log activity&#34;, &#34;log(mol/kg)&#34;),
            &#34;Log activity&#34; : (&#34;log activity&#34;, &#34;log(mol/kg)&#34;),
            &#34;mg/kg.sol&#34; : (&#34;&#34;, &#34;mg solute per kg solution&#34;),
            &#34;Alk., eq/kg.H2O&#34; : (&#34;alkalinity&#34;, &#34;eq/kg&#34;),
            &#34;Alk., eq/L&#34; : (&#34;alkalinity&#34;, &#34;eq/L&#34;),
            &#34;Alk., eq/kg.sol&#34; : (&#34;alkalinity&#34;, &#34;eq/kg solution&#34;),
            &#34;Alk., mg/L CaCO3&#34; : (&#34;alkalinity&#34;, &#34;mg/L CaCO3&#34;),
            &#34;Alk., mg/L HCO3-&#34; : (&#34;alkalinity&#34;, &#34;mg/L HCO3-&#34;),
            &#34;pX&#34; : (&#34;-(log activity)&#34;, &#34;-log(mol/kg)&#34;),
            &#34;activity&#34; : (&#34;activity&#34;, &#34;mol/kg&#34;),
            &#34;log_gamma&#34; : (&#34;log gamma&#34;, &#34;&#34;),
            &#34;gamma&#34; : (&#34;gamma&#34;, &#34;&#34;),
            &#34;affinity_kcal&#34; : (&#34;affinity&#34;, &#34;kcal/mol&#34;),
            &#34;%&#34; : (&#34;&#34;, &#34;%&#34;),
            &#34;Eh_volts&#34; : (&#34;Eh&#34;, &#34;volts&#34;),
            &#34;eq/kg.H2O&#34; : (&#34;charge&#34;, &#34;eq/kg&#34;),
        }
        
        out = unit_name_dict.get(subheader)
        
        return out[0], out[1]
    
    
    def lookup(self, col):
        
        &#34;&#34;&#34;
        Look up desired columns in the speciation report.
        
        Parameters
        ----------
        col : str or list of str
            Column name (or a list of column names) to look up.
            
        Returns
        ----------
        Pandas dataframe
            The speciation report with only the desired columns.
        &#34;&#34;&#34;
        
        if isinstance(col, str):
            col = [col]
        
        return self.report.iloc[:, self.report.columns.get_level_values(0).isin(set(col))]

    
    def __convert_aq_units_to_log_friendly(self, species):

        col_data = self.lookup(species)
        if col_data.columns.get_level_values(1) == &#39;log_activity&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;activity&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_molality&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;molality&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_gamma&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;gamma&#39;
        else:
            y = [float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = col_data.columns.get_level_values(1)[0]
        return y, out_unit
    
    
    def plot_mineral_saturation(self, sample_name, mineral_sat_type=&#34;affinity&#34;,
                                yrange=None,
                                colors=[&#34;blue&#34;, &#34;orange&#34;], bg_color=&#34;white&#34;,
                                save_as=None):
        &#34;&#34;&#34;
        Vizualize mineral saturation states in a sample as a bar plot.
        
        Parameters
        ----------
        sample_name : str
            Name of the sample to plot.
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Metric for mineral saturation state to plot. Can be &#34;affinity&#34; or
            &#34;logQoverK&#34;.
            
        yrange : list of numeric, optional
            Sets the lower and upper limits of the y axis.
        
        colors : list of two str, default [&#34;blue&#34;, &#34;orange&#34;]
            Sets the color of the bars representing supersaturated
            and undersaturated states, respectively.
        
        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        plt.xticks(rotation = 45, ha=&#39;right&#39;)
        
        if &#39;mineral_sat&#39; in self.sample_data[sample_name].keys():
            mineral_data = self.sample_data[sample_name][&#39;mineral_sat&#39;][mineral_sat_type].astype(float).sort_values(ascending=False)
            x = mineral_data.index
        else:
            msg = (&#34;This sample does not contain mineral saturation state data.&#34;
                   &#34;To generate this data, ensure that get_mineral_sat=True when&#34;
                   &#34;running speciate().&#34;)
            raise Exception(msg)
        
        pos_sat = [m if m &gt;= 0 else float(&#34;nan&#34;) for m in mineral_data] # possibly: special list for m==0
        neg_sat = [m if m &lt; 0 else float(&#34;nan&#34;) for m in mineral_data]
        
        barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
        for i, y_plot in enumerate([pos_sat, neg_sat]):
            
            if i == 0:
                color = colors[0]
            else:
                color = colors[1]
                
            bars = ax.bar(x, y_plot, tick_label=x, color=color)
            
            barlist.append(bars)
            
            if mineral_sat_type == &#34;affinity&#34;:
                ylabel = &#39;affinity, kcal/mol&#39;
            if mineral_sat_type == &#34;logQoverK&#34;:
                ylabel = &#39;logQ/K&#39;
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])
        
        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    

    def barplot(self, y, yrange=None, show_trace=True,
                show_legend=True, legend_loc=&#34;best&#34;,
                colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
        
        &#34;&#34;&#34;
        Show a bar plot to vizualize one or more variables across all samples.
        
        Parameters
        ----------
        y : str or list of str
            Name (or list of names) of the variables to plot. Valid variables
            are columns in the speciation report.
       
        yrange : list of numeric, optional
            Sets the lower and upper limits of the y axis.
        
        show_trace : bool, default True
            Show asterisks for columns with numerical values but are too short
            to see clearly?
            
        show_legend : bool, default True
            Show a legend if there is more than one variable?
        
        legend_loc : str or pair of float, default &#34;best&#34;
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        colormap : str, default &#34;viridis&#34;
            Name of the Matplotlib colormap to color the barplot. See
            https://matplotlib.org/stable/tutorials/colors/colormaps.html

        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        plt.xticks(rotation = 45, ha=&#39;right&#39;)

        if not isinstance(y, list):
            y = [y]
        
        x = self.lookup(y[0]).index # names of samples
        
        norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
        cmap = cm.__getattribute__(colormap)
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        X = np.arange(len(x))
        
        barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
        for i, yi in enumerate(y):
            y_col = self.lookup(yi)
            
            try:
                subheader = y_col.columns.get_level_values(1)[0]
            except:
                msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                       &#34;report. Available variables include &#34;
                      &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
                raise Exception(msg)
            unit_type, unit = self.__get_unit_info(subheader)
            
            try:
                y_vals = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
            except:
                msg = (&#34;One or more the values belonging to &#34;
                       &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0])+&#34;&#34;)
                raise Exception(msg)
            
            if [abs(y0) for y0 in y_vals] != y_vals: # convert to bar-friendly units if possible
                if subheader in [&#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;]:
                    y_plot, out_unit = self.__convert_aq_units_to_log_friendly(yi)
                    unit_type, unit = self.__get_unit_info(out_unit)
                else:
                    y_plot = y_vals
            else:
                y_plot = y_vals
                
            if i == 0:
                subheader_previous = subheader
                unit_previous = unit
            if unit != unit_previous and i != 0:
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
                
            yi_previous = copy.deepcopy(yi)
            unit_previous = copy.deepcopy(unit)
            subheader_previous = copy.deepcopy(subheader)
            
            if len(y) != 1:
                color = m.to_rgba(i)
            else:
                color = &#34;black&#34;
                
            bars = ax.bar(X+i*(1/(len(y)+1)), y_plot, tick_label=x, color=color, width=1/(len(y)+1))
            
            barlist.append(bars)

        max_bar_height = 0
        for bars in barlist:
            for p in bars.patches:
                max_bar_height = max([max_bar_height, np.nanmax(abs(p.get_height()))])
                
        for i,bars in enumerate(barlist):
            for p in bars.patches:
                if show_trace and abs(p.get_height())/max_bar_height &lt;= 0.009:
                    plt.annotate(&#34;*&#34;,
                                  (p.get_x() + p.get_width() / 2., p.get_height()),
                                  ha = &#39;center&#39;, va = &#39;center&#39;, xytext = (0, 10),
                                  color=m.to_rgba(i),
                                  weight=&#39;bold&#39;,
                                  fontsize=18,
                                  textcoords = &#39;offset points&#39;)
        
        if len(y) &gt; 1:
            ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
            if show_legend:
                ax.legend(labels=y, loc=legend_loc)
        else:
            if &#39;pH&#39; in y:
                ylabel = &#39;pH&#39;
            elif &#39;Temperature&#39; in y:
                ylabel = &#39;Temperature [°C]&#39;
            else:
                ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])
        
        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    
    
    def scatterplot(self, x=&#34;pH&#34;, y=&#34;Temperature&#34;, xrange=None, yrange=None,
                show_legend=True, legend_loc=&#34;best&#34;,
                colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
        
        &#34;&#34;&#34;
        Vizualize two or more sample variables with a scatterplot.
        
        Parameters
        ----------
        x, y : str, default for x is &#34;pH&#34;, default for y is &#34;Temperature&#34;
            Names of the variables to plot against each other. Valid variables
            are columns in the speciation report. `y` can be a list of
            of variable names for a multi-series scatterplot.
       
        xrange, yrange : list of numeric, optional
            Sets the lower and upper limits of the x and y axis.
            
        show_legend : bool, default True
            Show a legend if there is more than one variable?
        
        legend_loc : str or pair of float, default &#34;best&#34;
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        colormap : str, default &#34;viridis&#34;
            Name of the Matplotlib colormap to color the scatterpoints. See
            https://matplotlib.org/stable/tutorials/colors/colormaps.html

        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])

        if not isinstance(y, list):
            y = [y]
        
        if not isinstance(x, str):
            raise Exception(&#34;x must be a string.&#34;)
        
        x_col = self.lookup(x)
        try:
            x_plot = [float(x0[0]) if x0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for x0 in x_col.values.tolist()]
        except:
            msg = (&#34;One or more the values belonging to &#34;
                   &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(x_col.columns.get_level_values(0)[0])+&#34;&#34;)
            raise Exception(msg)
        
        try:
            xsubheader = x_col.columns.get_level_values(1)[0]
        except:
            msg = (&#34;Could not find &#39;{}&#39; &#34;.format(x)+&#34;in the speciation &#34;
                   &#34;report. Available variables include &#34;
                   &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
            raise Exception(msg)
        xunit_type, xunit = self.__get_unit_info(xsubheader)
        
        norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
        cmap = cm.__getattribute__(colormap)
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        
        for i, yi in enumerate(y):
            y_col = self.lookup(yi)
            
            try:
                subheader = y_col.columns.get_level_values(1)[0]
            except:
                msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                       &#34;report. Available variables include &#34;
                      &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
                raise Exception(msg)
            unit_type, unit = self.__get_unit_info(subheader)
            
            try:
                y_plot = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
            except:
                msg = (&#34;One or more the values belonging to &#34;
                       &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0])+&#34;&#34;)
                raise Exception(msg)
                
            if i == 0:
                subheader_previous = subheader
                unit_previous = unit
            if unit != unit_previous and i != 0:
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
                
            yi_previous = copy.deepcopy(yi)
            unit_previous = copy.deepcopy(unit)
            subheader_previous = copy.deepcopy(subheader)
            
            if len(y) != 1:
                color = m.to_rgba(i)
            else:
                color = &#34;black&#34;
            
            plt.scatter(x_plot, y_plot, marker=&#39;o&#39;, color=color)

        if len(y) &gt; 1:
            ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
            if show_legend:
                ax.legend(labels=y, loc=legend_loc)
        else:
            if &#39;pH&#39; in y:
                ylabel = &#39;pH&#39;
            elif &#39;Temperature&#39; in y:
                ylabel = &#39;Temperature [°C]&#39;
            else:
                ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
        
        if x == &#39;pH&#39;:
            xlabel = &#39;pH&#39;
        elif x == &#39;Temperature&#39;:
            xlabel = &#39;Temperature [°C]&#39;
        else:
            xlabel = &#34;{} {} [{}]&#34;.format(x, xunit_type, xunit)
        
        if xrange != None:
            plt.xlim(xrange[0], xrange[1])
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])

        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)
        plt.xlabel(xlabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    
    
    def plot_mass_contribution(self, basis, width=0.9,
                                     legend_loc=(1.02, 0.5)):
        
        &#34;&#34;&#34;
        Plot basis species contributions to mass balance of aqueous species
        across all samples.
        
        Parameters
        ----------
        basis : str
            Name of the basis species.
            
        width : float, default 0.9
            Width of bars. No space between bars if width=1.0.
        
        legend_loc : str or pair of float, default (1.02, 0.5)
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        &#34;&#34;&#34;
        
        try:
            self.mass_contribution
        except:
            msg = (&#34;Results for basis species contributions to aqueous mass &#34;
                   &#34;balance could not be found. Ensure that &#34;
                   &#34;get_mass_contribution = True when running speciate().&#34;)
            raise Exception(msg)
            
        if basis not in set(self.mass_contribution[&#39;basis&#39;]):
            msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
                   &#34;among available basis species: &#34;
                   &#34;{}&#34;.format(str(list(set(self.mass_contribution[&#39;basis&#39;]))))+&#34;&#34;)
            raise Exception(msg)
            
        df_sp = copy.deepcopy(self.mass_contribution.loc[self.mass_contribution[&#39;basis&#39;] == basis])
        
        df_sp[&#39;percent&#39;] = df_sp[&#39;percent&#39;].astype(float)
        
        unique_species = unique(df_sp[&#34;species&#34;])
        
        if &#34;Other&#34; in unique_species:

            unique_species.append(unique_species.pop(unique_species.index(&#34;Other&#34;)))
        
        labels = unique(df_sp[&#34;sample&#34;])

        fig, ax = plt.subplots()

        bottom = np.array([0]*len(labels))

        for i,sp in enumerate(unique_species):
            percents = []
            for sample in labels:
                df_sample = df_sp[df_sp[&#34;sample&#34;]==sample]
                try:
                    percent = df_sample[df_sample[&#34;species&#34;]==sp][&#34;percent&#34;].iloc[0]
                    percents.append(percent)
                except:
                    percents.append(0.0)
            ax.bar(labels, percents, width, bottom=bottom, label=sp)
            bottom = bottom + np.array(percents)

        ax.set_ylabel(&#39;%&#39;)
        ax.set_title(&#39;Species accounting for mass balance of &#39;+basis)
        plt.xticks(rotation = 45, ha=&#39;right&#39;)

        ax.legend(loc=legend_loc)
        
        plt.show()


class AqEquil():

    &#34;&#34;&#34;
    Class containing functions to speciate aqueous water chemistry data using
    existing or custom thermodynamic datasets.
    
    Parameters
    ----------
    eq36da : str, defaults to path given by the environment variable EQ36DA
        Path to directory where data1 files are stored. 
        
    eq36co : str, defaults to path given by the environment variable EQ36CO
        Path to directory where EQ3 executables are stored.
    
    Attributes
    ----------
    eq36da : str
        Path to directory where data1 files are stored.
        
    eq36co : str
        Path to directory where EQ3 executables are stored.
        
    df_input_processed : pd.Dataframe
        Pandas dataframe containing user-supplied sample chemistry data that has
        been processed by `speciate`.
        
    out_dict : pd.Dataframe
        Pandas dataframe reporting results of last speciation calculation
        performed by `speciate`.
    
    messages : bool, default True
        Print messages during calculations?
        
    &#34;&#34;&#34;

    def __init__(self,
                 eq36da=os.environ.get(&#39;EQ36DA&#39;),
                 eq36co=os.environ.get(&#39;EQ36CO&#39;)):

        self.eq36da = eq36da
        self.eq36co = eq36co
        self.df_input_processed = None
        self.out_dict = None
        self.messages = True

        os.environ[&#39;EQ36DA&#39;] = self.eq36da  # set eq3 db directory
        os.environ[&#39;EQ36CO&#39;] = self.eq36co  # set eq3 .exe directory
            
    def _check_sample_input_file(self, input_filename, exclude, db, custom_db):
        
        &#34;&#34;&#34;
        Check for problems in sample input file.
        &#34;&#34;&#34;
        
        if &#39;.csv&#39; in input_filename[-4:]:
            if os.path.exists(input_filename) and os.path.isfile(input_filename):
                df_in = pd.read_csv(input_filename, header=None) # no headers for now so colname dupes can be checked
            else:
                err = &#34;Cannot locate input file {}.&#34;.format(input_filename)
                raise Exception(err)
        else:
            err = (&#34;Input file {}&#34;.format(input_filename) + &#34; &#34;
                &#34;must be in comma separated values (.csv) format.&#34;)
            raise Exception(err)
        
        # are there any samples?
        if df_in.shape[0] &lt;= 2:
            err_no_samples = (&#34;The file {}&#34;.format(input_filename) + &#34; &#34;
                &#34;must contain at least three rows: the &#34;
                &#34;first for column names, the second for column subheaders, &#34;
                &#34;followed by one or more rows for sample data.&#34;)
            raise Exception(err_no_samples)
        
        err_list = [] # for appending errors found in the sample input file
        
        # get header list
        col_list = list(df_in.iloc[0, 1:])
        
        # are there blank headers?
        if True in [isinstance(x, float) and x != x for x in col_list]:
            # isinstance(x, float) and x != x is a typesafe way to check for nan
            err_blank_header = (&#34;One or more columns in the sample input &#34;
                &#34;file have blank headers. These might be empty columns. &#34;
                &#34;Only the first column may have a blank header. Remove any &#34;
                &#34;empty columns and/or give each header a name.&#34;)
            raise Exception(err_blank_header)
        
        # are there duplicate headers?
        dupe_cols = list(set([x for x in col_list if col_list.count(x) &gt; 1]))
        if len(dupe_cols) &gt; 0:
            err_dupe_cols = (&#34;Duplicate column names are not allowed. &#34;
                &#34;Duplicate column names were found for:\n&#34;
                &#34;{}&#34;.format(str(dupe_cols)))
            err_list.append(err_dupe_cols)
        
        df_in.columns = df_in.iloc[0] # set column names
        df_in = df_in.drop(df_in.index[0], axis=0) # drop column name row
        df_in_headercheck = copy.deepcopy(df_in.iloc[:,1:]) # drop first column. Deepcopy slice because drop() doesn&#39;t work well with unnamed columns.
                                          
        try:
            df_in_headercheck = df_in_headercheck.drop(exclude, axis=1) # drop excluded columns
        except:
            err_bad_exclude = &#34;err_bad_exclude&#34;
            err_list.append(err_bad_exclude)
        
        # get row list
        row_list = list(df_in.iloc[1:, 0])
        
        # are there blank rows?
        if True in [isinstance(x, float) and x != x for x in row_list]:
            # isinstance(x, float) and x != x is a typesafe way to check for nan
            err_blank_row = (&#34;One or more rows in the sample input &#34;
                &#34;file have blank sample names. These might be empty rows. &#34;
                &#34;Remove any empty rows and/or give each sample a name. Sample &#34;
                &#34;names go in the first column.&#34;)
            raise Exception(err_blank_row)
            
        # are there duplicate rows?
        dupe_rows = list(set([x for x in row_list if row_list.count(x) &gt; 1]))
        if len(dupe_rows) &gt; 0:
            err_dupe_rows = (&#34;Duplicate sample names are not allowed. &#34;
                &#34;Duplicate sample names were found for:\n&#34;
                &#34;{}&#34;.format(str(dupe_rows)))
            err_list.append(err_dupe_rows)
        
        # are column names valid entries in the database?
        if custom_db:
            data0_path = &#34;data0.&#34; + db
        else:
            data0_path = self.eq36da + &#34;/data0.&#34; + db
        if os.path.exists(data0_path) and os.path.isfile(data0_path):
            with open(data0_path) as data0:
                data0_lines = data0.readlines()
                start_index = [i+1 for i, s in enumerate(data0_lines) if &#39;*  species name&#39; in s]
                end_index = [i-1 for i, s in enumerate(data0_lines) if &#39;elements&#39; in s]
                db_species = [i.split()[0] for i in data0_lines[start_index[0]:end_index[0]]]
                for species in list(set(df_in_headercheck.columns)):
                    if species not in db_species and species != &#39;Temperature&#39;:
                        err_species_not_in_db = (&#34;The species &#39;{}&#39;&#34;.format(species) + &#34; &#34;
                            &#34;was not found in {}&#34;.format(data0_path) + &#34;. &#34;
                            &#34;If the column contains data that should not be &#34;
                            &#34;included in the speciation calculation, add the &#34;
                            &#34;column name to the &#39;exclude&#39; argument. Try &#34;
                            &#34;help(AqEquil.AqEquil.speciate) &#34;
                            &#34;for more information about &#39;exclude&#39;.&#34;)
                        err_list.append(err_species_not_in_db)
        else:
            err_no_data0 = (&#34;Could not locate {}.&#34;.format(data0_path) + &#34; &#34;
                &#34;Unable to determine if column headers included in &#34;
                &#34;{} &#34;.format(input_filename) + &#34;match entries for species &#34;
                &#34;in the requested thermodynamic database &#39;{}&#39;.&#34;.format(db))
            err_list.append(err_no_data0)
        
        
        # are subheader units valid?
        subheaders = df_in_headercheck.iloc[0,]
        valid_subheaders = [&#34;degC&#34;, &#34;ppm&#34;, &#34;ppb&#34;, &#34;Suppressed&#34;, &#34;Molality&#34;,
                            &#34;Molarity&#34;, &#34;mg/L&#34;, &#34;mg/kg.sol&#34;, &#34;Alk., eq/kg.H2O&#34;,
                            &#34;Alk., eq/L&#34;, &#34;Alk., eq/kg.sol&#34;, &#34;Alk., mg/L CaCO3&#34;,
                            &#34;Alk., mg/L HCO3-&#34;, &#34;Log activity&#34;, &#34;Log act combo&#34;,
                            &#34;Log mean act&#34;, &#34;pX&#34;, &#34;pH&#34;, &#34;pHCl&#34;, &#34;pmH&#34;, &#34;pmX&#34;,
                            &#34;Hetero. equil.&#34;, &#34;Homo. equil.&#34;, &#34;Make non-basis&#34;]
        for i, subheader in enumerate(subheaders):
            if subheader not in valid_subheaders:
                err_valid_sub = (&#34;The subheader &#39;{}&#39;&#34;.format(subheader) + &#34; &#34;
                    &#34;for the column &#39;{}&#39;&#34;.format(df_in_headercheck.columns[i]) + &#34; &#34;
                    &#34;is not recognized. Valid subheaders are {}&#34;.format(str(valid_subheaders)) + &#34;. &#34;
                    &#34;If the column {}&#34;.format(df_in_headercheck.columns[i]) + &#34; &#34;
                    &#34;contains data that is not meant for the &#34;
                    &#34;speciation calculation, add the column name &#34;
                    &#34;to the &#39;exclude&#39; argument. Try help(AqEquil.AqEquil.speciate) &#34;
                    &#34;for more information about &#39;exclude&#39;.&#34;)
                err_list.append(err_valid_sub)
            
        # is a &#39;Temperature&#39; column present?
        if &#34;Temperature&#34; not in df_in_headercheck.columns and &#34;Temperature&#34; not in exclude:
            err_temp = (&#34;The column &#39;Temperature&#39; was not found in the input file. &#34;
                &#34;Please include a column with &#39;Temperature&#39; in the first row, &#34;
                &#34;&#39;degC&#39; in the second row, and a temperature value for each &#34;
                &#34;sample in degrees Celsius.&#34;)
            err_list.append(err_temp)
        
        # raise exception that outlines all errors found
        if len(err_list) &gt; 0:
            errs = &#34;\n\n*&#34;.join(err_list)
            errs = (&#34;The input file {}&#34;.format(input_filename)+&#34; encountered&#34;
                &#34; errors:\n\n*&#34; + errs)
            raise Exception(errs)
        
        return
        
        
    def __clear_eqpt_extra_output(self):
        
        &#34;&#34;&#34;
        Deletes all EQPT output except data1.
        &#34;&#34;&#34;
        
        if os.path.exists(&#34;eqpt_log.txt&#34;) and os.path.isfile(&#34;eqpt_log.txt&#34;):
            os.remove(&#34;eqpt_log.txt&#34;)
        if os.path.exists(&#34;data1f.txt&#34;) and os.path.isfile(&#34;data1f.txt&#34;):
            os.remove(&#34;data1f.txt&#34;)
        if os.path.exists(&#34;slist.txt&#34;) and os.path.isfile(&#34;slist.txt&#34;):
            os.remove(&#34;slist.txt&#34;)

    def runeqpt(self, db, extra_eqpt_output=False):
        
        &#34;&#34;&#34;
        Convert a data0 into a data1 file with EQPT.
        
        Parameters
        ----------
        db : str
            Three letter code of database.
        
        extra_eqpt_output : bool, default False
            Keep additional output files from EQPT? These files include
            eqpt_log.txt, data1f.txt, and slist.txt.
        &#34;&#34;&#34;

        if os.path.exists(&#34;data0.&#34;+db) and os.path.isfile(&#34;data0.&#34;+db):
            pass
        else:
            raise Exception(&#34;Error: could not locate custom database&#34;,
                            &#34;data0.{} in {}.&#34;.format(db, os.getcwd()))

        if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
            os.remove(&#34;data1.&#34;+db)

        self.__clear_eqpt_extra_output()

        os.environ[&#39;EQ36DA&#39;] = os.getcwd()

        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeqpt&#39;, db]

        try:
            self.__run_script_and_wait(args) # run EQPT
        except:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da
            raise Exception(
                &#34;Error: EQPT failed to run on {}.&#34;.format(&#34;data0.&#34;+db))

        if os.path.exists(&#34;data1&#34;) and os.path.isfile(&#34;data1&#34;):
            os.rename(&#34;data1&#34;, &#34;data1.&#34;+db)
        if os.path.exists(&#34;output&#34;) and os.path.isfile(&#34;output&#34;):
            os.rename(&#34;output&#34;, &#34;eqpt_log.txt&#34;)
        if os.path.exists(&#34;data1f&#34;) and os.path.isfile(&#34;data1f&#34;):
            os.rename(&#34;data1f&#34;, &#34;data1f.txt&#34;)
        if os.path.exists(&#34;slist&#34;) and os.path.isfile(&#34;slist&#34;):
            os.rename(&#34;slist&#34;, &#34;slist.txt&#34;)

        if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
            if self.messages:
                print(&#34;Successfully created a data1.&#34;+db+&#34; from data0.&#34;+db)
        else:
            msg = (&#34;EQPT could not create data1.&#34;+db+&#34; from &#34;
                   &#34;data0.&#34;+db+&#34;. Check eqpt_log.txt for details.&#34;)
            raise Exception(msg)

        if not extra_eqpt_output:
            self.__clear_eqpt_extra_output()

        os.environ[&#39;EQ36DA&#39;] = self.eq36da  # reset default EQ3 db path

    def runeq3(self, filename_3i, db,
               path_3i=os.getcwd(),
               path_3o=os.getcwd(),
               path_3p=os.getcwd()):
        
        &#34;&#34;&#34;
        Call EQ3 on a .3i input file.
        
        Parameters
        ----------
        filename_3i : str
            Name of 3i input file.
        
        db : str
            Three letter code of database.
        &#34;&#34;&#34;

        # get current working dir
        cwd = os.getcwd()

        print(&#39;Calling EQ3 on &#39; + filename_3i + &#39; using &#39; + db)
        os.chdir(path_3i)  # step into 3i folder
        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq3&#39;, db, filename_3i]

        self.__run_script_and_wait(args) # run EQ3

        # restore working dir
        os.chdir(cwd)

        filename_3o = filename_3i[:-1] + &#39;o&#39;
        filename_3p = filename_3i[:-1] + &#39;p&#39;

        try:
            # rename output
            os.rename(path_3i + &#39;/output&#39;, path_3i + &#34;/&#34; + filename_3o)
        except:
            print(&#39;Error: EQ3 failed to produce output for &#39; + filename_3i)

        try:
            # move output
            shutil.move(path_3i + &#34;/&#34; + filename_3o,
                        path_3o + &#34;/&#34; + filename_3o)
        except:
            print(&#39;Error: Could not move&#39;, filename_3o, &#34;to&#34;, path_3o)

        try:
            # rename pickup
            os.rename(path_3i + &#39;/pickup&#39;, path_3i + &#34;/&#34; + filename_3p)
        except:
            print(&#39;Error: EQ3 failed to produce a pickup file for &#39; + filename_3i)

        try:
            # move pickup
            shutil.move(path_3i + &#34;/&#34; + filename_3p,
                        path_3p + &#34;/&#34; + filename_3p)
        except:
            print(&#39;Error: Could not move&#39;, filename_3p, &#34;to&#34;, path_3p)

    def __mk_check_del_directory(self, path):
        
        &#34;&#34;&#34;
        Checks for the dir being created. If it is already present, delete it
        before recreating it.
        &#34;&#34;&#34;
        
        if not os.path.exists(path):
            os.makedirs(path)
        else:
            shutil.rmtree(path)
            os.makedirs(path)

    def __read_inputs(self, file_type, location):
        
        &#34;&#34;&#34;
        Finds all files of a filetype in all downstream folders.
        &#34;&#34;&#34;
        
        file_name = []  # file names
        file_list = []  # file names with paths
        for root, dirs, files in os.walk(location):
            for file in files:
                if file.endswith(file_type):
                    if &#34;-checkpoint&#34; not in file:
                        file_name.append(file)
                        file_list.append(os.path.join(root, file))
        return file_name, file_list

    def __run_script_and_wait(self, args):
        
        &#34;&#34;&#34;
        Runs shell commands.
        &#34;&#34;&#34;
        
        with open(os.devnull, &#39;w&#39;) as fp:  # devnull supresses written output
            Popen(args, stdout=fp).wait()

    def _delete_rxn_folders(self):
        
        &#34;&#34;&#34;
        Deletes folders storing raw EQ3 input and output.
        &#34;&#34;&#34;
        
        if os.path.exists(&#39;rxn_3i&#39;) and os.path.isdir(&#39;rxn_3i&#39;):
            shutil.rmtree(&#39;rxn_3i&#39;)
        if os.path.exists(&#39;rxn_3o&#39;) and os.path.isdir(&#39;rxn_3o&#39;):
            shutil.rmtree(&#39;rxn_3o&#39;)
        if os.path.exists(&#39;rxn_3p&#39;) and os.path.isdir(&#39;rxn_3p&#39;):
            shutil.rmtree(&#39;rxn_3p&#39;)

    def speciate(self,
                 input_filename,
                 db=&#34;jus&#34;,
                 redox_flag=0,
                 redox_aux=&#34;Fe+3&#34;,
                 default_logfO2=-6,
                 exclude=[],
                 suppress=[],
                 charge_balance_on=&#34;none&#34;,
                 suppress_missing=True,
                 verbose=1,
                 report_filename=None,
                 get_aq_dist=True,
                 aq_dist_type=&#34;log_activity&#34;,
                 get_mass_contribution=True,
                 mass_contribution_other=True,
                 get_mineral_sat=True,
                 mineral_sat_type=&#34;affinity&#34;,
                 get_redox=True,
                 redox_type=&#34;Eh&#34;,
                 get_affinity_energy=False,
                 rxn_filename=None,
                 not_limiting=[&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;],
                 get_charge_balance=True,
                 custom_db=False,
                 extra_eqpt_output=False,
                 batch_3o_filename=None,
                 delete_generated_folders=False):
        
        &#34;&#34;&#34;
        Calculate the equilibrium distribution of chemical species in solution.
        Additionally, calculate chemical affinities and energy supplies for
        user-specified reactions.
        
        Parameters
        ----------
        input_filename : str
            User-supplied utf8-encoded comma separated value (csv) file
            containing sample data intended for speciation. The file must
            follow this format:
            
            - the first row is a header row that must contain the names of the
              species to be included in the speciation calculation. There
              cannot be duplicate headers.
            - the second row must contain subheaders for each species in the
              header row. These subheaders must be taken from the following:
              
                    degC
                    ppm
                    ppb
                    Suppressed
                    Molality
                    Molarity
                    mg/L
                    mg/kg.sol
                    Alk., eq/kg.H2O
                    Alk., eq/L
                    Alk., eq/kg.sol
                    Alk., mg/L CaCO3
                    Alk., mg/L HCO3-
                    Log activity
                    Log act combo
                    Log mean act
                    pX
                    pH
                    pHCl
                    pmH
                    pmX
                    Hetero. equil.
                    Homo. equil.
                    Make non-basis
                    
            - &#39;Temperature&#39; must be included as a header, with &#39;degC&#39; as its
              subheader.
            - The first column must contain sample names. There cannot be
              duplicate sample names.
        
        db : three letter str, default &#34;jus&#34;
            Three letter file extension for the desired thermodynamic database.
            If `custom_db` is False, this database must be named data1.xyz
            (where xyz is your desired three letter extension) and located
            in the EQ3/6 &#39;EQ36DA&#39; path. Otherwise, the database must be named
            data0.xyz and located in your current working directory. Note that
            data1 files are already compiled by EQPT, while data0 files will be
            automatically compiled for you if `custom_db` is True.
        
        redox_flag : int, default 0
            Values corresponding to redox options in the EQ3/6 v8.0 software.
            For more information see the &#39;Redox Option&#39; section of the EQ3/6
            version 8.0 software user&#39;s manual. Set sample redox state with the
            following options:
            
            * -3 for O2(g)
            * -2 for pe (in pe units)
            * -1 for Eh (volts)
            *  0 for logfO2 (log bars), or dissolved O2 (see below)
            *  1 for defining a redox couple (see `redox_aux`)
             
            Note that if you are importing water chemistry data from a
            spreadsheet, a column must be supplied with data that corresponds to
            the redox option you chose. The column name is important:
            
            * -3 must have a column named: O2(g)
            * -2 must have a column named: pe
            * -1 must have a column named: Eh
            *  0 must have a column named: logfO2
            *  1 must have a column corresponding to the auxilliary basis species
              selected to form a redox couple with its linked species (see
              `redox_aux`). For example, the redox couple Fe+2/Fe+3 would need
              a column named: Fe+3
            
            If an appropriate header or redox data cannot be found to define
            redox state, `default_logfO2` is used to set sample logfO2.
            
            There is a special case where dissolved oxygen can be used to impose
            sample redox state if `redox_flag` is set to 0 and a column named
            logfO2 does not appear in the sample data sheet. If there is a
            column corresponding to dissolved oxygen measurements, logfO2 is
            calculated from the equilibrium reaction O2(aq) = O2(g) at the
            temperature and pressure of the sample using the revised Helgeson-
            Kirkham-Flowers (HKF) equation of state (JC Tanger IV and HC
            Helgeson, Am. J. Sci., 1988, 288, 19).
        
        redox_aux : default &#34;Fe+3&#34;, optional
            Ignored unless `redox_flag` equals 1. Name of the auxilliary species
            whose reaction links it to a basis species (or another auxilliary
            species) such that they form a redox couple that controls sample
            fO2. For instance, Fe+3 is linked to Fe+2 in many supporting data
            files, so selecting `redox_flag` = 1 and `redox_aux` = &#34;Fe+3&#34; will
            set sample fO2 based on the Fe+2/Fe+3 redox couple.
        
        default_logfO2 : float, default -6
            Default value for sample logfO2 in case redox data cannot be found
            in the user-supplied sample spreadsheet.
        
        exclude : list of str, default []
            Names of columns in the user-supplied sample spreadsheet that should
            not be considered aqueous species. Useful for excluding columns
            containing sample metatadata, such as &#34;Year&#34; and &#34;Location&#34;.
            
        suppress : list of str, default []
            Names of chemical species that will be prevented from forming in the
            speciation calculation.
            
        charge_balance_on : str, default &#34;none&#34;
            If &#34;none&#34;, will not balance electrical charge between cations and
            anions in the speciation calculation. If a name of a species is
            supplied instead, the activity of that species will be allowed to
            change until charge balance is obtained. For example,
            charge_balance_on = &#34;H+&#34; will calculate what pH a sample must have
            to have zero net charge.
        
        suppress_missing : bool, default True
            Suppress the formation of an aqueous species if it is missing a
            value in the user-supplied sample spreadsheet?
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
            
        report_filename : str, optional
            Name of the comma separated values (csv) report file generated when
            the calculation is complete. If this argument is not defined, a
            report file is not generated.
            
        get_aq_dist : bool, default True
            Calculate distributions of aqueous species?
        
        aq_dist_type : str, default &#34;log_activity&#34;
            Desired units of measurement for reported distributions of aqueous
            species. Can be &#34;molality&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, or
            &#34;log_activity&#34;. Ignored if `get_aq_dist` is False.
        
        get_mass_contribution : bool, default True
            Calculate basis species contributions to mass balance of aqueous
            species?
        
        mass_contribution_other : bool, default True
            Include an &#34;other&#34; species for the sake of summing percents of basis
            species contributions to 100%? Ignored if `get_mass_contribution` is
            False.
        
        get_mineral_sat : bool, default True
            Calculate saturation states of pure solids?
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Desired units of measurement for reported saturation states of pure
            solids. Can be &#34;logQoverK&#34; or &#34;affinity&#34;. Ignored if
            `get_mineral_sat` is False.
        
        get_redox : bool, default True
            Calculate potentials of redox couples?
            
        redox_type : str, default &#34;Eh&#34;
            Desired units of measurement for reported redox potentials. Can be
            &#34;Eh&#34;, &#34;pe&#34;, &#34;logfO2&#34;, or &#34;Ah&#34;. Ignored if `get_redox` is False.
            
        get_affinity_energy : bool, default False
            Calculate affinities and energy supplies of reactions listed in a
            separate user-supplied file?
        
        rxn_filename : str, optional
            Name of file containing reactions used to calculate affinities and
            energy supplies. Ignored if `get_affinity_energy` is False.
        
        not_limiting : list, default [&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;]
            List containing names of species that are not considered limiting
            when calculating energy supplies. Ignored if `get_affinity_energy`
            is False.
        
        get_charge_balance : bool, default True
            Calculate charge balance and ionic strength?
            
        custom_db : bool, default False
            Is the database defined by `db` a custom user-supplied database? If
            this is set to True, searches for a data0.xyz file in the current
            working directory, where &#39;xyz&#39; corresponds to the three letter code
            assigned to `db`. This data0 file is automatically converted into a
            machine-readable file called data1 by software called EQPT. This
            data1 file is then used in speciation calculations.
        
        extra_eqpt_output : bool, default False
            Keep additional output files created by EQPT (see `custom_db`)?
            Ignored if `custom_db` is False.
        
        batch_3o_filename : str, optional
            Name of rds (R object) file exported after the speciation
            calculation? No file will be generated if this argument is not
            defined.
            
        delete_generated_folders : bool, default False
            Delete the &#39;rxn_3i&#39;, &#39;rxn_3o&#39;, and &#39;rxn_3p&#39; folders containing raw
            EQ3NR input, output, and pickup files once the speciation
            calculation is complete?
        
        Returns
        -------
        speciation : object of class Speciation
            Contains the results of the speciation calculation.
        
        &#34;&#34;&#34;
        
        # check input sample file for errors
        self._check_sample_input_file(input_filename, exclude, db, custom_db)
        
        # handle batch_3o naming
        if batch_3o_filename != None:
            if &#34;.rds&#34; in batch_3o_filename[-4:]:
                batch_3o_filename = batch_3o_filename
            else:
                batch_3o_filename = &#34;batch_3o_{}.rds&#34;.format(db)
        else:
            batch_3o_filename = ro.r(&#34;NULL&#34;)

        if custom_db:
            # EQ3/6 cannot handle spaces in the &#39;EQ36DA&#39; path name.
            if &#34; &#34; in os.getcwd():
                msg = (&#34;Error: the path to the custom database &#34;
                    &#34;cannot contain spaces. The current path &#34;
                    &#34;is: [ &#34; + os.getcwd() + &#34; ]. Remove or &#34;
                    &#34;replace spaces in folder names for this &#34;
                    &#34;feature. Example: [ &#34; + os.getcwd().replace(&#34; &#34;, &#34;-&#34;) + &#34; ].&#34;)
                raise Exception(msg)

            self.runeqpt(db, extra_eqpt_output)
            os.environ[&#39;EQ36DA&#39;] = os.getcwd()

        if get_affinity_energy:
            if rxn_filename == None:
                wrn = (&#34;A reaction file was not specified. Affinities and &#34;
                    &#34;energy supplies will not be calculated.&#34;)
                warnings.warn(wrn)
                get_affinity_energy = False
                rxn_filename = &#34;&#34;
            elif os.path.exists(rxn_filename) and os.path.isfile(rxn_filename):
                pass
            else:
                wrn = (&#34;Reaction file {} was not found. Affinities and &#34;
                    &#34;energy supplies will not be &#34;
                    &#34;calculated.&#34;.format(rxn_filename))
                warnings.warn(wrn)
                get_affinity_energy = False
                rxn_filename = &#34;&#34;
        else:
            rxn_filename = &#34;&#34;

        # preprocess for eq3 using R scripts
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_prescript = pkg_resources.resource_string(
                __name__, &#39;preprocess_for_EQ3.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_prescript)
            df_input_processed = ro.r.preprocess(input_filename=input_filename,
                                                 exclude=convert_to_RVector(
                                                     exclude),
                                                 redox_flag=redox_flag,
                                                 default_logfO2=default_logfO2,
                                                 charge_balance_on=charge_balance_on,
                                                 suppress_missing=suppress_missing,
                                                 suppress=convert_to_RVector(
                                                     suppress),
                                                 verbose=verbose)

        for warning in w:
            print(warning.message)

        self.df_input_processed = pandas2ri.ri2py_dataframe(df_input_processed)

        # run EQ3 on each input file
        cwd = os.getcwd()

        self.__mk_check_del_directory(&#39;rxn_3o&#39;)
        self.__mk_check_del_directory(&#39;rxn_3p&#39;)
        files_3i, files_3i_paths = self.__read_inputs(&#39;3i&#39;, &#39;rxn_3i&#39;)

        input_dir = cwd + &#34;/rxn_3i/&#34;
        output_dir = cwd + &#34;/rxn_3o/&#34;
        pickup_dir = cwd + &#34;/rxn_3p/&#34;
        
        for file in files_3i:
            self.runeq3(filename_3i=file, db=db, path_3i=input_dir,
                        path_3o=output_dir, path_3p=pickup_dir)

        if custom_db:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da

        files_3o = [file+&#34;.3o&#34; for file in self.df_input_processed.index]
        
        df_input_processed_names = convert_to_RVector(list(self.df_input_processed.columns))
        
        # mine output
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_3o_mine = pkg_resources.resource_string(
                __name__, &#39;3o_mine.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_3o_mine)
            batch_3o = ro.r.main_3o_mine(
                files_3o=convert_to_RVector(files_3o),
                input_filename=input_filename,
                rxn_filename=rxn_filename,
                get_aq_dist=get_aq_dist,
                aq_dist_type=aq_dist_type,
                get_mass_contribution=get_mass_contribution,
                mass_contribution_other=mass_contribution_other,
                get_mineral_sat=get_mineral_sat,
                mineral_sat_type=mineral_sat_type,
                get_redox=get_redox,
                redox_type=redox_type,
                get_charge_balance=get_charge_balance,
                get_affinity_energy=get_affinity_energy,
                not_limiting=convert_to_RVector(not_limiting),
                batch_3o_filename=batch_3o_filename,
                df_input_processed=pandas2ri.py2ri(self.df_input_processed),
                # Needed for keeping symbols in column names after porting
                #   df_input_processed in the line above. Some kind of check.names
                #   option for pandas2ri.py2ri would be nice. Workaround:
                df_input_processed_names=df_input_processed_names,
            )
        for warning in w:
            print(warning.message)
        
        if get_mass_contribution:
            mass_contribution = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;mass_contribution&#39;))
        df_report = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;report&#39;))
        df_input = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;input&#39;))
        report_divs = batch_3o.rx2(&#39;report_divs&#39;)

        input_cols = list(report_divs.rx2(&#39;input&#39;))
        df_input = df_report.loc[:, input_cols]

        # handle headers and subheaders of input section
        headers = [col.split(&#34;_&#34;)[0] for col in list(df_input.columns)]
        headers = [&#34;pH&#34; if header == &#34;H+&#34; else header for header in headers]
        headers = [header+&#34;_(input)&#34; if header not in [&#34;Temperature&#34;, &#34;pH&#34;]+exclude else header for header in headers]
        subheaders = [subheader[1] if len(subheader) &gt; 1 else &#34;&#34; for subheader in [
            col.split(&#34;_&#34;) for col in list(df_input.columns)]]
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_input.columns = multicolumns

        df_join = df_input

        if get_aq_dist:
            aq_distribution_cols = list(report_divs.rx2(&#39;aq_distribution&#39;))
            df_aq_distribution = df_report.loc[:, aq_distribution_cols]
            df_aq_distribution = df_aq_distribution.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of aq_distribution section
            headers = df_aq_distribution.columns
            subheaders = [aq_dist_type]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_aq_distribution.columns = multicolumns
            df_join = df_join.join(df_aq_distribution)

        if get_mineral_sat:
            mineral_sat_cols = list(report_divs.rx2(&#39;mineral_sat&#39;))
            df_mineral_sat = df_report.loc[:, mineral_sat_cols]
            df_mineral_sat = df_mineral_sat.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_mineral_sat section
            if mineral_sat_type == &#34;affinity&#34;:
                mineral_sat_unit = &#34;affinity_kcal&#34;
            elif mineral_sat_type == &#34;logQoverK&#34;:
                mineral_sat_unit = &#34;logQ/K&#34;
            else:
                raise Exception(
                    &#34;mineral_sat_type must be either &#39;affinity&#39; or &#39;logQoverK&#39;&#34;)

            headers = df_mineral_sat.columns
            subheaders = [mineral_sat_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_mineral_sat.columns = multicolumns
            df_join = df_join.join(df_mineral_sat)

        if get_redox:
            redox_cols = list(report_divs.rx2(&#39;redox&#39;))
            df_redox = df_report.loc[:, redox_cols]
            df_redox = df_redox.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_redox section
            if redox_type == &#34;Eh&#34;:
                redox_unit = &#34;Eh_volts&#34;
            elif redox_type == &#34;pe&#34;:
                redox_unit = &#34;pe&#34;
            elif redox_type == &#34;logfO2&#34;:
                redox_unit = &#34;logfO2&#34;
            elif redox_type == &#34;Ah&#34;:
                redox_unit = &#34;Ah_kcal&#34;
            else:
                raise Exception(
                    &#34;redox_type must be either &#39;Eh&#39;, &#39;pe&#39;, &#39;logfO2&#39;, or &#39;Ah&#39;&#34;)

            headers = df_redox.columns
            subheaders = [redox_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_redox.columns = multicolumns
            df_join = df_join.join(df_redox)

        if get_charge_balance:
            charge_balance_cols = list(report_divs.rx2(&#39;charge_balance&#39;))
            df_charge_balance = df_report.loc[:, charge_balance_cols]
            df_charge_balance = df_charge_balance.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_charge_balance section
            headers = df_charge_balance.columns
            subheaders = [&#34;%&#34;]*2 + [&#39;eq/kg.H2O&#39;, &#39;molality&#39;] + \
                [&#39;eq/kg.H2O&#39;]*4 + [&#39;molality&#39;]
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_charge_balance.columns = multicolumns
            df_join = df_join.join(df_charge_balance)

        if get_affinity_energy:
            affinity_cols = list(report_divs.rx2(&#39;affinity&#39;))
            energy_cols = list(report_divs.rx2(&#39;energy&#39;))
            df_affinity = df_report.loc[:, affinity_cols]
            df_energy = df_report.loc[:, energy_cols]
            df_affinity = df_affinity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            df_energy = df_energy.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_affinity section
            headers = df_affinity.columns
            subheaders = [&#39;cal/mol e-&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_affinity.columns = multicolumns

            # handle headers of df_energy section
            headers = df_energy.columns
            subheaders = [&#39;cal/kg.H2O&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_energy.columns = multicolumns
            df_join = df_join.join(df_affinity)
            df_join = df_join.join(df_energy)

        out_dict = {&#39;sample_data&#39;: {},
                    &#39;report&#39;: df_join,
                    &#39;input&#39;: df_input, &#39;report_divs&#39;: report_divs}
        
        if get_mass_contribution:
            out_dict[&#39;mass_contribution&#39;] = mass_contribution

        sample_data = batch_3o.rx2(&#39;sample_data&#39;)

        # assemble sample data
        for i, sample in enumerate(sample_data):
            dict_sample_data = {
                &#34;filename&#34;: str(sample.rx2(&#39;filename&#39;)[0]),
                &#34;name&#34;: str(sample.rx2(&#39;name&#39;)[0]),
                &#34;temperature&#34;: float(sample.rx2(&#39;temperature&#39;)[0]),
                &#34;pressure&#34;: float(sample.rx2(&#39;pressure&#39;)[0]),
                &#34;logact_H2O&#34;: float(sample.rx2(&#39;logact_H2O&#39;)[0]),
                &#34;H2O_density&#34;: float(sample.rx2(&#39;H2O_density&#39;)[0]),
                &#34;H2O_molality&#34;: float(sample.rx2(&#39;H2O_molality&#39;)[0]),
                &#34;H2O_log_molality&#34;: float(sample.rx2(&#39;H2O_log_molality&#39;)[0]),
                }

            if get_aq_dist:
                sample_aq_dist = pandas2ri.ri2py_dataframe(sample.rx2(&#39;aq_distribution&#39;))
                sample_aq_dist = sample_aq_dist.apply(pd.to_numeric, errors=&#39;coerce&#39;)
                dict_sample_data.update({&#34;aq_distribution&#34;: sample_aq_dist})

            if get_mass_contribution:
                sample_mass_contribution = mass_contribution[mass_contribution[&#34;sample&#34;] == sample.rx2(&#39;name&#39;)[0]]
                dict_sample_data.update(
                    {&#34;mass_contribution&#34;: sample_mass_contribution})

            if get_mineral_sat:
                dict_sample_data.update(
                    {&#34;mineral_sat&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;mineral_sat&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            if get_redox:
                dict_sample_data.update(
                    {&#34;redox&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;redox&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            if get_charge_balance:
                dict_sample_data.update({&#34;charge_balance&#34;: df_charge_balance.loc[sample.rx2(&#39;name&#39;)[0], :]})

            if get_affinity_energy:
                dict_sample_data.update({&#34;affinity_energy_raw&#34;: pandas2ri.ri2py_dataframe(
                    sample.rx2(&#39;affinity_energy_raw&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                dict_sample_data.update(
                    {&#34;affinity_energy&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;affinity_energy&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            out_dict[&#34;sample_data&#34;].update(
                {sample_data.names[i]: dict_sample_data})

        out_dict.update({&#34;batch_3o&#34;: batch_3o})
        speciation = Speciation(out_dict)

        if report_filename != None:
            if &#34;.csv&#34; in report_filename[-4:]:
                out_dict[&#34;report&#34;].to_csv(report_filename)
            else:
                out_dict[&#34;report&#34;].to_csv(report_filename+&#34;.csv&#34;)

        if delete_generated_folders:
            self._delete_rxn_folders()

        return speciation

    def create_data0(self,
                     filename,
                     supp_file,
                     supp_file_ss=None,
                     data0_formula_ox_name=None,
                     suppress_redox=[],
                     db=&#34;wrm&#34;,
                     exceed_Ttr=True,
                     grid_temps=[0.0100, 50.0000, 100.0000, 150.0000,
                                 200.0000, 250.0000, 300.0000, 350.0000],
                     grid_press=&#34;Psat&#34;,
                     infer_formula_ox=False,
                     basis_prefs={},
                     generate_template=True,
                     template_name=None,
                     verbose=1):
        &#34;&#34;&#34;
        Create a data0 file from a custom thermodynamic dataset.
        
        Parameters
        ----------
        filename : str
            Name of csv file containing thermodynamic data in the OBIGT format.
            
        supp_file : str
            Path of file containing data0-specific parameters.
            
        supp_file_ss : str, optional
            Name of file containing solid solution parameters.
        
        data0_formula_ox_name : str, optional
            Name of supplementary file containing data0 parameters and inferred
            formula oxidation states. Ignored if `infer_formula_ox` is False.
            See `infer_formula_ox` for more detail.
        
        suppress_redox : list of str, default []
            Suppress equilibrium between oxidation states of listed elements
            (Cl, H, and O cannot be included).
        
        db : str, default &#34;wrm&#34;
            Desired three letter code of data0 output.

        exceed_Ttr : bool, default True
            Calculate Gibbs energies of mineral phases and other species
            beyond their transition temperatures?

        grid_temps : list of eight float, default [0.0100, 50.0000, 100.0000, 150.0000, 200.0000, 250.0000, 300.0000, 350.0000]
            Eight temperature values that make up the T-P grid.
        
        grid_press : list of float, default &#34;Psat&#34;
            Eight pressure values that make up the T-P grid. &#34;Psat&#34; for
            calculations along the liquid-vapor saturation curve.

        infer_formula_ox : bool, default False
            Create a supplementary file containing data0 parameters and
            inferred formula oxidation states? This option is useful for
            creating as many entries in the formula_ox column when creating a
            new supplementary file. Note that compounds like DySO4+ result in
            blank entries in formula_ox because the redox states of two
            elements, Dy and S, would have to be estimated together; S has many
            oxidation states and Dy&#39;s oxidation states are not hard-coded.
        
        generate_template : bool, default True
            Generate a CSV sample input template customized to this data0?
        
        template_name : str, optional
            Name of the sample input template file generated. If no name is
            supplied, defaults to &#39;sample_template_xyz.csv&#39;, where &#39;xyz&#39; is
            the three letter code given to `db`. Ignored if `generate_template`
            is False.
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
        &#34;&#34;&#34;

        if verbose &gt;= 1:
            print(&#34;Creating data0.{}...&#34;.format(db))
        
        if sum([T &gt;= 10000 for T in grid_temps]):
            raise Exception(&#34;Grid temperatures must be below 10000 °C.&#34;)
        
        if isinstance(grid_press, list):
            if sum([T &gt;= 10000 for T in grid_temps]):
                raise Exception(&#34;Grid pressures must be below 10000 bars.&#34;)
        
        template = pkg_resources.resource_string(
            __name__, &#39;data0.min&#39;).decode(&#34;utf-8&#34;)
        grid_temps = convert_to_RVector(grid_temps)
        grid_press = convert_to_RVector(grid_press)
        suppress_redox = convert_to_RVector(suppress_redox)
        bp_values = list(basis_prefs.values())
        bp_keys = list(basis_prefs.keys())
        basis_prefs = convert_to_RVector(bp_values)
        basis_pref_names = convert_to_RVector(bp_keys)
        
        if supp_file_ss == None:
            supp_file_ss = ro.r(&#34;NULL&#34;)
        if data0_formula_ox_name == None:
            data0_formula_ox_name = ro.r(&#34;NULL&#34;)
        if template_name == None:
            template_name = &#34;sample_template_{}.csv&#34;.format(db)

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_create_data0 = pkg_resources.resource_string(
                __name__, &#39;create_data0.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_create_data0)
            ro.r.main_create_data0(filename=filename,
                                   supp_file=supp_file,
                                   supp_file_ss=supp_file_ss,
                                   grid_temps=grid_temps,
                                   grid_press=grid_press,
                                   db=db,
                                   template=template,
                                   exceed_Ttr=exceed_Ttr,
                                   data0_formula_ox_name=data0_formula_ox_name,
                                   suppress_redox=suppress_redox,
                                   infer_formula_ox=infer_formula_ox,
                                   generate_template=generate_template,
                                   template_name=template_name,
                                   verbose=verbose,
                                   basis_prefs=basis_prefs,
                                   basis_pref_names=basis_pref_names)
    
        for warning in w:
            print(warning.message)
        
        if verbose &gt;= 1:
            print(&#34;Finished creating data0.{}.&#34;.format(db))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="AqEquil.AqSpeciation.convert_to_RVector"><code class="name flex">
<span>def <span class="ident">convert_to_RVector</span></span>(<span>value, force_Rvec=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a value or list into an R vector of the appropriate type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>numeric</code> or <code>str,</code> or <code>list</code> of <code>numeric</code> or <code>str</code></dt>
<dd>Value to be converted.</dd>
<dt><strong><code>force_Rvec</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If <code>value</code> is not a list, force conversion into a R vector?
False will return an int, float, or str if value is non-list.
True will always return an R vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int, float, str,</code> or <code>an rpy2 R vector</code></dt>
<dd>A value or R vector of an appropriate data type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_RVector(value, force_Rvec=True):
    
    &#34;&#34;&#34;
    Convert a value or list into an R vector of the appropriate type.
    
    Parameters
    ----------
    value : numeric or str, or list of numeric or str
        Value to be converted.
    
    force_Rvec : bool, default True
        If `value` is not a list, force conversion into a R vector?
        False will return an int, float, or str if value is non-list.
        True will always return an R vector.
    
    Returns
    -------
    int, float, str, or an rpy2 R vector
        A value or R vector of an appropriate data type.
    &#34;&#34;&#34;

    if not isinstance(value, list) and not force_Rvec:
        return value
    elif not isinstance(value, list) and force_Rvec:
        value = [value]
    else:
        pass

    if all(isinstance(x, bool) for x in value):
        return ro.BoolVector(value)
    elif all(isinstance(x, int) for x in value):
        return ro.IntVector(value)
    elif all(isinstance(x, float) or isinstance(x, int) for x in value):
        return ro.FloatVector(value)
    else:
        return ro.StrVector(value)</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename, messages=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a speciation file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the speciation file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An object of class <code><a title="AqEquil.AqSpeciation.Speciation" href="#AqEquil.AqSpeciation.Speciation">Speciation</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(filename, messages=True):
    &#34;&#34;&#34;
    Load a speciation file.

    Parameters
    ----------
    filename : str
        Name of the speciation file.

    Returns
    ----------
    An object of class `Speciation`.
    &#34;&#34;&#34;

    with open(filename, &#39;rb&#39;) as handle:
        speciation = pickle.load(handle)
        if messages:
            print(&#34;Loaded &#39;{}&#39;&#34;.format(filename))
        return speciation</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.unique"><code class="name flex">
<span>def <span class="ident">unique</span></span>(<span>seq)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unique(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AqEquil.AqSpeciation.AqEquil"><code class="flex name class">
<span>class <span class="ident">AqEquil</span></span>
<span>(</span><span>eq36da=None, eq36co=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class containing functions to speciate aqueous water chemistry data using
existing or custom thermodynamic datasets.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eq36da</code></strong> :&ensp;<code>str, defaults to path given by the environment variable EQ36DA</code></dt>
<dd>Path to directory where data1 files are stored.</dd>
<dt><strong><code>eq36co</code></strong> :&ensp;<code>str, defaults to path given by the environment variable EQ36CO</code></dt>
<dd>Path to directory where EQ3 executables are stored.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>eq36da</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory where data1 files are stored.</dd>
<dt><strong><code>eq36co</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory where EQ3 executables are stored.</dd>
<dt><strong><code>df_input_processed</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe containing user-supplied sample chemistry data that has
been processed by <code>speciate</code>.</dd>
<dt><strong><code>out_dict</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe reporting results of last speciation calculation
performed by <code>speciate</code>.</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Print messages during calculations?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AqEquil():

    &#34;&#34;&#34;
    Class containing functions to speciate aqueous water chemistry data using
    existing or custom thermodynamic datasets.
    
    Parameters
    ----------
    eq36da : str, defaults to path given by the environment variable EQ36DA
        Path to directory where data1 files are stored. 
        
    eq36co : str, defaults to path given by the environment variable EQ36CO
        Path to directory where EQ3 executables are stored.
    
    Attributes
    ----------
    eq36da : str
        Path to directory where data1 files are stored.
        
    eq36co : str
        Path to directory where EQ3 executables are stored.
        
    df_input_processed : pd.Dataframe
        Pandas dataframe containing user-supplied sample chemistry data that has
        been processed by `speciate`.
        
    out_dict : pd.Dataframe
        Pandas dataframe reporting results of last speciation calculation
        performed by `speciate`.
    
    messages : bool, default True
        Print messages during calculations?
        
    &#34;&#34;&#34;

    def __init__(self,
                 eq36da=os.environ.get(&#39;EQ36DA&#39;),
                 eq36co=os.environ.get(&#39;EQ36CO&#39;)):

        self.eq36da = eq36da
        self.eq36co = eq36co
        self.df_input_processed = None
        self.out_dict = None
        self.messages = True

        os.environ[&#39;EQ36DA&#39;] = self.eq36da  # set eq3 db directory
        os.environ[&#39;EQ36CO&#39;] = self.eq36co  # set eq3 .exe directory
            
    def _check_sample_input_file(self, input_filename, exclude, db, custom_db):
        
        &#34;&#34;&#34;
        Check for problems in sample input file.
        &#34;&#34;&#34;
        
        if &#39;.csv&#39; in input_filename[-4:]:
            if os.path.exists(input_filename) and os.path.isfile(input_filename):
                df_in = pd.read_csv(input_filename, header=None) # no headers for now so colname dupes can be checked
            else:
                err = &#34;Cannot locate input file {}.&#34;.format(input_filename)
                raise Exception(err)
        else:
            err = (&#34;Input file {}&#34;.format(input_filename) + &#34; &#34;
                &#34;must be in comma separated values (.csv) format.&#34;)
            raise Exception(err)
        
        # are there any samples?
        if df_in.shape[0] &lt;= 2:
            err_no_samples = (&#34;The file {}&#34;.format(input_filename) + &#34; &#34;
                &#34;must contain at least three rows: the &#34;
                &#34;first for column names, the second for column subheaders, &#34;
                &#34;followed by one or more rows for sample data.&#34;)
            raise Exception(err_no_samples)
        
        err_list = [] # for appending errors found in the sample input file
        
        # get header list
        col_list = list(df_in.iloc[0, 1:])
        
        # are there blank headers?
        if True in [isinstance(x, float) and x != x for x in col_list]:
            # isinstance(x, float) and x != x is a typesafe way to check for nan
            err_blank_header = (&#34;One or more columns in the sample input &#34;
                &#34;file have blank headers. These might be empty columns. &#34;
                &#34;Only the first column may have a blank header. Remove any &#34;
                &#34;empty columns and/or give each header a name.&#34;)
            raise Exception(err_blank_header)
        
        # are there duplicate headers?
        dupe_cols = list(set([x for x in col_list if col_list.count(x) &gt; 1]))
        if len(dupe_cols) &gt; 0:
            err_dupe_cols = (&#34;Duplicate column names are not allowed. &#34;
                &#34;Duplicate column names were found for:\n&#34;
                &#34;{}&#34;.format(str(dupe_cols)))
            err_list.append(err_dupe_cols)
        
        df_in.columns = df_in.iloc[0] # set column names
        df_in = df_in.drop(df_in.index[0], axis=0) # drop column name row
        df_in_headercheck = copy.deepcopy(df_in.iloc[:,1:]) # drop first column. Deepcopy slice because drop() doesn&#39;t work well with unnamed columns.
                                          
        try:
            df_in_headercheck = df_in_headercheck.drop(exclude, axis=1) # drop excluded columns
        except:
            err_bad_exclude = &#34;err_bad_exclude&#34;
            err_list.append(err_bad_exclude)
        
        # get row list
        row_list = list(df_in.iloc[1:, 0])
        
        # are there blank rows?
        if True in [isinstance(x, float) and x != x for x in row_list]:
            # isinstance(x, float) and x != x is a typesafe way to check for nan
            err_blank_row = (&#34;One or more rows in the sample input &#34;
                &#34;file have blank sample names. These might be empty rows. &#34;
                &#34;Remove any empty rows and/or give each sample a name. Sample &#34;
                &#34;names go in the first column.&#34;)
            raise Exception(err_blank_row)
            
        # are there duplicate rows?
        dupe_rows = list(set([x for x in row_list if row_list.count(x) &gt; 1]))
        if len(dupe_rows) &gt; 0:
            err_dupe_rows = (&#34;Duplicate sample names are not allowed. &#34;
                &#34;Duplicate sample names were found for:\n&#34;
                &#34;{}&#34;.format(str(dupe_rows)))
            err_list.append(err_dupe_rows)
        
        # are column names valid entries in the database?
        if custom_db:
            data0_path = &#34;data0.&#34; + db
        else:
            data0_path = self.eq36da + &#34;/data0.&#34; + db
        if os.path.exists(data0_path) and os.path.isfile(data0_path):
            with open(data0_path) as data0:
                data0_lines = data0.readlines()
                start_index = [i+1 for i, s in enumerate(data0_lines) if &#39;*  species name&#39; in s]
                end_index = [i-1 for i, s in enumerate(data0_lines) if &#39;elements&#39; in s]
                db_species = [i.split()[0] for i in data0_lines[start_index[0]:end_index[0]]]
                for species in list(set(df_in_headercheck.columns)):
                    if species not in db_species and species != &#39;Temperature&#39;:
                        err_species_not_in_db = (&#34;The species &#39;{}&#39;&#34;.format(species) + &#34; &#34;
                            &#34;was not found in {}&#34;.format(data0_path) + &#34;. &#34;
                            &#34;If the column contains data that should not be &#34;
                            &#34;included in the speciation calculation, add the &#34;
                            &#34;column name to the &#39;exclude&#39; argument. Try &#34;
                            &#34;help(AqEquil.AqEquil.speciate) &#34;
                            &#34;for more information about &#39;exclude&#39;.&#34;)
                        err_list.append(err_species_not_in_db)
        else:
            err_no_data0 = (&#34;Could not locate {}.&#34;.format(data0_path) + &#34; &#34;
                &#34;Unable to determine if column headers included in &#34;
                &#34;{} &#34;.format(input_filename) + &#34;match entries for species &#34;
                &#34;in the requested thermodynamic database &#39;{}&#39;.&#34;.format(db))
            err_list.append(err_no_data0)
        
        
        # are subheader units valid?
        subheaders = df_in_headercheck.iloc[0,]
        valid_subheaders = [&#34;degC&#34;, &#34;ppm&#34;, &#34;ppb&#34;, &#34;Suppressed&#34;, &#34;Molality&#34;,
                            &#34;Molarity&#34;, &#34;mg/L&#34;, &#34;mg/kg.sol&#34;, &#34;Alk., eq/kg.H2O&#34;,
                            &#34;Alk., eq/L&#34;, &#34;Alk., eq/kg.sol&#34;, &#34;Alk., mg/L CaCO3&#34;,
                            &#34;Alk., mg/L HCO3-&#34;, &#34;Log activity&#34;, &#34;Log act combo&#34;,
                            &#34;Log mean act&#34;, &#34;pX&#34;, &#34;pH&#34;, &#34;pHCl&#34;, &#34;pmH&#34;, &#34;pmX&#34;,
                            &#34;Hetero. equil.&#34;, &#34;Homo. equil.&#34;, &#34;Make non-basis&#34;]
        for i, subheader in enumerate(subheaders):
            if subheader not in valid_subheaders:
                err_valid_sub = (&#34;The subheader &#39;{}&#39;&#34;.format(subheader) + &#34; &#34;
                    &#34;for the column &#39;{}&#39;&#34;.format(df_in_headercheck.columns[i]) + &#34; &#34;
                    &#34;is not recognized. Valid subheaders are {}&#34;.format(str(valid_subheaders)) + &#34;. &#34;
                    &#34;If the column {}&#34;.format(df_in_headercheck.columns[i]) + &#34; &#34;
                    &#34;contains data that is not meant for the &#34;
                    &#34;speciation calculation, add the column name &#34;
                    &#34;to the &#39;exclude&#39; argument. Try help(AqEquil.AqEquil.speciate) &#34;
                    &#34;for more information about &#39;exclude&#39;.&#34;)
                err_list.append(err_valid_sub)
            
        # is a &#39;Temperature&#39; column present?
        if &#34;Temperature&#34; not in df_in_headercheck.columns and &#34;Temperature&#34; not in exclude:
            err_temp = (&#34;The column &#39;Temperature&#39; was not found in the input file. &#34;
                &#34;Please include a column with &#39;Temperature&#39; in the first row, &#34;
                &#34;&#39;degC&#39; in the second row, and a temperature value for each &#34;
                &#34;sample in degrees Celsius.&#34;)
            err_list.append(err_temp)
        
        # raise exception that outlines all errors found
        if len(err_list) &gt; 0:
            errs = &#34;\n\n*&#34;.join(err_list)
            errs = (&#34;The input file {}&#34;.format(input_filename)+&#34; encountered&#34;
                &#34; errors:\n\n*&#34; + errs)
            raise Exception(errs)
        
        return
        
        
    def __clear_eqpt_extra_output(self):
        
        &#34;&#34;&#34;
        Deletes all EQPT output except data1.
        &#34;&#34;&#34;
        
        if os.path.exists(&#34;eqpt_log.txt&#34;) and os.path.isfile(&#34;eqpt_log.txt&#34;):
            os.remove(&#34;eqpt_log.txt&#34;)
        if os.path.exists(&#34;data1f.txt&#34;) and os.path.isfile(&#34;data1f.txt&#34;):
            os.remove(&#34;data1f.txt&#34;)
        if os.path.exists(&#34;slist.txt&#34;) and os.path.isfile(&#34;slist.txt&#34;):
            os.remove(&#34;slist.txt&#34;)

    def runeqpt(self, db, extra_eqpt_output=False):
        
        &#34;&#34;&#34;
        Convert a data0 into a data1 file with EQPT.
        
        Parameters
        ----------
        db : str
            Three letter code of database.
        
        extra_eqpt_output : bool, default False
            Keep additional output files from EQPT? These files include
            eqpt_log.txt, data1f.txt, and slist.txt.
        &#34;&#34;&#34;

        if os.path.exists(&#34;data0.&#34;+db) and os.path.isfile(&#34;data0.&#34;+db):
            pass
        else:
            raise Exception(&#34;Error: could not locate custom database&#34;,
                            &#34;data0.{} in {}.&#34;.format(db, os.getcwd()))

        if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
            os.remove(&#34;data1.&#34;+db)

        self.__clear_eqpt_extra_output()

        os.environ[&#39;EQ36DA&#39;] = os.getcwd()

        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeqpt&#39;, db]

        try:
            self.__run_script_and_wait(args) # run EQPT
        except:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da
            raise Exception(
                &#34;Error: EQPT failed to run on {}.&#34;.format(&#34;data0.&#34;+db))

        if os.path.exists(&#34;data1&#34;) and os.path.isfile(&#34;data1&#34;):
            os.rename(&#34;data1&#34;, &#34;data1.&#34;+db)
        if os.path.exists(&#34;output&#34;) and os.path.isfile(&#34;output&#34;):
            os.rename(&#34;output&#34;, &#34;eqpt_log.txt&#34;)
        if os.path.exists(&#34;data1f&#34;) and os.path.isfile(&#34;data1f&#34;):
            os.rename(&#34;data1f&#34;, &#34;data1f.txt&#34;)
        if os.path.exists(&#34;slist&#34;) and os.path.isfile(&#34;slist&#34;):
            os.rename(&#34;slist&#34;, &#34;slist.txt&#34;)

        if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
            if self.messages:
                print(&#34;Successfully created a data1.&#34;+db+&#34; from data0.&#34;+db)
        else:
            msg = (&#34;EQPT could not create data1.&#34;+db+&#34; from &#34;
                   &#34;data0.&#34;+db+&#34;. Check eqpt_log.txt for details.&#34;)
            raise Exception(msg)

        if not extra_eqpt_output:
            self.__clear_eqpt_extra_output()

        os.environ[&#39;EQ36DA&#39;] = self.eq36da  # reset default EQ3 db path

    def runeq3(self, filename_3i, db,
               path_3i=os.getcwd(),
               path_3o=os.getcwd(),
               path_3p=os.getcwd()):
        
        &#34;&#34;&#34;
        Call EQ3 on a .3i input file.
        
        Parameters
        ----------
        filename_3i : str
            Name of 3i input file.
        
        db : str
            Three letter code of database.
        &#34;&#34;&#34;

        # get current working dir
        cwd = os.getcwd()

        print(&#39;Calling EQ3 on &#39; + filename_3i + &#39; using &#39; + db)
        os.chdir(path_3i)  # step into 3i folder
        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq3&#39;, db, filename_3i]

        self.__run_script_and_wait(args) # run EQ3

        # restore working dir
        os.chdir(cwd)

        filename_3o = filename_3i[:-1] + &#39;o&#39;
        filename_3p = filename_3i[:-1] + &#39;p&#39;

        try:
            # rename output
            os.rename(path_3i + &#39;/output&#39;, path_3i + &#34;/&#34; + filename_3o)
        except:
            print(&#39;Error: EQ3 failed to produce output for &#39; + filename_3i)

        try:
            # move output
            shutil.move(path_3i + &#34;/&#34; + filename_3o,
                        path_3o + &#34;/&#34; + filename_3o)
        except:
            print(&#39;Error: Could not move&#39;, filename_3o, &#34;to&#34;, path_3o)

        try:
            # rename pickup
            os.rename(path_3i + &#39;/pickup&#39;, path_3i + &#34;/&#34; + filename_3p)
        except:
            print(&#39;Error: EQ3 failed to produce a pickup file for &#39; + filename_3i)

        try:
            # move pickup
            shutil.move(path_3i + &#34;/&#34; + filename_3p,
                        path_3p + &#34;/&#34; + filename_3p)
        except:
            print(&#39;Error: Could not move&#39;, filename_3p, &#34;to&#34;, path_3p)

    def __mk_check_del_directory(self, path):
        
        &#34;&#34;&#34;
        Checks for the dir being created. If it is already present, delete it
        before recreating it.
        &#34;&#34;&#34;
        
        if not os.path.exists(path):
            os.makedirs(path)
        else:
            shutil.rmtree(path)
            os.makedirs(path)

    def __read_inputs(self, file_type, location):
        
        &#34;&#34;&#34;
        Finds all files of a filetype in all downstream folders.
        &#34;&#34;&#34;
        
        file_name = []  # file names
        file_list = []  # file names with paths
        for root, dirs, files in os.walk(location):
            for file in files:
                if file.endswith(file_type):
                    if &#34;-checkpoint&#34; not in file:
                        file_name.append(file)
                        file_list.append(os.path.join(root, file))
        return file_name, file_list

    def __run_script_and_wait(self, args):
        
        &#34;&#34;&#34;
        Runs shell commands.
        &#34;&#34;&#34;
        
        with open(os.devnull, &#39;w&#39;) as fp:  # devnull supresses written output
            Popen(args, stdout=fp).wait()

    def _delete_rxn_folders(self):
        
        &#34;&#34;&#34;
        Deletes folders storing raw EQ3 input and output.
        &#34;&#34;&#34;
        
        if os.path.exists(&#39;rxn_3i&#39;) and os.path.isdir(&#39;rxn_3i&#39;):
            shutil.rmtree(&#39;rxn_3i&#39;)
        if os.path.exists(&#39;rxn_3o&#39;) and os.path.isdir(&#39;rxn_3o&#39;):
            shutil.rmtree(&#39;rxn_3o&#39;)
        if os.path.exists(&#39;rxn_3p&#39;) and os.path.isdir(&#39;rxn_3p&#39;):
            shutil.rmtree(&#39;rxn_3p&#39;)

    def speciate(self,
                 input_filename,
                 db=&#34;jus&#34;,
                 redox_flag=0,
                 redox_aux=&#34;Fe+3&#34;,
                 default_logfO2=-6,
                 exclude=[],
                 suppress=[],
                 charge_balance_on=&#34;none&#34;,
                 suppress_missing=True,
                 verbose=1,
                 report_filename=None,
                 get_aq_dist=True,
                 aq_dist_type=&#34;log_activity&#34;,
                 get_mass_contribution=True,
                 mass_contribution_other=True,
                 get_mineral_sat=True,
                 mineral_sat_type=&#34;affinity&#34;,
                 get_redox=True,
                 redox_type=&#34;Eh&#34;,
                 get_affinity_energy=False,
                 rxn_filename=None,
                 not_limiting=[&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;],
                 get_charge_balance=True,
                 custom_db=False,
                 extra_eqpt_output=False,
                 batch_3o_filename=None,
                 delete_generated_folders=False):
        
        &#34;&#34;&#34;
        Calculate the equilibrium distribution of chemical species in solution.
        Additionally, calculate chemical affinities and energy supplies for
        user-specified reactions.
        
        Parameters
        ----------
        input_filename : str
            User-supplied utf8-encoded comma separated value (csv) file
            containing sample data intended for speciation. The file must
            follow this format:
            
            - the first row is a header row that must contain the names of the
              species to be included in the speciation calculation. There
              cannot be duplicate headers.
            - the second row must contain subheaders for each species in the
              header row. These subheaders must be taken from the following:
              
                    degC
                    ppm
                    ppb
                    Suppressed
                    Molality
                    Molarity
                    mg/L
                    mg/kg.sol
                    Alk., eq/kg.H2O
                    Alk., eq/L
                    Alk., eq/kg.sol
                    Alk., mg/L CaCO3
                    Alk., mg/L HCO3-
                    Log activity
                    Log act combo
                    Log mean act
                    pX
                    pH
                    pHCl
                    pmH
                    pmX
                    Hetero. equil.
                    Homo. equil.
                    Make non-basis
                    
            - &#39;Temperature&#39; must be included as a header, with &#39;degC&#39; as its
              subheader.
            - The first column must contain sample names. There cannot be
              duplicate sample names.
        
        db : three letter str, default &#34;jus&#34;
            Three letter file extension for the desired thermodynamic database.
            If `custom_db` is False, this database must be named data1.xyz
            (where xyz is your desired three letter extension) and located
            in the EQ3/6 &#39;EQ36DA&#39; path. Otherwise, the database must be named
            data0.xyz and located in your current working directory. Note that
            data1 files are already compiled by EQPT, while data0 files will be
            automatically compiled for you if `custom_db` is True.
        
        redox_flag : int, default 0
            Values corresponding to redox options in the EQ3/6 v8.0 software.
            For more information see the &#39;Redox Option&#39; section of the EQ3/6
            version 8.0 software user&#39;s manual. Set sample redox state with the
            following options:
            
            * -3 for O2(g)
            * -2 for pe (in pe units)
            * -1 for Eh (volts)
            *  0 for logfO2 (log bars), or dissolved O2 (see below)
            *  1 for defining a redox couple (see `redox_aux`)
             
            Note that if you are importing water chemistry data from a
            spreadsheet, a column must be supplied with data that corresponds to
            the redox option you chose. The column name is important:
            
            * -3 must have a column named: O2(g)
            * -2 must have a column named: pe
            * -1 must have a column named: Eh
            *  0 must have a column named: logfO2
            *  1 must have a column corresponding to the auxilliary basis species
              selected to form a redox couple with its linked species (see
              `redox_aux`). For example, the redox couple Fe+2/Fe+3 would need
              a column named: Fe+3
            
            If an appropriate header or redox data cannot be found to define
            redox state, `default_logfO2` is used to set sample logfO2.
            
            There is a special case where dissolved oxygen can be used to impose
            sample redox state if `redox_flag` is set to 0 and a column named
            logfO2 does not appear in the sample data sheet. If there is a
            column corresponding to dissolved oxygen measurements, logfO2 is
            calculated from the equilibrium reaction O2(aq) = O2(g) at the
            temperature and pressure of the sample using the revised Helgeson-
            Kirkham-Flowers (HKF) equation of state (JC Tanger IV and HC
            Helgeson, Am. J. Sci., 1988, 288, 19).
        
        redox_aux : default &#34;Fe+3&#34;, optional
            Ignored unless `redox_flag` equals 1. Name of the auxilliary species
            whose reaction links it to a basis species (or another auxilliary
            species) such that they form a redox couple that controls sample
            fO2. For instance, Fe+3 is linked to Fe+2 in many supporting data
            files, so selecting `redox_flag` = 1 and `redox_aux` = &#34;Fe+3&#34; will
            set sample fO2 based on the Fe+2/Fe+3 redox couple.
        
        default_logfO2 : float, default -6
            Default value for sample logfO2 in case redox data cannot be found
            in the user-supplied sample spreadsheet.
        
        exclude : list of str, default []
            Names of columns in the user-supplied sample spreadsheet that should
            not be considered aqueous species. Useful for excluding columns
            containing sample metatadata, such as &#34;Year&#34; and &#34;Location&#34;.
            
        suppress : list of str, default []
            Names of chemical species that will be prevented from forming in the
            speciation calculation.
            
        charge_balance_on : str, default &#34;none&#34;
            If &#34;none&#34;, will not balance electrical charge between cations and
            anions in the speciation calculation. If a name of a species is
            supplied instead, the activity of that species will be allowed to
            change until charge balance is obtained. For example,
            charge_balance_on = &#34;H+&#34; will calculate what pH a sample must have
            to have zero net charge.
        
        suppress_missing : bool, default True
            Suppress the formation of an aqueous species if it is missing a
            value in the user-supplied sample spreadsheet?
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
            
        report_filename : str, optional
            Name of the comma separated values (csv) report file generated when
            the calculation is complete. If this argument is not defined, a
            report file is not generated.
            
        get_aq_dist : bool, default True
            Calculate distributions of aqueous species?
        
        aq_dist_type : str, default &#34;log_activity&#34;
            Desired units of measurement for reported distributions of aqueous
            species. Can be &#34;molality&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, or
            &#34;log_activity&#34;. Ignored if `get_aq_dist` is False.
        
        get_mass_contribution : bool, default True
            Calculate basis species contributions to mass balance of aqueous
            species?
        
        mass_contribution_other : bool, default True
            Include an &#34;other&#34; species for the sake of summing percents of basis
            species contributions to 100%? Ignored if `get_mass_contribution` is
            False.
        
        get_mineral_sat : bool, default True
            Calculate saturation states of pure solids?
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Desired units of measurement for reported saturation states of pure
            solids. Can be &#34;logQoverK&#34; or &#34;affinity&#34;. Ignored if
            `get_mineral_sat` is False.
        
        get_redox : bool, default True
            Calculate potentials of redox couples?
            
        redox_type : str, default &#34;Eh&#34;
            Desired units of measurement for reported redox potentials. Can be
            &#34;Eh&#34;, &#34;pe&#34;, &#34;logfO2&#34;, or &#34;Ah&#34;. Ignored if `get_redox` is False.
            
        get_affinity_energy : bool, default False
            Calculate affinities and energy supplies of reactions listed in a
            separate user-supplied file?
        
        rxn_filename : str, optional
            Name of file containing reactions used to calculate affinities and
            energy supplies. Ignored if `get_affinity_energy` is False.
        
        not_limiting : list, default [&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;]
            List containing names of species that are not considered limiting
            when calculating energy supplies. Ignored if `get_affinity_energy`
            is False.
        
        get_charge_balance : bool, default True
            Calculate charge balance and ionic strength?
            
        custom_db : bool, default False
            Is the database defined by `db` a custom user-supplied database? If
            this is set to True, searches for a data0.xyz file in the current
            working directory, where &#39;xyz&#39; corresponds to the three letter code
            assigned to `db`. This data0 file is automatically converted into a
            machine-readable file called data1 by software called EQPT. This
            data1 file is then used in speciation calculations.
        
        extra_eqpt_output : bool, default False
            Keep additional output files created by EQPT (see `custom_db`)?
            Ignored if `custom_db` is False.
        
        batch_3o_filename : str, optional
            Name of rds (R object) file exported after the speciation
            calculation? No file will be generated if this argument is not
            defined.
            
        delete_generated_folders : bool, default False
            Delete the &#39;rxn_3i&#39;, &#39;rxn_3o&#39;, and &#39;rxn_3p&#39; folders containing raw
            EQ3NR input, output, and pickup files once the speciation
            calculation is complete?
        
        Returns
        -------
        speciation : object of class Speciation
            Contains the results of the speciation calculation.
        
        &#34;&#34;&#34;
        
        # check input sample file for errors
        self._check_sample_input_file(input_filename, exclude, db, custom_db)
        
        # handle batch_3o naming
        if batch_3o_filename != None:
            if &#34;.rds&#34; in batch_3o_filename[-4:]:
                batch_3o_filename = batch_3o_filename
            else:
                batch_3o_filename = &#34;batch_3o_{}.rds&#34;.format(db)
        else:
            batch_3o_filename = ro.r(&#34;NULL&#34;)

        if custom_db:
            # EQ3/6 cannot handle spaces in the &#39;EQ36DA&#39; path name.
            if &#34; &#34; in os.getcwd():
                msg = (&#34;Error: the path to the custom database &#34;
                    &#34;cannot contain spaces. The current path &#34;
                    &#34;is: [ &#34; + os.getcwd() + &#34; ]. Remove or &#34;
                    &#34;replace spaces in folder names for this &#34;
                    &#34;feature. Example: [ &#34; + os.getcwd().replace(&#34; &#34;, &#34;-&#34;) + &#34; ].&#34;)
                raise Exception(msg)

            self.runeqpt(db, extra_eqpt_output)
            os.environ[&#39;EQ36DA&#39;] = os.getcwd()

        if get_affinity_energy:
            if rxn_filename == None:
                wrn = (&#34;A reaction file was not specified. Affinities and &#34;
                    &#34;energy supplies will not be calculated.&#34;)
                warnings.warn(wrn)
                get_affinity_energy = False
                rxn_filename = &#34;&#34;
            elif os.path.exists(rxn_filename) and os.path.isfile(rxn_filename):
                pass
            else:
                wrn = (&#34;Reaction file {} was not found. Affinities and &#34;
                    &#34;energy supplies will not be &#34;
                    &#34;calculated.&#34;.format(rxn_filename))
                warnings.warn(wrn)
                get_affinity_energy = False
                rxn_filename = &#34;&#34;
        else:
            rxn_filename = &#34;&#34;

        # preprocess for eq3 using R scripts
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_prescript = pkg_resources.resource_string(
                __name__, &#39;preprocess_for_EQ3.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_prescript)
            df_input_processed = ro.r.preprocess(input_filename=input_filename,
                                                 exclude=convert_to_RVector(
                                                     exclude),
                                                 redox_flag=redox_flag,
                                                 default_logfO2=default_logfO2,
                                                 charge_balance_on=charge_balance_on,
                                                 suppress_missing=suppress_missing,
                                                 suppress=convert_to_RVector(
                                                     suppress),
                                                 verbose=verbose)

        for warning in w:
            print(warning.message)

        self.df_input_processed = pandas2ri.ri2py_dataframe(df_input_processed)

        # run EQ3 on each input file
        cwd = os.getcwd()

        self.__mk_check_del_directory(&#39;rxn_3o&#39;)
        self.__mk_check_del_directory(&#39;rxn_3p&#39;)
        files_3i, files_3i_paths = self.__read_inputs(&#39;3i&#39;, &#39;rxn_3i&#39;)

        input_dir = cwd + &#34;/rxn_3i/&#34;
        output_dir = cwd + &#34;/rxn_3o/&#34;
        pickup_dir = cwd + &#34;/rxn_3p/&#34;
        
        for file in files_3i:
            self.runeq3(filename_3i=file, db=db, path_3i=input_dir,
                        path_3o=output_dir, path_3p=pickup_dir)

        if custom_db:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da

        files_3o = [file+&#34;.3o&#34; for file in self.df_input_processed.index]
        
        df_input_processed_names = convert_to_RVector(list(self.df_input_processed.columns))
        
        # mine output
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_3o_mine = pkg_resources.resource_string(
                __name__, &#39;3o_mine.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_3o_mine)
            batch_3o = ro.r.main_3o_mine(
                files_3o=convert_to_RVector(files_3o),
                input_filename=input_filename,
                rxn_filename=rxn_filename,
                get_aq_dist=get_aq_dist,
                aq_dist_type=aq_dist_type,
                get_mass_contribution=get_mass_contribution,
                mass_contribution_other=mass_contribution_other,
                get_mineral_sat=get_mineral_sat,
                mineral_sat_type=mineral_sat_type,
                get_redox=get_redox,
                redox_type=redox_type,
                get_charge_balance=get_charge_balance,
                get_affinity_energy=get_affinity_energy,
                not_limiting=convert_to_RVector(not_limiting),
                batch_3o_filename=batch_3o_filename,
                df_input_processed=pandas2ri.py2ri(self.df_input_processed),
                # Needed for keeping symbols in column names after porting
                #   df_input_processed in the line above. Some kind of check.names
                #   option for pandas2ri.py2ri would be nice. Workaround:
                df_input_processed_names=df_input_processed_names,
            )
        for warning in w:
            print(warning.message)
        
        if get_mass_contribution:
            mass_contribution = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;mass_contribution&#39;))
        df_report = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;report&#39;))
        df_input = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;input&#39;))
        report_divs = batch_3o.rx2(&#39;report_divs&#39;)

        input_cols = list(report_divs.rx2(&#39;input&#39;))
        df_input = df_report.loc[:, input_cols]

        # handle headers and subheaders of input section
        headers = [col.split(&#34;_&#34;)[0] for col in list(df_input.columns)]
        headers = [&#34;pH&#34; if header == &#34;H+&#34; else header for header in headers]
        headers = [header+&#34;_(input)&#34; if header not in [&#34;Temperature&#34;, &#34;pH&#34;]+exclude else header for header in headers]
        subheaders = [subheader[1] if len(subheader) &gt; 1 else &#34;&#34; for subheader in [
            col.split(&#34;_&#34;) for col in list(df_input.columns)]]
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_input.columns = multicolumns

        df_join = df_input

        if get_aq_dist:
            aq_distribution_cols = list(report_divs.rx2(&#39;aq_distribution&#39;))
            df_aq_distribution = df_report.loc[:, aq_distribution_cols]
            df_aq_distribution = df_aq_distribution.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of aq_distribution section
            headers = df_aq_distribution.columns
            subheaders = [aq_dist_type]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_aq_distribution.columns = multicolumns
            df_join = df_join.join(df_aq_distribution)

        if get_mineral_sat:
            mineral_sat_cols = list(report_divs.rx2(&#39;mineral_sat&#39;))
            df_mineral_sat = df_report.loc[:, mineral_sat_cols]
            df_mineral_sat = df_mineral_sat.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_mineral_sat section
            if mineral_sat_type == &#34;affinity&#34;:
                mineral_sat_unit = &#34;affinity_kcal&#34;
            elif mineral_sat_type == &#34;logQoverK&#34;:
                mineral_sat_unit = &#34;logQ/K&#34;
            else:
                raise Exception(
                    &#34;mineral_sat_type must be either &#39;affinity&#39; or &#39;logQoverK&#39;&#34;)

            headers = df_mineral_sat.columns
            subheaders = [mineral_sat_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_mineral_sat.columns = multicolumns
            df_join = df_join.join(df_mineral_sat)

        if get_redox:
            redox_cols = list(report_divs.rx2(&#39;redox&#39;))
            df_redox = df_report.loc[:, redox_cols]
            df_redox = df_redox.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_redox section
            if redox_type == &#34;Eh&#34;:
                redox_unit = &#34;Eh_volts&#34;
            elif redox_type == &#34;pe&#34;:
                redox_unit = &#34;pe&#34;
            elif redox_type == &#34;logfO2&#34;:
                redox_unit = &#34;logfO2&#34;
            elif redox_type == &#34;Ah&#34;:
                redox_unit = &#34;Ah_kcal&#34;
            else:
                raise Exception(
                    &#34;redox_type must be either &#39;Eh&#39;, &#39;pe&#39;, &#39;logfO2&#39;, or &#39;Ah&#39;&#34;)

            headers = df_redox.columns
            subheaders = [redox_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_redox.columns = multicolumns
            df_join = df_join.join(df_redox)

        if get_charge_balance:
            charge_balance_cols = list(report_divs.rx2(&#39;charge_balance&#39;))
            df_charge_balance = df_report.loc[:, charge_balance_cols]
            df_charge_balance = df_charge_balance.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_charge_balance section
            headers = df_charge_balance.columns
            subheaders = [&#34;%&#34;]*2 + [&#39;eq/kg.H2O&#39;, &#39;molality&#39;] + \
                [&#39;eq/kg.H2O&#39;]*4 + [&#39;molality&#39;]
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_charge_balance.columns = multicolumns
            df_join = df_join.join(df_charge_balance)

        if get_affinity_energy:
            affinity_cols = list(report_divs.rx2(&#39;affinity&#39;))
            energy_cols = list(report_divs.rx2(&#39;energy&#39;))
            df_affinity = df_report.loc[:, affinity_cols]
            df_energy = df_report.loc[:, energy_cols]
            df_affinity = df_affinity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            df_energy = df_energy.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_affinity section
            headers = df_affinity.columns
            subheaders = [&#39;cal/mol e-&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_affinity.columns = multicolumns

            # handle headers of df_energy section
            headers = df_energy.columns
            subheaders = [&#39;cal/kg.H2O&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_energy.columns = multicolumns
            df_join = df_join.join(df_affinity)
            df_join = df_join.join(df_energy)

        out_dict = {&#39;sample_data&#39;: {},
                    &#39;report&#39;: df_join,
                    &#39;input&#39;: df_input, &#39;report_divs&#39;: report_divs}
        
        if get_mass_contribution:
            out_dict[&#39;mass_contribution&#39;] = mass_contribution

        sample_data = batch_3o.rx2(&#39;sample_data&#39;)

        # assemble sample data
        for i, sample in enumerate(sample_data):
            dict_sample_data = {
                &#34;filename&#34;: str(sample.rx2(&#39;filename&#39;)[0]),
                &#34;name&#34;: str(sample.rx2(&#39;name&#39;)[0]),
                &#34;temperature&#34;: float(sample.rx2(&#39;temperature&#39;)[0]),
                &#34;pressure&#34;: float(sample.rx2(&#39;pressure&#39;)[0]),
                &#34;logact_H2O&#34;: float(sample.rx2(&#39;logact_H2O&#39;)[0]),
                &#34;H2O_density&#34;: float(sample.rx2(&#39;H2O_density&#39;)[0]),
                &#34;H2O_molality&#34;: float(sample.rx2(&#39;H2O_molality&#39;)[0]),
                &#34;H2O_log_molality&#34;: float(sample.rx2(&#39;H2O_log_molality&#39;)[0]),
                }

            if get_aq_dist:
                sample_aq_dist = pandas2ri.ri2py_dataframe(sample.rx2(&#39;aq_distribution&#39;))
                sample_aq_dist = sample_aq_dist.apply(pd.to_numeric, errors=&#39;coerce&#39;)
                dict_sample_data.update({&#34;aq_distribution&#34;: sample_aq_dist})

            if get_mass_contribution:
                sample_mass_contribution = mass_contribution[mass_contribution[&#34;sample&#34;] == sample.rx2(&#39;name&#39;)[0]]
                dict_sample_data.update(
                    {&#34;mass_contribution&#34;: sample_mass_contribution})

            if get_mineral_sat:
                dict_sample_data.update(
                    {&#34;mineral_sat&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;mineral_sat&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            if get_redox:
                dict_sample_data.update(
                    {&#34;redox&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;redox&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            if get_charge_balance:
                dict_sample_data.update({&#34;charge_balance&#34;: df_charge_balance.loc[sample.rx2(&#39;name&#39;)[0], :]})

            if get_affinity_energy:
                dict_sample_data.update({&#34;affinity_energy_raw&#34;: pandas2ri.ri2py_dataframe(
                    sample.rx2(&#39;affinity_energy_raw&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                dict_sample_data.update(
                    {&#34;affinity_energy&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;affinity_energy&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            out_dict[&#34;sample_data&#34;].update(
                {sample_data.names[i]: dict_sample_data})

        out_dict.update({&#34;batch_3o&#34;: batch_3o})
        speciation = Speciation(out_dict)

        if report_filename != None:
            if &#34;.csv&#34; in report_filename[-4:]:
                out_dict[&#34;report&#34;].to_csv(report_filename)
            else:
                out_dict[&#34;report&#34;].to_csv(report_filename+&#34;.csv&#34;)

        if delete_generated_folders:
            self._delete_rxn_folders()

        return speciation

    def create_data0(self,
                     filename,
                     supp_file,
                     supp_file_ss=None,
                     data0_formula_ox_name=None,
                     suppress_redox=[],
                     db=&#34;wrm&#34;,
                     exceed_Ttr=True,
                     grid_temps=[0.0100, 50.0000, 100.0000, 150.0000,
                                 200.0000, 250.0000, 300.0000, 350.0000],
                     grid_press=&#34;Psat&#34;,
                     infer_formula_ox=False,
                     basis_prefs={},
                     generate_template=True,
                     template_name=None,
                     verbose=1):
        &#34;&#34;&#34;
        Create a data0 file from a custom thermodynamic dataset.
        
        Parameters
        ----------
        filename : str
            Name of csv file containing thermodynamic data in the OBIGT format.
            
        supp_file : str
            Path of file containing data0-specific parameters.
            
        supp_file_ss : str, optional
            Name of file containing solid solution parameters.
        
        data0_formula_ox_name : str, optional
            Name of supplementary file containing data0 parameters and inferred
            formula oxidation states. Ignored if `infer_formula_ox` is False.
            See `infer_formula_ox` for more detail.
        
        suppress_redox : list of str, default []
            Suppress equilibrium between oxidation states of listed elements
            (Cl, H, and O cannot be included).
        
        db : str, default &#34;wrm&#34;
            Desired three letter code of data0 output.

        exceed_Ttr : bool, default True
            Calculate Gibbs energies of mineral phases and other species
            beyond their transition temperatures?

        grid_temps : list of eight float, default [0.0100, 50.0000, 100.0000, 150.0000, 200.0000, 250.0000, 300.0000, 350.0000]
            Eight temperature values that make up the T-P grid.
        
        grid_press : list of float, default &#34;Psat&#34;
            Eight pressure values that make up the T-P grid. &#34;Psat&#34; for
            calculations along the liquid-vapor saturation curve.

        infer_formula_ox : bool, default False
            Create a supplementary file containing data0 parameters and
            inferred formula oxidation states? This option is useful for
            creating as many entries in the formula_ox column when creating a
            new supplementary file. Note that compounds like DySO4+ result in
            blank entries in formula_ox because the redox states of two
            elements, Dy and S, would have to be estimated together; S has many
            oxidation states and Dy&#39;s oxidation states are not hard-coded.
        
        generate_template : bool, default True
            Generate a CSV sample input template customized to this data0?
        
        template_name : str, optional
            Name of the sample input template file generated. If no name is
            supplied, defaults to &#39;sample_template_xyz.csv&#39;, where &#39;xyz&#39; is
            the three letter code given to `db`. Ignored if `generate_template`
            is False.
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
        &#34;&#34;&#34;

        if verbose &gt;= 1:
            print(&#34;Creating data0.{}...&#34;.format(db))
        
        if sum([T &gt;= 10000 for T in grid_temps]):
            raise Exception(&#34;Grid temperatures must be below 10000 °C.&#34;)
        
        if isinstance(grid_press, list):
            if sum([T &gt;= 10000 for T in grid_temps]):
                raise Exception(&#34;Grid pressures must be below 10000 bars.&#34;)
        
        template = pkg_resources.resource_string(
            __name__, &#39;data0.min&#39;).decode(&#34;utf-8&#34;)
        grid_temps = convert_to_RVector(grid_temps)
        grid_press = convert_to_RVector(grid_press)
        suppress_redox = convert_to_RVector(suppress_redox)
        bp_values = list(basis_prefs.values())
        bp_keys = list(basis_prefs.keys())
        basis_prefs = convert_to_RVector(bp_values)
        basis_pref_names = convert_to_RVector(bp_keys)
        
        if supp_file_ss == None:
            supp_file_ss = ro.r(&#34;NULL&#34;)
        if data0_formula_ox_name == None:
            data0_formula_ox_name = ro.r(&#34;NULL&#34;)
        if template_name == None:
            template_name = &#34;sample_template_{}.csv&#34;.format(db)

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_create_data0 = pkg_resources.resource_string(
                __name__, &#39;create_data0.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_create_data0)
            ro.r.main_create_data0(filename=filename,
                                   supp_file=supp_file,
                                   supp_file_ss=supp_file_ss,
                                   grid_temps=grid_temps,
                                   grid_press=grid_press,
                                   db=db,
                                   template=template,
                                   exceed_Ttr=exceed_Ttr,
                                   data0_formula_ox_name=data0_formula_ox_name,
                                   suppress_redox=suppress_redox,
                                   infer_formula_ox=infer_formula_ox,
                                   generate_template=generate_template,
                                   template_name=template_name,
                                   verbose=verbose,
                                   basis_prefs=basis_prefs,
                                   basis_pref_names=basis_pref_names)
    
        for warning in w:
            print(warning.message)
        
        if verbose &gt;= 1:
            print(&#34;Finished creating data0.{}.&#34;.format(db))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AqEquil.AqSpeciation.AqEquil.create_data0"><code class="name flex">
<span>def <span class="ident">create_data0</span></span>(<span>self, filename, supp_file, supp_file_ss=None, data0_formula_ox_name=None, suppress_redox=[], db='wrm', exceed_Ttr=True, grid_temps=[0.01, 50.0, 100.0, 150.0, 200.0, 250.0, 300.0, 350.0], grid_press='Psat', infer_formula_ox=False, basis_prefs={}, generate_template=True, template_name=None, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a data0 file from a custom thermodynamic dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of csv file containing thermodynamic data in the OBIGT format.</dd>
<dt><strong><code>supp_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path of file containing data0-specific parameters.</dd>
<dt><strong><code>supp_file_ss</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of file containing solid solution parameters.</dd>
<dt><strong><code>data0_formula_ox_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of supplementary file containing data0 parameters and inferred
formula oxidation states. Ignored if <code>infer_formula_ox</code> is False.
See <code>infer_formula_ox</code> for more detail.</dd>
<dt><strong><code>suppress_redox</code></strong> :&ensp;<code>list</code> of <code>str</code>, default <code>[]</code></dt>
<dd>Suppress equilibrium between oxidation states of listed elements
(Cl, H, and O cannot be included).</dd>
<dt><strong><code>db</code></strong> :&ensp;<code>str</code>, default <code>"wrm"</code></dt>
<dd>Desired three letter code of data0 output.</dd>
<dt><strong><code>exceed_Ttr</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate Gibbs energies of mineral phases and other species
beyond their transition temperatures?</dd>
<dt><strong><code>grid_temps</code></strong> :&ensp;<code>list</code> of <code>eight float</code>, default <code>[0.0100, 50.0000, 100.0000, 150.0000, 200.0000, 250.0000, 300.0000, 350.0000]</code></dt>
<dd>Eight temperature values that make up the T-P grid.</dd>
<dt><strong><code>grid_press</code></strong> :&ensp;<code>list</code> of <code>float</code>, default <code>"Psat"</code></dt>
<dd>Eight pressure values that make up the T-P grid. "Psat" for
calculations along the liquid-vapor saturation curve.</dd>
<dt><strong><code>infer_formula_ox</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Create a supplementary file containing data0 parameters and
inferred formula oxidation states? This option is useful for
creating as many entries in the formula_ox column when creating a
new supplementary file. Note that compounds like DySO4+ result in
blank entries in formula_ox because the redox states of two
elements, Dy and S, would have to be estimated together; S has many
oxidation states and Dy's oxidation states are not hard-coded.</dd>
<dt><strong><code>generate_template</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Generate a CSV sample input template customized to this data0?</dd>
<dt><strong><code>template_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the sample input template file generated. If no name is
supplied, defaults to 'sample_template_xyz.csv', where 'xyz' is
the three letter code given to <code>db</code>. Ignored if <code>generate_template</code>
is False.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int, 0, 1,</code> or <code>2</code>, default <code>1</code></dt>
<dd>Level determining how many messages are returned during a
calculation. 2 for all messages, 1 for errors or warnings only,
0 for silent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_data0(self,
                 filename,
                 supp_file,
                 supp_file_ss=None,
                 data0_formula_ox_name=None,
                 suppress_redox=[],
                 db=&#34;wrm&#34;,
                 exceed_Ttr=True,
                 grid_temps=[0.0100, 50.0000, 100.0000, 150.0000,
                             200.0000, 250.0000, 300.0000, 350.0000],
                 grid_press=&#34;Psat&#34;,
                 infer_formula_ox=False,
                 basis_prefs={},
                 generate_template=True,
                 template_name=None,
                 verbose=1):
    &#34;&#34;&#34;
    Create a data0 file from a custom thermodynamic dataset.
    
    Parameters
    ----------
    filename : str
        Name of csv file containing thermodynamic data in the OBIGT format.
        
    supp_file : str
        Path of file containing data0-specific parameters.
        
    supp_file_ss : str, optional
        Name of file containing solid solution parameters.
    
    data0_formula_ox_name : str, optional
        Name of supplementary file containing data0 parameters and inferred
        formula oxidation states. Ignored if `infer_formula_ox` is False.
        See `infer_formula_ox` for more detail.
    
    suppress_redox : list of str, default []
        Suppress equilibrium between oxidation states of listed elements
        (Cl, H, and O cannot be included).
    
    db : str, default &#34;wrm&#34;
        Desired three letter code of data0 output.

    exceed_Ttr : bool, default True
        Calculate Gibbs energies of mineral phases and other species
        beyond their transition temperatures?

    grid_temps : list of eight float, default [0.0100, 50.0000, 100.0000, 150.0000, 200.0000, 250.0000, 300.0000, 350.0000]
        Eight temperature values that make up the T-P grid.
    
    grid_press : list of float, default &#34;Psat&#34;
        Eight pressure values that make up the T-P grid. &#34;Psat&#34; for
        calculations along the liquid-vapor saturation curve.

    infer_formula_ox : bool, default False
        Create a supplementary file containing data0 parameters and
        inferred formula oxidation states? This option is useful for
        creating as many entries in the formula_ox column when creating a
        new supplementary file. Note that compounds like DySO4+ result in
        blank entries in formula_ox because the redox states of two
        elements, Dy and S, would have to be estimated together; S has many
        oxidation states and Dy&#39;s oxidation states are not hard-coded.
    
    generate_template : bool, default True
        Generate a CSV sample input template customized to this data0?
    
    template_name : str, optional
        Name of the sample input template file generated. If no name is
        supplied, defaults to &#39;sample_template_xyz.csv&#39;, where &#39;xyz&#39; is
        the three letter code given to `db`. Ignored if `generate_template`
        is False.
    
    verbose : int, 0, 1, or 2, default 1
        Level determining how many messages are returned during a
        calculation. 2 for all messages, 1 for errors or warnings only,
        0 for silent.
    &#34;&#34;&#34;

    if verbose &gt;= 1:
        print(&#34;Creating data0.{}...&#34;.format(db))
    
    if sum([T &gt;= 10000 for T in grid_temps]):
        raise Exception(&#34;Grid temperatures must be below 10000 °C.&#34;)
    
    if isinstance(grid_press, list):
        if sum([T &gt;= 10000 for T in grid_temps]):
            raise Exception(&#34;Grid pressures must be below 10000 bars.&#34;)
    
    template = pkg_resources.resource_string(
        __name__, &#39;data0.min&#39;).decode(&#34;utf-8&#34;)
    grid_temps = convert_to_RVector(grid_temps)
    grid_press = convert_to_RVector(grid_press)
    suppress_redox = convert_to_RVector(suppress_redox)
    bp_values = list(basis_prefs.values())
    bp_keys = list(basis_prefs.keys())
    basis_prefs = convert_to_RVector(bp_values)
    basis_pref_names = convert_to_RVector(bp_keys)
    
    if supp_file_ss == None:
        supp_file_ss = ro.r(&#34;NULL&#34;)
    if data0_formula_ox_name == None:
        data0_formula_ox_name = ro.r(&#34;NULL&#34;)
    if template_name == None:
        template_name = &#34;sample_template_{}.csv&#34;.format(db)

    with warnings.catch_warnings(record=True) as w:
        warnings.simplefilter(&#34;always&#34;)
        r_create_data0 = pkg_resources.resource_string(
            __name__, &#39;create_data0.r&#39;).decode(&#34;utf-8&#34;)
        ro.r(r_create_data0)
        ro.r.main_create_data0(filename=filename,
                               supp_file=supp_file,
                               supp_file_ss=supp_file_ss,
                               grid_temps=grid_temps,
                               grid_press=grid_press,
                               db=db,
                               template=template,
                               exceed_Ttr=exceed_Ttr,
                               data0_formula_ox_name=data0_formula_ox_name,
                               suppress_redox=suppress_redox,
                               infer_formula_ox=infer_formula_ox,
                               generate_template=generate_template,
                               template_name=template_name,
                               verbose=verbose,
                               basis_prefs=basis_prefs,
                               basis_pref_names=basis_pref_names)

    for warning in w:
        print(warning.message)
    
    if verbose &gt;= 1:
        print(&#34;Finished creating data0.{}.&#34;.format(db))</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.AqEquil.runeq3"><code class="name flex">
<span>def <span class="ident">runeq3</span></span>(<span>self, filename_3i, db, path_3i='C:\\Users\\gmboy\\Desktop\\aqequil', path_3o='C:\\Users\\gmboy\\Desktop\\aqequil', path_3p='C:\\Users\\gmboy\\Desktop\\aqequil')</span>
</code></dt>
<dd>
<div class="desc"><p>Call EQ3 on a .3i input file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename_3i</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of 3i input file.</dd>
<dt><strong><code>db</code></strong> :&ensp;<code>str</code></dt>
<dd>Three letter code of database.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runeq3(self, filename_3i, db,
           path_3i=os.getcwd(),
           path_3o=os.getcwd(),
           path_3p=os.getcwd()):
    
    &#34;&#34;&#34;
    Call EQ3 on a .3i input file.
    
    Parameters
    ----------
    filename_3i : str
        Name of 3i input file.
    
    db : str
        Three letter code of database.
    &#34;&#34;&#34;

    # get current working dir
    cwd = os.getcwd()

    print(&#39;Calling EQ3 on &#39; + filename_3i + &#39; using &#39; + db)
    os.chdir(path_3i)  # step into 3i folder
    args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq3&#39;, db, filename_3i]

    self.__run_script_and_wait(args) # run EQ3

    # restore working dir
    os.chdir(cwd)

    filename_3o = filename_3i[:-1] + &#39;o&#39;
    filename_3p = filename_3i[:-1] + &#39;p&#39;

    try:
        # rename output
        os.rename(path_3i + &#39;/output&#39;, path_3i + &#34;/&#34; + filename_3o)
    except:
        print(&#39;Error: EQ3 failed to produce output for &#39; + filename_3i)

    try:
        # move output
        shutil.move(path_3i + &#34;/&#34; + filename_3o,
                    path_3o + &#34;/&#34; + filename_3o)
    except:
        print(&#39;Error: Could not move&#39;, filename_3o, &#34;to&#34;, path_3o)

    try:
        # rename pickup
        os.rename(path_3i + &#39;/pickup&#39;, path_3i + &#34;/&#34; + filename_3p)
    except:
        print(&#39;Error: EQ3 failed to produce a pickup file for &#39; + filename_3i)

    try:
        # move pickup
        shutil.move(path_3i + &#34;/&#34; + filename_3p,
                    path_3p + &#34;/&#34; + filename_3p)
    except:
        print(&#39;Error: Could not move&#39;, filename_3p, &#34;to&#34;, path_3p)</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.AqEquil.runeqpt"><code class="name flex">
<span>def <span class="ident">runeqpt</span></span>(<span>self, db, extra_eqpt_output=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a data0 into a data1 file with EQPT.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db</code></strong> :&ensp;<code>str</code></dt>
<dd>Three letter code of database.</dd>
<dt><strong><code>extra_eqpt_output</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Keep additional output files from EQPT? These files include
eqpt_log.txt, data1f.txt, and slist.txt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runeqpt(self, db, extra_eqpt_output=False):
    
    &#34;&#34;&#34;
    Convert a data0 into a data1 file with EQPT.
    
    Parameters
    ----------
    db : str
        Three letter code of database.
    
    extra_eqpt_output : bool, default False
        Keep additional output files from EQPT? These files include
        eqpt_log.txt, data1f.txt, and slist.txt.
    &#34;&#34;&#34;

    if os.path.exists(&#34;data0.&#34;+db) and os.path.isfile(&#34;data0.&#34;+db):
        pass
    else:
        raise Exception(&#34;Error: could not locate custom database&#34;,
                        &#34;data0.{} in {}.&#34;.format(db, os.getcwd()))

    if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
        os.remove(&#34;data1.&#34;+db)

    self.__clear_eqpt_extra_output()

    os.environ[&#39;EQ36DA&#39;] = os.getcwd()

    args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeqpt&#39;, db]

    try:
        self.__run_script_and_wait(args) # run EQPT
    except:
        os.environ[&#39;EQ36DA&#39;] = self.eq36da
        raise Exception(
            &#34;Error: EQPT failed to run on {}.&#34;.format(&#34;data0.&#34;+db))

    if os.path.exists(&#34;data1&#34;) and os.path.isfile(&#34;data1&#34;):
        os.rename(&#34;data1&#34;, &#34;data1.&#34;+db)
    if os.path.exists(&#34;output&#34;) and os.path.isfile(&#34;output&#34;):
        os.rename(&#34;output&#34;, &#34;eqpt_log.txt&#34;)
    if os.path.exists(&#34;data1f&#34;) and os.path.isfile(&#34;data1f&#34;):
        os.rename(&#34;data1f&#34;, &#34;data1f.txt&#34;)
    if os.path.exists(&#34;slist&#34;) and os.path.isfile(&#34;slist&#34;):
        os.rename(&#34;slist&#34;, &#34;slist.txt&#34;)

    if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
        if self.messages:
            print(&#34;Successfully created a data1.&#34;+db+&#34; from data0.&#34;+db)
    else:
        msg = (&#34;EQPT could not create data1.&#34;+db+&#34; from &#34;
               &#34;data0.&#34;+db+&#34;. Check eqpt_log.txt for details.&#34;)
        raise Exception(msg)

    if not extra_eqpt_output:
        self.__clear_eqpt_extra_output()

    os.environ[&#39;EQ36DA&#39;] = self.eq36da  # reset default EQ3 db path</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.AqEquil.speciate"><code class="name flex">
<span>def <span class="ident">speciate</span></span>(<span>self, input_filename, db='jus', redox_flag=0, redox_aux='Fe+3', default_logfO2=-6, exclude=[], suppress=[], charge_balance_on='none', suppress_missing=True, verbose=1, report_filename=None, get_aq_dist=True, aq_dist_type='log_activity', get_mass_contribution=True, mass_contribution_other=True, get_mineral_sat=True, mineral_sat_type='affinity', get_redox=True, redox_type='Eh', get_affinity_energy=False, rxn_filename=None, not_limiting=['H+', 'OH-', 'H2O'], get_charge_balance=True, custom_db=False, extra_eqpt_output=False, batch_3o_filename=None, delete_generated_folders=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the equilibrium distribution of chemical species in solution.
Additionally, calculate chemical affinities and energy supplies for
user-specified reactions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>User-supplied utf8-encoded comma separated value (csv) file
containing sample data intended for speciation. The file must
follow this format:</p>
<ul>
<li>the first row is a header row that must contain the names of the
species to be included in the speciation calculation. There
cannot be duplicate headers.</li>
<li>
<p>the second row must contain subheaders for each species in the
header row. These subheaders must be taken from the following:</p>
<pre><code>degC
ppm
ppb
Suppressed
Molality
Molarity
mg/L
mg/kg.sol
Alk., eq/kg.H2O
Alk., eq/L
Alk., eq/kg.sol
Alk., mg/L CaCO3
Alk., mg/L HCO3-
Log activity
Log act combo
Log mean act
pX
pH
pHCl
pmH
pmX
Hetero. equil.
Homo. equil.
Make non-basis
</code></pre>
</li>
<li>
<p>'Temperature' must be included as a header, with 'degC' as its
subheader.</p>
</li>
<li>The first column must contain sample names. There cannot be
duplicate sample names.</li>
</ul>
</dd>
<dt><strong><code>db</code></strong> :&ensp;<code>three letter str</code>, default <code>"jus"</code></dt>
<dd>Three letter file extension for the desired thermodynamic database.
If <code>custom_db</code> is False, this database must be named data1.xyz
(where xyz is your desired three letter extension) and located
in the EQ3/6 'EQ36DA' path. Otherwise, the database must be named
data0.xyz and located in your current working directory. Note that
data1 files are already compiled by EQPT, while data0 files will be
automatically compiled for you if <code>custom_db</code> is True.</dd>
<dt><strong><code>redox_flag</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>
<p>Values corresponding to redox options in the EQ3/6 v8.0 software.
For more information see the 'Redox Option' section of the EQ3/6
version 8.0 software user's manual. Set sample redox state with the
following options:</p>
<ul>
<li>-3 for O2(g)</li>
<li>-2 for pe (in pe units)</li>
<li>-1 for Eh (volts)</li>
<li>0 for logfO2 (log bars), or dissolved O2 (see below)</li>
<li>1 for defining a redox couple (see <code>redox_aux</code>)</li>
</ul>
<p>Note that if you are importing water chemistry data from a
spreadsheet, a column must be supplied with data that corresponds to
the redox option you chose. The column name is important:</p>
<ul>
<li>-3 must have a column named: O2(g)</li>
<li>-2 must have a column named: pe</li>
<li>-1 must have a column named: Eh</li>
<li>0 must have a column named: logfO2</li>
<li>1 must have a column corresponding to the auxilliary basis species
selected to form a redox couple with its linked species (see
<code>redox_aux</code>). For example, the redox couple Fe+2/Fe+3 would need
a column named: Fe+3</li>
</ul>
<p>If an appropriate header or redox data cannot be found to define
redox state, <code>default_logfO2</code> is used to set sample logfO2.</p>
<p>There is a special case where dissolved oxygen can be used to impose
sample redox state if <code>redox_flag</code> is set to 0 and a column named
logfO2 does not appear in the sample data sheet. If there is a
column corresponding to dissolved oxygen measurements, logfO2 is
calculated from the equilibrium reaction O2(aq) = O2(g) at the
temperature and pressure of the sample using the revised Helgeson-
Kirkham-Flowers (HKF) equation of state (JC Tanger IV and HC
Helgeson, Am. J. Sci., 1988, 288, 19).</p>
</dd>
<dt><strong><code>redox_aux</code></strong> :&ensp;<code>default "Fe+3"</code>, optional</dt>
<dd>Ignored unless <code>redox_flag</code> equals 1. Name of the auxilliary species
whose reaction links it to a basis species (or another auxilliary
species) such that they form a redox couple that controls sample
fO2. For instance, Fe+3 is linked to Fe+2 in many supporting data
files, so selecting <code>redox_flag</code> = 1 and <code>redox_aux</code> = "Fe+3" will
set sample fO2 based on the Fe+2/Fe+3 redox couple.</dd>
<dt><strong><code>default_logfO2</code></strong> :&ensp;<code>float</code>, default <code>-6</code></dt>
<dd>Default value for sample logfO2 in case redox data cannot be found
in the user-supplied sample spreadsheet.</dd>
<dt><strong><code>exclude</code></strong> :&ensp;<code>list</code> of <code>str</code>, default <code>[]</code></dt>
<dd>Names of columns in the user-supplied sample spreadsheet that should
not be considered aqueous species. Useful for excluding columns
containing sample metatadata, such as "Year" and "Location".</dd>
<dt><strong><code>suppress</code></strong> :&ensp;<code>list</code> of <code>str</code>, default <code>[]</code></dt>
<dd>Names of chemical species that will be prevented from forming in the
speciation calculation.</dd>
<dt><strong><code>charge_balance_on</code></strong> :&ensp;<code>str</code>, default <code>"none"</code></dt>
<dd>If "none", will not balance electrical charge between cations and
anions in the speciation calculation. If a name of a species is
supplied instead, the activity of that species will be allowed to
change until charge balance is obtained. For example,
charge_balance_on = "H+" will calculate what pH a sample must have
to have zero net charge.</dd>
<dt><strong><code>suppress_missing</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Suppress the formation of an aqueous species if it is missing a
value in the user-supplied sample spreadsheet?</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int, 0, 1,</code> or <code>2</code>, default <code>1</code></dt>
<dd>Level determining how many messages are returned during a
calculation. 2 for all messages, 1 for errors or warnings only,
0 for silent.</dd>
<dt><strong><code>report_filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the comma separated values (csv) report file generated when
the calculation is complete. If this argument is not defined, a
report file is not generated.</dd>
<dt><strong><code>get_aq_dist</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate distributions of aqueous species?</dd>
<dt><strong><code>aq_dist_type</code></strong> :&ensp;<code>str</code>, default <code>"log_activity"</code></dt>
<dd>Desired units of measurement for reported distributions of aqueous
species. Can be "molality", "log_molality", "log_gamma", or
"log_activity". Ignored if <code>get_aq_dist</code> is False.</dd>
<dt><strong><code>get_mass_contribution</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate basis species contributions to mass balance of aqueous
species?</dd>
<dt><strong><code>mass_contribution_other</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Include an "other" species for the sake of summing percents of basis
species contributions to 100%? Ignored if <code>get_mass_contribution</code> is
False.</dd>
<dt><strong><code>get_mineral_sat</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate saturation states of pure solids?</dd>
<dt><strong><code>mineral_sat_type</code></strong> :&ensp;<code>str</code>, default <code>"affinity"</code></dt>
<dd>Desired units of measurement for reported saturation states of pure
solids. Can be "logQoverK" or "affinity". Ignored if
<code>get_mineral_sat</code> is False.</dd>
<dt><strong><code>get_redox</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate potentials of redox couples?</dd>
<dt><strong><code>redox_type</code></strong> :&ensp;<code>str</code>, default <code>"Eh"</code></dt>
<dd>Desired units of measurement for reported redox potentials. Can be
"Eh", "pe", "logfO2", or "Ah". Ignored if <code>get_redox</code> is False.</dd>
<dt><strong><code>get_affinity_energy</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Calculate affinities and energy supplies of reactions listed in a
separate user-supplied file?</dd>
<dt><strong><code>rxn_filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of file containing reactions used to calculate affinities and
energy supplies. Ignored if <code>get_affinity_energy</code> is False.</dd>
<dt><strong><code>not_limiting</code></strong> :&ensp;<code>list</code>, default <code>["H+", "OH-", "H2O"]</code></dt>
<dd>List containing names of species that are not considered limiting
when calculating energy supplies. Ignored if <code>get_affinity_energy</code>
is False.</dd>
<dt><strong><code>get_charge_balance</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate charge balance and ionic strength?</dd>
<dt><strong><code>custom_db</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Is the database defined by <code>db</code> a custom user-supplied database? If
this is set to True, searches for a data0.xyz file in the current
working directory, where 'xyz' corresponds to the three letter code
assigned to <code>db</code>. This data0 file is automatically converted into a
machine-readable file called data1 by software called EQPT. This
data1 file is then used in speciation calculations.</dd>
<dt><strong><code>extra_eqpt_output</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Keep additional output files created by EQPT (see <code>custom_db</code>)?
Ignored if <code>custom_db</code> is False.</dd>
<dt><strong><code>batch_3o_filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of rds (R object) file exported after the speciation
calculation? No file will be generated if this argument is not
defined.</dd>
<dt><strong><code>delete_generated_folders</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Delete the 'rxn_3i', 'rxn_3o', and 'rxn_3p' folders containing raw
EQ3NR input, output, and pickup files once the speciation
calculation is complete?</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>speciation</code></strong> :&ensp;<code>object</code> of <code>class <a title="AqEquil.AqSpeciation.Speciation" href="#AqEquil.AqSpeciation.Speciation">Speciation</a></code></dt>
<dd>Contains the results of the speciation calculation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def speciate(self,
             input_filename,
             db=&#34;jus&#34;,
             redox_flag=0,
             redox_aux=&#34;Fe+3&#34;,
             default_logfO2=-6,
             exclude=[],
             suppress=[],
             charge_balance_on=&#34;none&#34;,
             suppress_missing=True,
             verbose=1,
             report_filename=None,
             get_aq_dist=True,
             aq_dist_type=&#34;log_activity&#34;,
             get_mass_contribution=True,
             mass_contribution_other=True,
             get_mineral_sat=True,
             mineral_sat_type=&#34;affinity&#34;,
             get_redox=True,
             redox_type=&#34;Eh&#34;,
             get_affinity_energy=False,
             rxn_filename=None,
             not_limiting=[&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;],
             get_charge_balance=True,
             custom_db=False,
             extra_eqpt_output=False,
             batch_3o_filename=None,
             delete_generated_folders=False):
    
    &#34;&#34;&#34;
    Calculate the equilibrium distribution of chemical species in solution.
    Additionally, calculate chemical affinities and energy supplies for
    user-specified reactions.
    
    Parameters
    ----------
    input_filename : str
        User-supplied utf8-encoded comma separated value (csv) file
        containing sample data intended for speciation. The file must
        follow this format:
        
        - the first row is a header row that must contain the names of the
          species to be included in the speciation calculation. There
          cannot be duplicate headers.
        - the second row must contain subheaders for each species in the
          header row. These subheaders must be taken from the following:
          
                degC
                ppm
                ppb
                Suppressed
                Molality
                Molarity
                mg/L
                mg/kg.sol
                Alk., eq/kg.H2O
                Alk., eq/L
                Alk., eq/kg.sol
                Alk., mg/L CaCO3
                Alk., mg/L HCO3-
                Log activity
                Log act combo
                Log mean act
                pX
                pH
                pHCl
                pmH
                pmX
                Hetero. equil.
                Homo. equil.
                Make non-basis
                
        - &#39;Temperature&#39; must be included as a header, with &#39;degC&#39; as its
          subheader.
        - The first column must contain sample names. There cannot be
          duplicate sample names.
    
    db : three letter str, default &#34;jus&#34;
        Three letter file extension for the desired thermodynamic database.
        If `custom_db` is False, this database must be named data1.xyz
        (where xyz is your desired three letter extension) and located
        in the EQ3/6 &#39;EQ36DA&#39; path. Otherwise, the database must be named
        data0.xyz and located in your current working directory. Note that
        data1 files are already compiled by EQPT, while data0 files will be
        automatically compiled for you if `custom_db` is True.
    
    redox_flag : int, default 0
        Values corresponding to redox options in the EQ3/6 v8.0 software.
        For more information see the &#39;Redox Option&#39; section of the EQ3/6
        version 8.0 software user&#39;s manual. Set sample redox state with the
        following options:
        
        * -3 for O2(g)
        * -2 for pe (in pe units)
        * -1 for Eh (volts)
        *  0 for logfO2 (log bars), or dissolved O2 (see below)
        *  1 for defining a redox couple (see `redox_aux`)
         
        Note that if you are importing water chemistry data from a
        spreadsheet, a column must be supplied with data that corresponds to
        the redox option you chose. The column name is important:
        
        * -3 must have a column named: O2(g)
        * -2 must have a column named: pe
        * -1 must have a column named: Eh
        *  0 must have a column named: logfO2
        *  1 must have a column corresponding to the auxilliary basis species
          selected to form a redox couple with its linked species (see
          `redox_aux`). For example, the redox couple Fe+2/Fe+3 would need
          a column named: Fe+3
        
        If an appropriate header or redox data cannot be found to define
        redox state, `default_logfO2` is used to set sample logfO2.
        
        There is a special case where dissolved oxygen can be used to impose
        sample redox state if `redox_flag` is set to 0 and a column named
        logfO2 does not appear in the sample data sheet. If there is a
        column corresponding to dissolved oxygen measurements, logfO2 is
        calculated from the equilibrium reaction O2(aq) = O2(g) at the
        temperature and pressure of the sample using the revised Helgeson-
        Kirkham-Flowers (HKF) equation of state (JC Tanger IV and HC
        Helgeson, Am. J. Sci., 1988, 288, 19).
    
    redox_aux : default &#34;Fe+3&#34;, optional
        Ignored unless `redox_flag` equals 1. Name of the auxilliary species
        whose reaction links it to a basis species (or another auxilliary
        species) such that they form a redox couple that controls sample
        fO2. For instance, Fe+3 is linked to Fe+2 in many supporting data
        files, so selecting `redox_flag` = 1 and `redox_aux` = &#34;Fe+3&#34; will
        set sample fO2 based on the Fe+2/Fe+3 redox couple.
    
    default_logfO2 : float, default -6
        Default value for sample logfO2 in case redox data cannot be found
        in the user-supplied sample spreadsheet.
    
    exclude : list of str, default []
        Names of columns in the user-supplied sample spreadsheet that should
        not be considered aqueous species. Useful for excluding columns
        containing sample metatadata, such as &#34;Year&#34; and &#34;Location&#34;.
        
    suppress : list of str, default []
        Names of chemical species that will be prevented from forming in the
        speciation calculation.
        
    charge_balance_on : str, default &#34;none&#34;
        If &#34;none&#34;, will not balance electrical charge between cations and
        anions in the speciation calculation. If a name of a species is
        supplied instead, the activity of that species will be allowed to
        change until charge balance is obtained. For example,
        charge_balance_on = &#34;H+&#34; will calculate what pH a sample must have
        to have zero net charge.
    
    suppress_missing : bool, default True
        Suppress the formation of an aqueous species if it is missing a
        value in the user-supplied sample spreadsheet?
    
    verbose : int, 0, 1, or 2, default 1
        Level determining how many messages are returned during a
        calculation. 2 for all messages, 1 for errors or warnings only,
        0 for silent.
        
    report_filename : str, optional
        Name of the comma separated values (csv) report file generated when
        the calculation is complete. If this argument is not defined, a
        report file is not generated.
        
    get_aq_dist : bool, default True
        Calculate distributions of aqueous species?
    
    aq_dist_type : str, default &#34;log_activity&#34;
        Desired units of measurement for reported distributions of aqueous
        species. Can be &#34;molality&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, or
        &#34;log_activity&#34;. Ignored if `get_aq_dist` is False.
    
    get_mass_contribution : bool, default True
        Calculate basis species contributions to mass balance of aqueous
        species?
    
    mass_contribution_other : bool, default True
        Include an &#34;other&#34; species for the sake of summing percents of basis
        species contributions to 100%? Ignored if `get_mass_contribution` is
        False.
    
    get_mineral_sat : bool, default True
        Calculate saturation states of pure solids?
    
    mineral_sat_type : str, default &#34;affinity&#34;
        Desired units of measurement for reported saturation states of pure
        solids. Can be &#34;logQoverK&#34; or &#34;affinity&#34;. Ignored if
        `get_mineral_sat` is False.
    
    get_redox : bool, default True
        Calculate potentials of redox couples?
        
    redox_type : str, default &#34;Eh&#34;
        Desired units of measurement for reported redox potentials. Can be
        &#34;Eh&#34;, &#34;pe&#34;, &#34;logfO2&#34;, or &#34;Ah&#34;. Ignored if `get_redox` is False.
        
    get_affinity_energy : bool, default False
        Calculate affinities and energy supplies of reactions listed in a
        separate user-supplied file?
    
    rxn_filename : str, optional
        Name of file containing reactions used to calculate affinities and
        energy supplies. Ignored if `get_affinity_energy` is False.
    
    not_limiting : list, default [&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;]
        List containing names of species that are not considered limiting
        when calculating energy supplies. Ignored if `get_affinity_energy`
        is False.
    
    get_charge_balance : bool, default True
        Calculate charge balance and ionic strength?
        
    custom_db : bool, default False
        Is the database defined by `db` a custom user-supplied database? If
        this is set to True, searches for a data0.xyz file in the current
        working directory, where &#39;xyz&#39; corresponds to the three letter code
        assigned to `db`. This data0 file is automatically converted into a
        machine-readable file called data1 by software called EQPT. This
        data1 file is then used in speciation calculations.
    
    extra_eqpt_output : bool, default False
        Keep additional output files created by EQPT (see `custom_db`)?
        Ignored if `custom_db` is False.
    
    batch_3o_filename : str, optional
        Name of rds (R object) file exported after the speciation
        calculation? No file will be generated if this argument is not
        defined.
        
    delete_generated_folders : bool, default False
        Delete the &#39;rxn_3i&#39;, &#39;rxn_3o&#39;, and &#39;rxn_3p&#39; folders containing raw
        EQ3NR input, output, and pickup files once the speciation
        calculation is complete?
    
    Returns
    -------
    speciation : object of class Speciation
        Contains the results of the speciation calculation.
    
    &#34;&#34;&#34;
    
    # check input sample file for errors
    self._check_sample_input_file(input_filename, exclude, db, custom_db)
    
    # handle batch_3o naming
    if batch_3o_filename != None:
        if &#34;.rds&#34; in batch_3o_filename[-4:]:
            batch_3o_filename = batch_3o_filename
        else:
            batch_3o_filename = &#34;batch_3o_{}.rds&#34;.format(db)
    else:
        batch_3o_filename = ro.r(&#34;NULL&#34;)

    if custom_db:
        # EQ3/6 cannot handle spaces in the &#39;EQ36DA&#39; path name.
        if &#34; &#34; in os.getcwd():
            msg = (&#34;Error: the path to the custom database &#34;
                &#34;cannot contain spaces. The current path &#34;
                &#34;is: [ &#34; + os.getcwd() + &#34; ]. Remove or &#34;
                &#34;replace spaces in folder names for this &#34;
                &#34;feature. Example: [ &#34; + os.getcwd().replace(&#34; &#34;, &#34;-&#34;) + &#34; ].&#34;)
            raise Exception(msg)

        self.runeqpt(db, extra_eqpt_output)
        os.environ[&#39;EQ36DA&#39;] = os.getcwd()

    if get_affinity_energy:
        if rxn_filename == None:
            wrn = (&#34;A reaction file was not specified. Affinities and &#34;
                &#34;energy supplies will not be calculated.&#34;)
            warnings.warn(wrn)
            get_affinity_energy = False
            rxn_filename = &#34;&#34;
        elif os.path.exists(rxn_filename) and os.path.isfile(rxn_filename):
            pass
        else:
            wrn = (&#34;Reaction file {} was not found. Affinities and &#34;
                &#34;energy supplies will not be &#34;
                &#34;calculated.&#34;.format(rxn_filename))
            warnings.warn(wrn)
            get_affinity_energy = False
            rxn_filename = &#34;&#34;
    else:
        rxn_filename = &#34;&#34;

    # preprocess for eq3 using R scripts
    with warnings.catch_warnings(record=True) as w:
        warnings.simplefilter(&#34;always&#34;)
        r_prescript = pkg_resources.resource_string(
            __name__, &#39;preprocess_for_EQ3.r&#39;).decode(&#34;utf-8&#34;)
        ro.r(r_prescript)
        df_input_processed = ro.r.preprocess(input_filename=input_filename,
                                             exclude=convert_to_RVector(
                                                 exclude),
                                             redox_flag=redox_flag,
                                             default_logfO2=default_logfO2,
                                             charge_balance_on=charge_balance_on,
                                             suppress_missing=suppress_missing,
                                             suppress=convert_to_RVector(
                                                 suppress),
                                             verbose=verbose)

    for warning in w:
        print(warning.message)

    self.df_input_processed = pandas2ri.ri2py_dataframe(df_input_processed)

    # run EQ3 on each input file
    cwd = os.getcwd()

    self.__mk_check_del_directory(&#39;rxn_3o&#39;)
    self.__mk_check_del_directory(&#39;rxn_3p&#39;)
    files_3i, files_3i_paths = self.__read_inputs(&#39;3i&#39;, &#39;rxn_3i&#39;)

    input_dir = cwd + &#34;/rxn_3i/&#34;
    output_dir = cwd + &#34;/rxn_3o/&#34;
    pickup_dir = cwd + &#34;/rxn_3p/&#34;
    
    for file in files_3i:
        self.runeq3(filename_3i=file, db=db, path_3i=input_dir,
                    path_3o=output_dir, path_3p=pickup_dir)

    if custom_db:
        os.environ[&#39;EQ36DA&#39;] = self.eq36da

    files_3o = [file+&#34;.3o&#34; for file in self.df_input_processed.index]
    
    df_input_processed_names = convert_to_RVector(list(self.df_input_processed.columns))
    
    # mine output
    with warnings.catch_warnings(record=True) as w:
        warnings.simplefilter(&#34;always&#34;)
        r_3o_mine = pkg_resources.resource_string(
            __name__, &#39;3o_mine.r&#39;).decode(&#34;utf-8&#34;)
        ro.r(r_3o_mine)
        batch_3o = ro.r.main_3o_mine(
            files_3o=convert_to_RVector(files_3o),
            input_filename=input_filename,
            rxn_filename=rxn_filename,
            get_aq_dist=get_aq_dist,
            aq_dist_type=aq_dist_type,
            get_mass_contribution=get_mass_contribution,
            mass_contribution_other=mass_contribution_other,
            get_mineral_sat=get_mineral_sat,
            mineral_sat_type=mineral_sat_type,
            get_redox=get_redox,
            redox_type=redox_type,
            get_charge_balance=get_charge_balance,
            get_affinity_energy=get_affinity_energy,
            not_limiting=convert_to_RVector(not_limiting),
            batch_3o_filename=batch_3o_filename,
            df_input_processed=pandas2ri.py2ri(self.df_input_processed),
            # Needed for keeping symbols in column names after porting
            #   df_input_processed in the line above. Some kind of check.names
            #   option for pandas2ri.py2ri would be nice. Workaround:
            df_input_processed_names=df_input_processed_names,
        )
    for warning in w:
        print(warning.message)
    
    if get_mass_contribution:
        mass_contribution = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;mass_contribution&#39;))
    df_report = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;report&#39;))
    df_input = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;input&#39;))
    report_divs = batch_3o.rx2(&#39;report_divs&#39;)

    input_cols = list(report_divs.rx2(&#39;input&#39;))
    df_input = df_report.loc[:, input_cols]

    # handle headers and subheaders of input section
    headers = [col.split(&#34;_&#34;)[0] for col in list(df_input.columns)]
    headers = [&#34;pH&#34; if header == &#34;H+&#34; else header for header in headers]
    headers = [header+&#34;_(input)&#34; if header not in [&#34;Temperature&#34;, &#34;pH&#34;]+exclude else header for header in headers]
    subheaders = [subheader[1] if len(subheader) &gt; 1 else &#34;&#34; for subheader in [
        col.split(&#34;_&#34;) for col in list(df_input.columns)]]
    multicolumns = pd.MultiIndex.from_arrays(
        [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
    df_input.columns = multicolumns

    df_join = df_input

    if get_aq_dist:
        aq_distribution_cols = list(report_divs.rx2(&#39;aq_distribution&#39;))
        df_aq_distribution = df_report.loc[:, aq_distribution_cols]
        df_aq_distribution = df_aq_distribution.apply(pd.to_numeric, errors=&#39;coerce&#39;)

        # handle headers of aq_distribution section
        headers = df_aq_distribution.columns
        subheaders = [aq_dist_type]*len(headers)
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_aq_distribution.columns = multicolumns
        df_join = df_join.join(df_aq_distribution)

    if get_mineral_sat:
        mineral_sat_cols = list(report_divs.rx2(&#39;mineral_sat&#39;))
        df_mineral_sat = df_report.loc[:, mineral_sat_cols]
        df_mineral_sat = df_mineral_sat.apply(pd.to_numeric, errors=&#39;coerce&#39;)

        # handle headers of df_mineral_sat section
        if mineral_sat_type == &#34;affinity&#34;:
            mineral_sat_unit = &#34;affinity_kcal&#34;
        elif mineral_sat_type == &#34;logQoverK&#34;:
            mineral_sat_unit = &#34;logQ/K&#34;
        else:
            raise Exception(
                &#34;mineral_sat_type must be either &#39;affinity&#39; or &#39;logQoverK&#39;&#34;)

        headers = df_mineral_sat.columns
        subheaders = [mineral_sat_unit]*len(headers)
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_mineral_sat.columns = multicolumns
        df_join = df_join.join(df_mineral_sat)

    if get_redox:
        redox_cols = list(report_divs.rx2(&#39;redox&#39;))
        df_redox = df_report.loc[:, redox_cols]
        df_redox = df_redox.apply(pd.to_numeric, errors=&#39;coerce&#39;)

        # handle headers of df_redox section
        if redox_type == &#34;Eh&#34;:
            redox_unit = &#34;Eh_volts&#34;
        elif redox_type == &#34;pe&#34;:
            redox_unit = &#34;pe&#34;
        elif redox_type == &#34;logfO2&#34;:
            redox_unit = &#34;logfO2&#34;
        elif redox_type == &#34;Ah&#34;:
            redox_unit = &#34;Ah_kcal&#34;
        else:
            raise Exception(
                &#34;redox_type must be either &#39;Eh&#39;, &#39;pe&#39;, &#39;logfO2&#39;, or &#39;Ah&#39;&#34;)

        headers = df_redox.columns
        subheaders = [redox_unit]*len(headers)
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_redox.columns = multicolumns
        df_join = df_join.join(df_redox)

    if get_charge_balance:
        charge_balance_cols = list(report_divs.rx2(&#39;charge_balance&#39;))
        df_charge_balance = df_report.loc[:, charge_balance_cols]
        df_charge_balance = df_charge_balance.apply(pd.to_numeric, errors=&#39;coerce&#39;)

        # handle headers of df_charge_balance section
        headers = df_charge_balance.columns
        subheaders = [&#34;%&#34;]*2 + [&#39;eq/kg.H2O&#39;, &#39;molality&#39;] + \
            [&#39;eq/kg.H2O&#39;]*4 + [&#39;molality&#39;]
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_charge_balance.columns = multicolumns
        df_join = df_join.join(df_charge_balance)

    if get_affinity_energy:
        affinity_cols = list(report_divs.rx2(&#39;affinity&#39;))
        energy_cols = list(report_divs.rx2(&#39;energy&#39;))
        df_affinity = df_report.loc[:, affinity_cols]
        df_energy = df_report.loc[:, energy_cols]
        df_affinity = df_affinity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
        df_energy = df_energy.apply(pd.to_numeric, errors=&#39;coerce&#39;)

        # handle headers of df_affinity section
        headers = df_affinity.columns
        subheaders = [&#39;cal/mol e-&#39;]*len(headers)
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_affinity.columns = multicolumns

        # handle headers of df_energy section
        headers = df_energy.columns
        subheaders = [&#39;cal/kg.H2O&#39;]*len(headers)
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_energy.columns = multicolumns
        df_join = df_join.join(df_affinity)
        df_join = df_join.join(df_energy)

    out_dict = {&#39;sample_data&#39;: {},
                &#39;report&#39;: df_join,
                &#39;input&#39;: df_input, &#39;report_divs&#39;: report_divs}
    
    if get_mass_contribution:
        out_dict[&#39;mass_contribution&#39;] = mass_contribution

    sample_data = batch_3o.rx2(&#39;sample_data&#39;)

    # assemble sample data
    for i, sample in enumerate(sample_data):
        dict_sample_data = {
            &#34;filename&#34;: str(sample.rx2(&#39;filename&#39;)[0]),
            &#34;name&#34;: str(sample.rx2(&#39;name&#39;)[0]),
            &#34;temperature&#34;: float(sample.rx2(&#39;temperature&#39;)[0]),
            &#34;pressure&#34;: float(sample.rx2(&#39;pressure&#39;)[0]),
            &#34;logact_H2O&#34;: float(sample.rx2(&#39;logact_H2O&#39;)[0]),
            &#34;H2O_density&#34;: float(sample.rx2(&#39;H2O_density&#39;)[0]),
            &#34;H2O_molality&#34;: float(sample.rx2(&#39;H2O_molality&#39;)[0]),
            &#34;H2O_log_molality&#34;: float(sample.rx2(&#39;H2O_log_molality&#39;)[0]),
            }

        if get_aq_dist:
            sample_aq_dist = pandas2ri.ri2py_dataframe(sample.rx2(&#39;aq_distribution&#39;))
            sample_aq_dist = sample_aq_dist.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            dict_sample_data.update({&#34;aq_distribution&#34;: sample_aq_dist})

        if get_mass_contribution:
            sample_mass_contribution = mass_contribution[mass_contribution[&#34;sample&#34;] == sample.rx2(&#39;name&#39;)[0]]
            dict_sample_data.update(
                {&#34;mass_contribution&#34;: sample_mass_contribution})

        if get_mineral_sat:
            dict_sample_data.update(
                {&#34;mineral_sat&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;mineral_sat&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

        if get_redox:
            dict_sample_data.update(
                {&#34;redox&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;redox&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

        if get_charge_balance:
            dict_sample_data.update({&#34;charge_balance&#34;: df_charge_balance.loc[sample.rx2(&#39;name&#39;)[0], :]})

        if get_affinity_energy:
            dict_sample_data.update({&#34;affinity_energy_raw&#34;: pandas2ri.ri2py_dataframe(
                sample.rx2(&#39;affinity_energy_raw&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
            dict_sample_data.update(
                {&#34;affinity_energy&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;affinity_energy&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

        out_dict[&#34;sample_data&#34;].update(
            {sample_data.names[i]: dict_sample_data})

    out_dict.update({&#34;batch_3o&#34;: batch_3o})
    speciation = Speciation(out_dict)

    if report_filename != None:
        if &#34;.csv&#34; in report_filename[-4:]:
            out_dict[&#34;report&#34;].to_csv(report_filename)
        else:
            out_dict[&#34;report&#34;].to_csv(report_filename+&#34;.csv&#34;)

    if delete_generated_folders:
        self._delete_rxn_folders()

    return speciation</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation"><code class="flex name class">
<span>class <span class="ident">Speciation</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the output of a speciation calculation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe containing user-supplied sample chemistry data.</dd>
<dt><strong><code>mass_contribution</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe containing basis species contributions to mass balance
of aqueous species.</dd>
<dt><strong><code>batch_3o</code></strong> :&ensp;<code>rpy2 ListVector</code></dt>
<dd>An rpy2 ListVector (R object) containing speciation results, in case
analysis in R is preferred.</dd>
<dt><strong><code>report</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe reporting major results of speciation calculation in
across all samples.</dd>
<dt><strong><code>report_divs</code></strong> :&ensp;<code>rpy2 ListVector</code></dt>
<dd>An rpy2 ListVector of column names within the different sections of the
speciation report.</dd>
<dt><strong><code>sample_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with sample names as keys and speciation results as values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Speciation(object):
    
    &#34;&#34;&#34;
    Stores the output of a speciation calculation.
    
    Attributes
    ----------
    input : pd.Dataframe
        Pandas dataframe containing user-supplied sample chemistry data.
    
    mass_contribution : pd.Dataframe
        Pandas dataframe containing basis species contributions to mass balance
        of aqueous species.
    
    batch_3o : rpy2 ListVector
        An rpy2 ListVector (R object) containing speciation results, in case
        analysis in R is preferred.
    
    report : pd.Dataframe
        Pandas dataframe reporting major results of speciation calculation in
        across all samples.
    
    report_divs : rpy2 ListVector
        An rpy2 ListVector of column names within the different sections of the
        speciation report.
    
    sample_data : dict
        Dictionary with sample names as keys and speciation results as values.
    
    &#34;&#34;&#34;
    
    def __init__(self, args):
        for k in args:
            setattr(self, k, args[k])

    def __getitem__(self, item):
         return getattr(self, item)
        
    def save(self, filename, messages=True):
        &#34;&#34;&#34;
        Save the speciation as a &#39;.speciation&#39; file to your current working
        directory. This file can be loaded with `AqEquil.load(filename)`.
        
        Parameters
        ----------
        filename : str
            The desired name of the file.
            
        messages : str
            Print a message confirming the save?
        &#34;&#34;&#34;
        
        if filename[-11:] != &#39;.speciation&#39;:
            filename = filename + &#39;.speciation&#39;
        
        with open(filename, &#39;wb&#39;) as handle:
            pickle.dump(self, handle, protocol=pickle.HIGHEST_PROTOCOL)
            if messages:
                print(&#34;Saved as &#39;{}&#39;&#34;.format(filename))
    
    
    @staticmethod
    def __get_unit_info(subheader):
        
        unit_name_dict = {
            &#34;pH&#34; : (&#34;&#34;, &#34;pH&#34;),
            &#34;ppm&#34; : (&#34;&#34;, &#34;ppm&#34;),
            &#34;ppb&#34; : (&#34;&#34;, &#34;ppb&#34;),
            &#34;mg/L&#34; : (&#34;&#34;, &#34;mg/L&#34;),
            &#34;degC&#34; : (&#34;temperature&#34;, &#34;°C&#34;),
            &#34;log_molality&#34; : (&#34;log molality&#34;, &#34;log(mol/kg)&#34;),
            &#34;Molality&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;molality&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;molal&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;log_activity&#34; : (&#34;log activity&#34;, &#34;log(mol/kg)&#34;),
            &#34;Log activity&#34; : (&#34;log activity&#34;, &#34;log(mol/kg)&#34;),
            &#34;mg/kg.sol&#34; : (&#34;&#34;, &#34;mg solute per kg solution&#34;),
            &#34;Alk., eq/kg.H2O&#34; : (&#34;alkalinity&#34;, &#34;eq/kg&#34;),
            &#34;Alk., eq/L&#34; : (&#34;alkalinity&#34;, &#34;eq/L&#34;),
            &#34;Alk., eq/kg.sol&#34; : (&#34;alkalinity&#34;, &#34;eq/kg solution&#34;),
            &#34;Alk., mg/L CaCO3&#34; : (&#34;alkalinity&#34;, &#34;mg/L CaCO3&#34;),
            &#34;Alk., mg/L HCO3-&#34; : (&#34;alkalinity&#34;, &#34;mg/L HCO3-&#34;),
            &#34;pX&#34; : (&#34;-(log activity)&#34;, &#34;-log(mol/kg)&#34;),
            &#34;activity&#34; : (&#34;activity&#34;, &#34;mol/kg&#34;),
            &#34;log_gamma&#34; : (&#34;log gamma&#34;, &#34;&#34;),
            &#34;gamma&#34; : (&#34;gamma&#34;, &#34;&#34;),
            &#34;affinity_kcal&#34; : (&#34;affinity&#34;, &#34;kcal/mol&#34;),
            &#34;%&#34; : (&#34;&#34;, &#34;%&#34;),
            &#34;Eh_volts&#34; : (&#34;Eh&#34;, &#34;volts&#34;),
            &#34;eq/kg.H2O&#34; : (&#34;charge&#34;, &#34;eq/kg&#34;),
        }
        
        out = unit_name_dict.get(subheader)
        
        return out[0], out[1]
    
    
    def lookup(self, col):
        
        &#34;&#34;&#34;
        Look up desired columns in the speciation report.
        
        Parameters
        ----------
        col : str or list of str
            Column name (or a list of column names) to look up.
            
        Returns
        ----------
        Pandas dataframe
            The speciation report with only the desired columns.
        &#34;&#34;&#34;
        
        if isinstance(col, str):
            col = [col]
        
        return self.report.iloc[:, self.report.columns.get_level_values(0).isin(set(col))]

    
    def __convert_aq_units_to_log_friendly(self, species):

        col_data = self.lookup(species)
        if col_data.columns.get_level_values(1) == &#39;log_activity&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;activity&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_molality&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;molality&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_gamma&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;gamma&#39;
        else:
            y = [float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = col_data.columns.get_level_values(1)[0]
        return y, out_unit
    
    
    def plot_mineral_saturation(self, sample_name, mineral_sat_type=&#34;affinity&#34;,
                                yrange=None,
                                colors=[&#34;blue&#34;, &#34;orange&#34;], bg_color=&#34;white&#34;,
                                save_as=None):
        &#34;&#34;&#34;
        Vizualize mineral saturation states in a sample as a bar plot.
        
        Parameters
        ----------
        sample_name : str
            Name of the sample to plot.
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Metric for mineral saturation state to plot. Can be &#34;affinity&#34; or
            &#34;logQoverK&#34;.
            
        yrange : list of numeric, optional
            Sets the lower and upper limits of the y axis.
        
        colors : list of two str, default [&#34;blue&#34;, &#34;orange&#34;]
            Sets the color of the bars representing supersaturated
            and undersaturated states, respectively.
        
        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        plt.xticks(rotation = 45, ha=&#39;right&#39;)
        
        if &#39;mineral_sat&#39; in self.sample_data[sample_name].keys():
            mineral_data = self.sample_data[sample_name][&#39;mineral_sat&#39;][mineral_sat_type].astype(float).sort_values(ascending=False)
            x = mineral_data.index
        else:
            msg = (&#34;This sample does not contain mineral saturation state data.&#34;
                   &#34;To generate this data, ensure that get_mineral_sat=True when&#34;
                   &#34;running speciate().&#34;)
            raise Exception(msg)
        
        pos_sat = [m if m &gt;= 0 else float(&#34;nan&#34;) for m in mineral_data] # possibly: special list for m==0
        neg_sat = [m if m &lt; 0 else float(&#34;nan&#34;) for m in mineral_data]
        
        barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
        for i, y_plot in enumerate([pos_sat, neg_sat]):
            
            if i == 0:
                color = colors[0]
            else:
                color = colors[1]
                
            bars = ax.bar(x, y_plot, tick_label=x, color=color)
            
            barlist.append(bars)
            
            if mineral_sat_type == &#34;affinity&#34;:
                ylabel = &#39;affinity, kcal/mol&#39;
            if mineral_sat_type == &#34;logQoverK&#34;:
                ylabel = &#39;logQ/K&#39;
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])
        
        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    

    def barplot(self, y, yrange=None, show_trace=True,
                show_legend=True, legend_loc=&#34;best&#34;,
                colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
        
        &#34;&#34;&#34;
        Show a bar plot to vizualize one or more variables across all samples.
        
        Parameters
        ----------
        y : str or list of str
            Name (or list of names) of the variables to plot. Valid variables
            are columns in the speciation report.
       
        yrange : list of numeric, optional
            Sets the lower and upper limits of the y axis.
        
        show_trace : bool, default True
            Show asterisks for columns with numerical values but are too short
            to see clearly?
            
        show_legend : bool, default True
            Show a legend if there is more than one variable?
        
        legend_loc : str or pair of float, default &#34;best&#34;
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        colormap : str, default &#34;viridis&#34;
            Name of the Matplotlib colormap to color the barplot. See
            https://matplotlib.org/stable/tutorials/colors/colormaps.html

        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        plt.xticks(rotation = 45, ha=&#39;right&#39;)

        if not isinstance(y, list):
            y = [y]
        
        x = self.lookup(y[0]).index # names of samples
        
        norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
        cmap = cm.__getattribute__(colormap)
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        X = np.arange(len(x))
        
        barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
        for i, yi in enumerate(y):
            y_col = self.lookup(yi)
            
            try:
                subheader = y_col.columns.get_level_values(1)[0]
            except:
                msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                       &#34;report. Available variables include &#34;
                      &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
                raise Exception(msg)
            unit_type, unit = self.__get_unit_info(subheader)
            
            try:
                y_vals = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
            except:
                msg = (&#34;One or more the values belonging to &#34;
                       &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0])+&#34;&#34;)
                raise Exception(msg)
            
            if [abs(y0) for y0 in y_vals] != y_vals: # convert to bar-friendly units if possible
                if subheader in [&#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;]:
                    y_plot, out_unit = self.__convert_aq_units_to_log_friendly(yi)
                    unit_type, unit = self.__get_unit_info(out_unit)
                else:
                    y_plot = y_vals
            else:
                y_plot = y_vals
                
            if i == 0:
                subheader_previous = subheader
                unit_previous = unit
            if unit != unit_previous and i != 0:
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
                
            yi_previous = copy.deepcopy(yi)
            unit_previous = copy.deepcopy(unit)
            subheader_previous = copy.deepcopy(subheader)
            
            if len(y) != 1:
                color = m.to_rgba(i)
            else:
                color = &#34;black&#34;
                
            bars = ax.bar(X+i*(1/(len(y)+1)), y_plot, tick_label=x, color=color, width=1/(len(y)+1))
            
            barlist.append(bars)

        max_bar_height = 0
        for bars in barlist:
            for p in bars.patches:
                max_bar_height = max([max_bar_height, np.nanmax(abs(p.get_height()))])
                
        for i,bars in enumerate(barlist):
            for p in bars.patches:
                if show_trace and abs(p.get_height())/max_bar_height &lt;= 0.009:
                    plt.annotate(&#34;*&#34;,
                                  (p.get_x() + p.get_width() / 2., p.get_height()),
                                  ha = &#39;center&#39;, va = &#39;center&#39;, xytext = (0, 10),
                                  color=m.to_rgba(i),
                                  weight=&#39;bold&#39;,
                                  fontsize=18,
                                  textcoords = &#39;offset points&#39;)
        
        if len(y) &gt; 1:
            ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
            if show_legend:
                ax.legend(labels=y, loc=legend_loc)
        else:
            if &#39;pH&#39; in y:
                ylabel = &#39;pH&#39;
            elif &#39;Temperature&#39; in y:
                ylabel = &#39;Temperature [°C]&#39;
            else:
                ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])
        
        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    
    
    def scatterplot(self, x=&#34;pH&#34;, y=&#34;Temperature&#34;, xrange=None, yrange=None,
                show_legend=True, legend_loc=&#34;best&#34;,
                colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
        
        &#34;&#34;&#34;
        Vizualize two or more sample variables with a scatterplot.
        
        Parameters
        ----------
        x, y : str, default for x is &#34;pH&#34;, default for y is &#34;Temperature&#34;
            Names of the variables to plot against each other. Valid variables
            are columns in the speciation report. `y` can be a list of
            of variable names for a multi-series scatterplot.
       
        xrange, yrange : list of numeric, optional
            Sets the lower and upper limits of the x and y axis.
            
        show_legend : bool, default True
            Show a legend if there is more than one variable?
        
        legend_loc : str or pair of float, default &#34;best&#34;
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        colormap : str, default &#34;viridis&#34;
            Name of the Matplotlib colormap to color the scatterpoints. See
            https://matplotlib.org/stable/tutorials/colors/colormaps.html

        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])

        if not isinstance(y, list):
            y = [y]
        
        if not isinstance(x, str):
            raise Exception(&#34;x must be a string.&#34;)
        
        x_col = self.lookup(x)
        try:
            x_plot = [float(x0[0]) if x0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for x0 in x_col.values.tolist()]
        except:
            msg = (&#34;One or more the values belonging to &#34;
                   &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(x_col.columns.get_level_values(0)[0])+&#34;&#34;)
            raise Exception(msg)
        
        try:
            xsubheader = x_col.columns.get_level_values(1)[0]
        except:
            msg = (&#34;Could not find &#39;{}&#39; &#34;.format(x)+&#34;in the speciation &#34;
                   &#34;report. Available variables include &#34;
                   &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
            raise Exception(msg)
        xunit_type, xunit = self.__get_unit_info(xsubheader)
        
        norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
        cmap = cm.__getattribute__(colormap)
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        
        for i, yi in enumerate(y):
            y_col = self.lookup(yi)
            
            try:
                subheader = y_col.columns.get_level_values(1)[0]
            except:
                msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                       &#34;report. Available variables include &#34;
                      &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
                raise Exception(msg)
            unit_type, unit = self.__get_unit_info(subheader)
            
            try:
                y_plot = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
            except:
                msg = (&#34;One or more the values belonging to &#34;
                       &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0])+&#34;&#34;)
                raise Exception(msg)
                
            if i == 0:
                subheader_previous = subheader
                unit_previous = unit
            if unit != unit_previous and i != 0:
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
                
            yi_previous = copy.deepcopy(yi)
            unit_previous = copy.deepcopy(unit)
            subheader_previous = copy.deepcopy(subheader)
            
            if len(y) != 1:
                color = m.to_rgba(i)
            else:
                color = &#34;black&#34;
            
            plt.scatter(x_plot, y_plot, marker=&#39;o&#39;, color=color)

        if len(y) &gt; 1:
            ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
            if show_legend:
                ax.legend(labels=y, loc=legend_loc)
        else:
            if &#39;pH&#39; in y:
                ylabel = &#39;pH&#39;
            elif &#39;Temperature&#39; in y:
                ylabel = &#39;Temperature [°C]&#39;
            else:
                ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
        
        if x == &#39;pH&#39;:
            xlabel = &#39;pH&#39;
        elif x == &#39;Temperature&#39;:
            xlabel = &#39;Temperature [°C]&#39;
        else:
            xlabel = &#34;{} {} [{}]&#34;.format(x, xunit_type, xunit)
        
        if xrange != None:
            plt.xlim(xrange[0], xrange[1])
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])

        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)
        plt.xlabel(xlabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    
    
    def plot_mass_contribution(self, basis, width=0.9,
                                     legend_loc=(1.02, 0.5)):
        
        &#34;&#34;&#34;
        Plot basis species contributions to mass balance of aqueous species
        across all samples.
        
        Parameters
        ----------
        basis : str
            Name of the basis species.
            
        width : float, default 0.9
            Width of bars. No space between bars if width=1.0.
        
        legend_loc : str or pair of float, default (1.02, 0.5)
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        &#34;&#34;&#34;
        
        try:
            self.mass_contribution
        except:
            msg = (&#34;Results for basis species contributions to aqueous mass &#34;
                   &#34;balance could not be found. Ensure that &#34;
                   &#34;get_mass_contribution = True when running speciate().&#34;)
            raise Exception(msg)
            
        if basis not in set(self.mass_contribution[&#39;basis&#39;]):
            msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
                   &#34;among available basis species: &#34;
                   &#34;{}&#34;.format(str(list(set(self.mass_contribution[&#39;basis&#39;]))))+&#34;&#34;)
            raise Exception(msg)
            
        df_sp = copy.deepcopy(self.mass_contribution.loc[self.mass_contribution[&#39;basis&#39;] == basis])
        
        df_sp[&#39;percent&#39;] = df_sp[&#39;percent&#39;].astype(float)
        
        unique_species = unique(df_sp[&#34;species&#34;])
        
        if &#34;Other&#34; in unique_species:

            unique_species.append(unique_species.pop(unique_species.index(&#34;Other&#34;)))
        
        labels = unique(df_sp[&#34;sample&#34;])

        fig, ax = plt.subplots()

        bottom = np.array([0]*len(labels))

        for i,sp in enumerate(unique_species):
            percents = []
            for sample in labels:
                df_sample = df_sp[df_sp[&#34;sample&#34;]==sample]
                try:
                    percent = df_sample[df_sample[&#34;species&#34;]==sp][&#34;percent&#34;].iloc[0]
                    percents.append(percent)
                except:
                    percents.append(0.0)
            ax.bar(labels, percents, width, bottom=bottom, label=sp)
            bottom = bottom + np.array(percents)

        ax.set_ylabel(&#39;%&#39;)
        ax.set_title(&#39;Species accounting for mass balance of &#39;+basis)
        plt.xticks(rotation = 45, ha=&#39;right&#39;)

        ax.legend(loc=legend_loc)
        
        plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AqEquil.AqSpeciation.Speciation.barplot"><code class="name flex">
<span>def <span class="ident">barplot</span></span>(<span>self, y, yrange=None, show_trace=True, show_legend=True, legend_loc='best', colormap='viridis', bg_color='white', save_as=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a bar plot to vizualize one or more variables across all samples.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Name (or list of names) of the variables to plot. Valid variables
are columns in the speciation report.</dd>
<dt><strong><code>yrange</code></strong> :&ensp;<code>list</code> of <code>numeric</code>, optional</dt>
<dd>Sets the lower and upper limits of the y axis.</dd>
<dt><strong><code>show_trace</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show asterisks for columns with numerical values but are too short
to see clearly?</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show a legend if there is more than one variable?</dd>
<dt><strong><code>legend_loc</code></strong> :&ensp;<code>str</code> or <code>pair</code> of <code>float</code>, default <code>"best"</code></dt>
<dd>Location of the legend on the plot. See
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend">https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend</a></dd>
<dt><strong><code>colormap</code></strong> :&ensp;<code>str</code>, default <code>"viridis"</code></dt>
<dd>Name of the Matplotlib colormap to color the barplot. See
<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">https://matplotlib.org/stable/tutorials/colors/colormaps.html</a></dd>
<dt><strong><code>bg_color</code></strong> :&ensp;<code>str</code>, default <code>"white"</code></dt>
<dd>Name of the Matplotlib color you wish to set as the panel
background. A list of named colors can be found here:
<a href="https://matplotlib.org/stable/gallery/color/named_colors.html">https://matplotlib.org/stable/gallery/color/named_colors.html</a></dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure as a PNG.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def barplot(self, y, yrange=None, show_trace=True,
            show_legend=True, legend_loc=&#34;best&#34;,
            colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
    
    &#34;&#34;&#34;
    Show a bar plot to vizualize one or more variables across all samples.
    
    Parameters
    ----------
    y : str or list of str
        Name (or list of names) of the variables to plot. Valid variables
        are columns in the speciation report.
   
    yrange : list of numeric, optional
        Sets the lower and upper limits of the y axis.
    
    show_trace : bool, default True
        Show asterisks for columns with numerical values but are too short
        to see clearly?
        
    show_legend : bool, default True
        Show a legend if there is more than one variable?
    
    legend_loc : str or pair of float, default &#34;best&#34;
        Location of the legend on the plot. See
        https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
    
    colormap : str, default &#34;viridis&#34;
        Name of the Matplotlib colormap to color the barplot. See
        https://matplotlib.org/stable/tutorials/colors/colormaps.html

    bg_color : str, default &#34;white&#34;
        Name of the Matplotlib color you wish to set as the panel
        background. A list of named colors can be found here:
        https://matplotlib.org/stable/gallery/color/named_colors.html
        
    save_as : str, optional
        Provide a filename to save this figure as a PNG.
    &#34;&#34;&#34;
    
    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])
    plt.xticks(rotation = 45, ha=&#39;right&#39;)

    if not isinstance(y, list):
        y = [y]
    
    x = self.lookup(y[0]).index # names of samples
    
    norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
    cmap = cm.__getattribute__(colormap)
    m = cm.ScalarMappable(norm=norm, cmap=cmap)
    X = np.arange(len(x))
    
    barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
    for i, yi in enumerate(y):
        y_col = self.lookup(yi)
        
        try:
            subheader = y_col.columns.get_level_values(1)[0]
        except:
            msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                   &#34;report. Available variables include &#34;
                  &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
            raise Exception(msg)
        unit_type, unit = self.__get_unit_info(subheader)
        
        try:
            y_vals = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
        except:
            msg = (&#34;One or more the values belonging to &#34;
                   &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0])+&#34;&#34;)
            raise Exception(msg)
        
        if [abs(y0) for y0 in y_vals] != y_vals: # convert to bar-friendly units if possible
            if subheader in [&#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;]:
                y_plot, out_unit = self.__convert_aq_units_to_log_friendly(yi)
                unit_type, unit = self.__get_unit_info(out_unit)
            else:
                y_plot = y_vals
        else:
            y_plot = y_vals
            
        if i == 0:
            subheader_previous = subheader
            unit_previous = unit
        if unit != unit_previous and i != 0:
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
        elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
        elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
            
        yi_previous = copy.deepcopy(yi)
        unit_previous = copy.deepcopy(unit)
        subheader_previous = copy.deepcopy(subheader)
        
        if len(y) != 1:
            color = m.to_rgba(i)
        else:
            color = &#34;black&#34;
            
        bars = ax.bar(X+i*(1/(len(y)+1)), y_plot, tick_label=x, color=color, width=1/(len(y)+1))
        
        barlist.append(bars)

    max_bar_height = 0
    for bars in barlist:
        for p in bars.patches:
            max_bar_height = max([max_bar_height, np.nanmax(abs(p.get_height()))])
            
    for i,bars in enumerate(barlist):
        for p in bars.patches:
            if show_trace and abs(p.get_height())/max_bar_height &lt;= 0.009:
                plt.annotate(&#34;*&#34;,
                              (p.get_x() + p.get_width() / 2., p.get_height()),
                              ha = &#39;center&#39;, va = &#39;center&#39;, xytext = (0, 10),
                              color=m.to_rgba(i),
                              weight=&#39;bold&#39;,
                              fontsize=18,
                              textcoords = &#39;offset points&#39;)
    
    if len(y) &gt; 1:
        ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
        if show_legend:
            ax.legend(labels=y, loc=legend_loc)
    else:
        if &#39;pH&#39; in y:
            ylabel = &#39;pH&#39;
        elif &#39;Temperature&#39; in y:
            ylabel = &#39;Temperature [°C]&#39;
        else:
            ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
    
    if yrange != None:
        plt.ylim(yrange[0], yrange[1])
    
    ax.set_facecolor(bg_color)
    plt.ylabel(ylabel)

    if save_as != None:
        if &#34;.png&#34; not in save_as[:-4]:
            save_as = save_as+&#34;.png&#34;
        
        plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
        print(&#34;Saved figure as {}&#34;.format(save_as))
    
    plt.show()</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.lookup"><code class="name flex">
<span>def <span class="ident">lookup</span></span>(<span>self, col)</span>
</code></dt>
<dd>
<div class="desc"><p>Look up desired columns in the speciation report.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>col</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Column name (or a list of column names) to look up.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Pandas dataframe</code></dt>
<dd>The speciation report with only the desired columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup(self, col):
    
    &#34;&#34;&#34;
    Look up desired columns in the speciation report.
    
    Parameters
    ----------
    col : str or list of str
        Column name (or a list of column names) to look up.
        
    Returns
    ----------
    Pandas dataframe
        The speciation report with only the desired columns.
    &#34;&#34;&#34;
    
    if isinstance(col, str):
        col = [col]
    
    return self.report.iloc[:, self.report.columns.get_level_values(0).isin(set(col))]</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.plot_mass_contribution"><code class="name flex">
<span>def <span class="ident">plot_mass_contribution</span></span>(<span>self, basis, width=0.9, legend_loc=(1.02, 0.5))</span>
</code></dt>
<dd>
<div class="desc"><p>Plot basis species contributions to mass balance of aqueous species
across all samples.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>basis</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the basis species.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, default <code>0.9</code></dt>
<dd>Width of bars. No space between bars if width=1.0.</dd>
<dt><strong><code>legend_loc</code></strong> :&ensp;<code>str</code> or <code>pair</code> of <code>float</code>, default <code>(1.02, 0.5)</code></dt>
<dd>Location of the legend on the plot. See
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend">https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend</a></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mass_contribution(self, basis, width=0.9,
                                 legend_loc=(1.02, 0.5)):
    
    &#34;&#34;&#34;
    Plot basis species contributions to mass balance of aqueous species
    across all samples.
    
    Parameters
    ----------
    basis : str
        Name of the basis species.
        
    width : float, default 0.9
        Width of bars. No space between bars if width=1.0.
    
    legend_loc : str or pair of float, default (1.02, 0.5)
        Location of the legend on the plot. See
        https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
    &#34;&#34;&#34;
    
    try:
        self.mass_contribution
    except:
        msg = (&#34;Results for basis species contributions to aqueous mass &#34;
               &#34;balance could not be found. Ensure that &#34;
               &#34;get_mass_contribution = True when running speciate().&#34;)
        raise Exception(msg)
        
    if basis not in set(self.mass_contribution[&#39;basis&#39;]):
        msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
               &#34;among available basis species: &#34;
               &#34;{}&#34;.format(str(list(set(self.mass_contribution[&#39;basis&#39;]))))+&#34;&#34;)
        raise Exception(msg)
        
    df_sp = copy.deepcopy(self.mass_contribution.loc[self.mass_contribution[&#39;basis&#39;] == basis])
    
    df_sp[&#39;percent&#39;] = df_sp[&#39;percent&#39;].astype(float)
    
    unique_species = unique(df_sp[&#34;species&#34;])
    
    if &#34;Other&#34; in unique_species:

        unique_species.append(unique_species.pop(unique_species.index(&#34;Other&#34;)))
    
    labels = unique(df_sp[&#34;sample&#34;])

    fig, ax = plt.subplots()

    bottom = np.array([0]*len(labels))

    for i,sp in enumerate(unique_species):
        percents = []
        for sample in labels:
            df_sample = df_sp[df_sp[&#34;sample&#34;]==sample]
            try:
                percent = df_sample[df_sample[&#34;species&#34;]==sp][&#34;percent&#34;].iloc[0]
                percents.append(percent)
            except:
                percents.append(0.0)
        ax.bar(labels, percents, width, bottom=bottom, label=sp)
        bottom = bottom + np.array(percents)

    ax.set_ylabel(&#39;%&#39;)
    ax.set_title(&#39;Species accounting for mass balance of &#39;+basis)
    plt.xticks(rotation = 45, ha=&#39;right&#39;)

    ax.legend(loc=legend_loc)
    
    plt.show()</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.plot_mineral_saturation"><code class="name flex">
<span>def <span class="ident">plot_mineral_saturation</span></span>(<span>self, sample_name, mineral_sat_type='affinity', yrange=None, colors=['blue', 'orange'], bg_color='white', save_as=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Vizualize mineral saturation states in a sample as a bar plot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sample_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the sample to plot.</dd>
<dt><strong><code>mineral_sat_type</code></strong> :&ensp;<code>str</code>, default <code>"affinity"</code></dt>
<dd>Metric for mineral saturation state to plot. Can be "affinity" or
"logQoverK".</dd>
<dt><strong><code>yrange</code></strong> :&ensp;<code>list</code> of <code>numeric</code>, optional</dt>
<dd>Sets the lower and upper limits of the y axis.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>list</code> of <code>two str</code>, default <code>["blue", "orange"]</code></dt>
<dd>Sets the color of the bars representing supersaturated
and undersaturated states, respectively.</dd>
<dt><strong><code>bg_color</code></strong> :&ensp;<code>str</code>, default <code>"white"</code></dt>
<dd>Name of the Matplotlib color you wish to set as the panel
background. A list of named colors can be found here:
<a href="https://matplotlib.org/stable/gallery/color/named_colors.html">https://matplotlib.org/stable/gallery/color/named_colors.html</a></dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure as a PNG.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mineral_saturation(self, sample_name, mineral_sat_type=&#34;affinity&#34;,
                            yrange=None,
                            colors=[&#34;blue&#34;, &#34;orange&#34;], bg_color=&#34;white&#34;,
                            save_as=None):
    &#34;&#34;&#34;
    Vizualize mineral saturation states in a sample as a bar plot.
    
    Parameters
    ----------
    sample_name : str
        Name of the sample to plot.
    
    mineral_sat_type : str, default &#34;affinity&#34;
        Metric for mineral saturation state to plot. Can be &#34;affinity&#34; or
        &#34;logQoverK&#34;.
        
    yrange : list of numeric, optional
        Sets the lower and upper limits of the y axis.
    
    colors : list of two str, default [&#34;blue&#34;, &#34;orange&#34;]
        Sets the color of the bars representing supersaturated
        and undersaturated states, respectively.
    
    bg_color : str, default &#34;white&#34;
        Name of the Matplotlib color you wish to set as the panel
        background. A list of named colors can be found here:
        https://matplotlib.org/stable/gallery/color/named_colors.html
        
    save_as : str, optional
        Provide a filename to save this figure as a PNG.
    &#34;&#34;&#34;
    
    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])
    plt.xticks(rotation = 45, ha=&#39;right&#39;)
    
    if &#39;mineral_sat&#39; in self.sample_data[sample_name].keys():
        mineral_data = self.sample_data[sample_name][&#39;mineral_sat&#39;][mineral_sat_type].astype(float).sort_values(ascending=False)
        x = mineral_data.index
    else:
        msg = (&#34;This sample does not contain mineral saturation state data.&#34;
               &#34;To generate this data, ensure that get_mineral_sat=True when&#34;
               &#34;running speciate().&#34;)
        raise Exception(msg)
    
    pos_sat = [m if m &gt;= 0 else float(&#34;nan&#34;) for m in mineral_data] # possibly: special list for m==0
    neg_sat = [m if m &lt; 0 else float(&#34;nan&#34;) for m in mineral_data]
    
    barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
    for i, y_plot in enumerate([pos_sat, neg_sat]):
        
        if i == 0:
            color = colors[0]
        else:
            color = colors[1]
            
        bars = ax.bar(x, y_plot, tick_label=x, color=color)
        
        barlist.append(bars)
        
        if mineral_sat_type == &#34;affinity&#34;:
            ylabel = &#39;affinity, kcal/mol&#39;
        if mineral_sat_type == &#34;logQoverK&#34;:
            ylabel = &#39;logQ/K&#39;
    
    if yrange != None:
        plt.ylim(yrange[0], yrange[1])
    
    ax.set_facecolor(bg_color)
    plt.ylabel(ylabel)

    if save_as != None:
        if &#34;.png&#34; not in save_as[:-4]:
            save_as = save_as+&#34;.png&#34;
        
        plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
        print(&#34;Saved figure as {}&#34;.format(save_as))
    
    plt.show()</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename, messages=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the speciation as a '.speciation' file to your current working
directory. This file can be loaded with <code>AqEquil.load(filename)</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The desired name of the file.</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>str</code></dt>
<dd>Print a message confirming the save?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename, messages=True):
    &#34;&#34;&#34;
    Save the speciation as a &#39;.speciation&#39; file to your current working
    directory. This file can be loaded with `AqEquil.load(filename)`.
    
    Parameters
    ----------
    filename : str
        The desired name of the file.
        
    messages : str
        Print a message confirming the save?
    &#34;&#34;&#34;
    
    if filename[-11:] != &#39;.speciation&#39;:
        filename = filename + &#39;.speciation&#39;
    
    with open(filename, &#39;wb&#39;) as handle:
        pickle.dump(self, handle, protocol=pickle.HIGHEST_PROTOCOL)
        if messages:
            print(&#34;Saved as &#39;{}&#39;&#34;.format(filename))</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.scatterplot"><code class="name flex">
<span>def <span class="ident">scatterplot</span></span>(<span>self, x='pH', y='Temperature', xrange=None, yrange=None, show_legend=True, legend_loc='best', colormap='viridis', bg_color='white', save_as=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Vizualize two or more sample variables with a scatterplot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>str</code>, default <code>for x is "pH"</code>, default <code>for y is "Temperature"</code></dt>
<dd>Names of the variables to plot against each other. Valid variables
are columns in the speciation report. <code>y</code> can be a list of
of variable names for a multi-series scatterplot.</dd>
<dt><strong><code>xrange</code></strong>, <strong><code>yrange</code></strong> :&ensp;<code>list</code> of <code>numeric</code>, optional</dt>
<dd>Sets the lower and upper limits of the x and y axis.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show a legend if there is more than one variable?</dd>
<dt><strong><code>legend_loc</code></strong> :&ensp;<code>str</code> or <code>pair</code> of <code>float</code>, default <code>"best"</code></dt>
<dd>Location of the legend on the plot. See
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend">https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend</a></dd>
<dt><strong><code>colormap</code></strong> :&ensp;<code>str</code>, default <code>"viridis"</code></dt>
<dd>Name of the Matplotlib colormap to color the scatterpoints. See
<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">https://matplotlib.org/stable/tutorials/colors/colormaps.html</a></dd>
<dt><strong><code>bg_color</code></strong> :&ensp;<code>str</code>, default <code>"white"</code></dt>
<dd>Name of the Matplotlib color you wish to set as the panel
background. A list of named colors can be found here:
<a href="https://matplotlib.org/stable/gallery/color/named_colors.html">https://matplotlib.org/stable/gallery/color/named_colors.html</a></dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure as a PNG.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatterplot(self, x=&#34;pH&#34;, y=&#34;Temperature&#34;, xrange=None, yrange=None,
            show_legend=True, legend_loc=&#34;best&#34;,
            colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
    
    &#34;&#34;&#34;
    Vizualize two or more sample variables with a scatterplot.
    
    Parameters
    ----------
    x, y : str, default for x is &#34;pH&#34;, default for y is &#34;Temperature&#34;
        Names of the variables to plot against each other. Valid variables
        are columns in the speciation report. `y` can be a list of
        of variable names for a multi-series scatterplot.
   
    xrange, yrange : list of numeric, optional
        Sets the lower and upper limits of the x and y axis.
        
    show_legend : bool, default True
        Show a legend if there is more than one variable?
    
    legend_loc : str or pair of float, default &#34;best&#34;
        Location of the legend on the plot. See
        https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
    
    colormap : str, default &#34;viridis&#34;
        Name of the Matplotlib colormap to color the scatterpoints. See
        https://matplotlib.org/stable/tutorials/colors/colormaps.html

    bg_color : str, default &#34;white&#34;
        Name of the Matplotlib color you wish to set as the panel
        background. A list of named colors can be found here:
        https://matplotlib.org/stable/gallery/color/named_colors.html
        
    save_as : str, optional
        Provide a filename to save this figure as a PNG.
    &#34;&#34;&#34;
    
    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])

    if not isinstance(y, list):
        y = [y]
    
    if not isinstance(x, str):
        raise Exception(&#34;x must be a string.&#34;)
    
    x_col = self.lookup(x)
    try:
        x_plot = [float(x0[0]) if x0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for x0 in x_col.values.tolist()]
    except:
        msg = (&#34;One or more the values belonging to &#34;
               &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(x_col.columns.get_level_values(0)[0])+&#34;&#34;)
        raise Exception(msg)
    
    try:
        xsubheader = x_col.columns.get_level_values(1)[0]
    except:
        msg = (&#34;Could not find &#39;{}&#39; &#34;.format(x)+&#34;in the speciation &#34;
               &#34;report. Available variables include &#34;
               &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
        raise Exception(msg)
    xunit_type, xunit = self.__get_unit_info(xsubheader)
    
    norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
    cmap = cm.__getattribute__(colormap)
    m = cm.ScalarMappable(norm=norm, cmap=cmap)
    
    for i, yi in enumerate(y):
        y_col = self.lookup(yi)
        
        try:
            subheader = y_col.columns.get_level_values(1)[0]
        except:
            msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                   &#34;report. Available variables include &#34;
                  &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0))))+&#34;&#34;)
            raise Exception(msg)
        unit_type, unit = self.__get_unit_info(subheader)
        
        try:
            y_plot = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
        except:
            msg = (&#34;One or more the values belonging to &#34;
                   &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0])+&#34;&#34;)
            raise Exception(msg)
            
        if i == 0:
            subheader_previous = subheader
            unit_previous = unit
        if unit != unit_previous and i != 0:
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
        elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
        elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
            
        yi_previous = copy.deepcopy(yi)
        unit_previous = copy.deepcopy(unit)
        subheader_previous = copy.deepcopy(subheader)
        
        if len(y) != 1:
            color = m.to_rgba(i)
        else:
            color = &#34;black&#34;
        
        plt.scatter(x_plot, y_plot, marker=&#39;o&#39;, color=color)

    if len(y) &gt; 1:
        ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
        if show_legend:
            ax.legend(labels=y, loc=legend_loc)
    else:
        if &#39;pH&#39; in y:
            ylabel = &#39;pH&#39;
        elif &#39;Temperature&#39; in y:
            ylabel = &#39;Temperature [°C]&#39;
        else:
            ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
    
    if x == &#39;pH&#39;:
        xlabel = &#39;pH&#39;
    elif x == &#39;Temperature&#39;:
        xlabel = &#39;Temperature [°C]&#39;
    else:
        xlabel = &#34;{} {} [{}]&#34;.format(x, xunit_type, xunit)
    
    if xrange != None:
        plt.xlim(xrange[0], xrange[1])
    
    if yrange != None:
        plt.ylim(yrange[0], yrange[1])

    ax.set_facecolor(bg_color)
    plt.ylabel(ylabel)
    plt.xlabel(xlabel)

    if save_as != None:
        if &#34;.png&#34; not in save_as[:-4]:
            save_as = save_as+&#34;.png&#34;
        
        plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
        print(&#34;Saved figure as {}&#34;.format(save_as))
    
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AqEquil" href="index.html">AqEquil</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="AqEquil.AqSpeciation.convert_to_RVector" href="#AqEquil.AqSpeciation.convert_to_RVector">convert_to_RVector</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.load" href="#AqEquil.AqSpeciation.load">load</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.unique" href="#AqEquil.AqSpeciation.unique">unique</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AqEquil.AqSpeciation.AqEquil" href="#AqEquil.AqSpeciation.AqEquil">AqEquil</a></code></h4>
<ul class="">
<li><code><a title="AqEquil.AqSpeciation.AqEquil.create_data0" href="#AqEquil.AqSpeciation.AqEquil.create_data0">create_data0</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.AqEquil.runeq3" href="#AqEquil.AqSpeciation.AqEquil.runeq3">runeq3</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.AqEquil.runeqpt" href="#AqEquil.AqSpeciation.AqEquil.runeqpt">runeqpt</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.AqEquil.speciate" href="#AqEquil.AqSpeciation.AqEquil.speciate">speciate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AqEquil.AqSpeciation.Speciation" href="#AqEquil.AqSpeciation.Speciation">Speciation</a></code></h4>
<ul class="">
<li><code><a title="AqEquil.AqSpeciation.Speciation.barplot" href="#AqEquil.AqSpeciation.Speciation.barplot">barplot</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.lookup" href="#AqEquil.AqSpeciation.Speciation.lookup">lookup</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.plot_mass_contribution" href="#AqEquil.AqSpeciation.Speciation.plot_mass_contribution">plot_mass_contribution</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.plot_mineral_saturation" href="#AqEquil.AqSpeciation.Speciation.plot_mineral_saturation">plot_mineral_saturation</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.save" href="#AqEquil.AqSpeciation.Speciation.save">save</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.scatterplot" href="#AqEquil.AqSpeciation.Speciation.scatterplot">scatterplot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>