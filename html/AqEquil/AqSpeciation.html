<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>AqEquil.AqSpeciation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AqEquil.AqSpeciation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import re
import sys
import shutil
import copy
import collections
import pickle

import warnings
from subprocess import Popen
import pkg_resources
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.cm as cm

with warnings.catch_warnings():
    warnings.simplefilter(&#34;ignore&#34;)
    import rpy2.robjects as ro
    from rpy2.robjects import pandas2ri
    pandas2ri.activate()

def load(filename, messages=True):
    &#34;&#34;&#34;
    Load a speciation file.

    Parameters
    ----------
    filename : str
        Name of the speciation file.

    Returns
    ----------
    An object of class `Speciation`.
    &#34;&#34;&#34;

    with open(filename, &#39;rb&#39;) as handle:
        speciation = pickle.load(handle)
        if messages:
            print(&#34;Loaded &#39;{}&#39;&#34;.format(filename))
        return speciation


def convert_to_RVector(value, force_Rvec=True):
    
    &#34;&#34;&#34;
    Convert a value or list into an R vector of the appropriate type.
    
    Parameters
    ----------
    value : numeric or str, or list of numeric or str
        Value to be converted.
    
    force_Rvec : bool, default True
        If `value` is not a list, force conversion into a R vector?
        False will return an int, float, or str if value is non-list.
        True will always return an R vector.
    
    Returns
    -------
    int, float, str, or an rpy2 R vector
        A value or R vector of an appropriate data type.
    &#34;&#34;&#34;

    if not isinstance(value, list) and not force_Rvec:
        return value
    elif not isinstance(value, list) and force_Rvec:
        value = [value]
    else:
        pass

    if all(isinstance(x, bool) for x in value):
        return ro.BoolVector(value)
    elif all(isinstance(x, int) for x in value):
        return ro.IntVector(value)
    elif all(isinstance(x, float) or isinstance(x, int) for x in value):
        return ro.FloatVector(value)
    else:
        return ro.StrVector(value)


class Speciation(object):
    
    &#34;&#34;&#34;
    Stores the output of a speciation calculation.
    
    Attributes
    ----------
    input : pd.Dataframe
        Pandas dataframe containing user-supplied sample chemistry data.
    
    mass_contribution : pd.Dataframe
        Pandas dataframe containing basis species contributions to mass balance
        of aqueous species.
    
    batch_3o : rpy2 ListVector
        An rpy2 ListVector (R object) containing speciation results, in case
        analysis in R is preferred.
    
    report : pd.Dataframe
        Pandas dataframe reporting major results of speciation calculation in
        across all samples.
    
    report_divs : rpy2 ListVector
        An rpy2 ListVector of column names within the different sections of the
        speciation report.
    
    sample_data : dict
        Dictionary with sample names as keys and speciation results as values.
    
    &#34;&#34;&#34;
    
    def __init__(self, args):
        for k in args:
            setattr(self, k, args[k])

    def __getitem__(self, item):
         return getattr(self, item)
    
    @staticmethod
    def __unique(seq):
        &#34;&#34;&#34;
        Provide a sequence, get a list of non-repeating elements in the same order.
        &#34;&#34;&#34;
        seen = set()
        seen_add = seen.add
        return [x for x in seq if not (x in seen or seen_add(x))]

    
    def save(self, filename, messages=True):
        &#34;&#34;&#34;
        Save the speciation as a &#39;.speciation&#39; file to your current working
        directory. This file can be loaded with `AqEquil.load(filename)`.
        
        Parameters
        ----------
        filename : str
            The desired name of the file.
            
        messages : str
            Print a message confirming the save?
        &#34;&#34;&#34;
        
        if filename[-11:] != &#39;.speciation&#39;:
            filename = filename + &#39;.speciation&#39;
        
        with open(filename, &#39;wb&#39;) as handle:
            pickle.dump(self, handle, protocol=pickle.HIGHEST_PROTOCOL)
            if messages:
                print(&#34;Saved as &#39;{}&#39;&#34;.format(filename))
    
    
    @staticmethod
    def __get_unit_info(subheader):
        
        unit_name_dict = {
            &#34;pH&#34; : (&#34;&#34;, &#34;pH&#34;),
            &#34;ppm&#34; : (&#34;&#34;, &#34;ppm&#34;),
            &#34;ppb&#34; : (&#34;&#34;, &#34;ppb&#34;),
            &#34;mg/L&#34; : (&#34;&#34;, &#34;mg/L&#34;),
            &#34;degC&#34; : (&#34;temperature&#34;, &#34;°C&#34;),
            &#34;log_molality&#34; : (&#34;log molality&#34;, &#34;log(mol/kg)&#34;),
            &#34;Molality&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;molality&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;molal&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;log_activity&#34; : (&#34;log activity&#34;, &#34;&#34;),
            &#34;Log activity&#34; : (&#34;log activity&#34;, &#34;&#34;),
            &#34;mg/kg.sol&#34; : (&#34;&#34;, &#34;mg solute per kg solution&#34;),
            &#34;Alk., eq/kg.H2O&#34; : (&#34;alkalinity&#34;, &#34;eq/kg&#34;),
            &#34;Alk., eq/L&#34; : (&#34;alkalinity&#34;, &#34;eq/L&#34;),
            &#34;Alk., eq/kg.sol&#34; : (&#34;alkalinity&#34;, &#34;eq/kg solution&#34;),
            &#34;Alk., mg/L CaCO3&#34; : (&#34;alkalinity&#34;, &#34;mg/L CaCO3&#34;),
            &#34;Alk., mg/L HCO3-&#34; : (&#34;alkalinity&#34;, &#34;mg/L HCO3-&#34;),
            &#34;pX&#34; : (&#34;-(log activity)&#34;, &#34;-log(mol/kg)&#34;),
            &#34;activity&#34; : (&#34;activity&#34;, &#34;&#34;),
            &#34;log_gamma&#34; : (&#34;log gamma&#34;, &#34;log(kg/mol)&#34;),
            &#34;gamma&#34; : (&#34;gamma&#34;, &#34;kg/mol&#34;),
            &#34;affinity_kcal&#34; : (&#34;affinity&#34;, &#34;kcal/mol&#34;),
            &#34;%&#34; : (&#34;&#34;, &#34;%&#34;),
            &#34;Eh_volts&#34; : (&#34;Eh&#34;, &#34;volts&#34;),
            &#34;eq/kg.H2O&#34; : (&#34;charge&#34;, &#34;eq/kg&#34;),
            &#34;logfO2&#34; : (&#34;&#34;, &#34;&#34;),
            &#34;cal/kg.H2O&#34; : (&#34;energy supply&#34;, &#34;cal/kg H2O&#34;),
            &#34;Log ion-H+ activity ratio&#34; : (&#34;Log ion-H+ activity ratio&#34;, &#34;&#34;),
            &#34;log_fugacity&#34; : (&#34;log fugacity&#34;, &#34;log(bar)&#34;),
            &#34;fugacity&#34; : (&#34;fugacity&#34;, &#34;bar&#34;),
        }
        
        out = unit_name_dict.get(subheader)
        
        return out[0], out[1]
    
    
    def lookup(self, col=None):
        
        &#34;&#34;&#34;
        Look up desired columns in the speciation report.
        
        Parameters
        ----------
        col : str or list of str
            Leave blank to get a list of section names in the report:
            ```speciation.lookup()```
            Provide the name of a section to look up the names of columns in
            that section of the report:
            ```speciation.lookup(&#34;aq_distribution&#34;)```
            Provide a column name (or a list of column names) to retrieve the
            column from the report:
            ```speciation.lookup([&#34;Temperature&#34;, &#34;O2&#34;])```
            
        Returns
        ----------
        Pandas dataframe or list of str
            If a column name (or list of column names) is provided, returns the
            speciation report with only the desired column(s). Otherwise returns
            a list of section names (if no arguments are provided), or a list of
            columns in a section (if a section name is provided).
        &#34;&#34;&#34;
        
        if col==None and self.report_divs.named:
            return list(self.report_divs.names)
        
        if self.report_divs.named:
            if col in list(self.report_divs.names):
                return list(self.report_divs.rx2(col))
        
        if isinstance(col, str):
            col = [col]
        
        return self.report.iloc[:, self.report.columns.get_level_values(0).isin(set(col))]
    
    def __convert_aq_units_to_log_friendly(self, species, rows):

        col_data = self.lookup(species)
        
        col_data = col_data.loc[rows]
        
        if col_data.columns.get_level_values(1) == &#39;log_activity&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;activity&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_molality&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;molality&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_gamma&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;gamma&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_fugacity&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;fugacity&#39;
        else:
            y = [float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = col_data.columns.get_level_values(1)[0]
        return y, out_unit
    
    
    def plot_mineral_saturation(self, sample_name, mineral_sat_type=&#34;affinity&#34;,
                                yrange=None,
                                colors=[&#34;blue&#34;, &#34;orange&#34;], bg_color=&#34;white&#34;,
                                save_as=None):
        &#34;&#34;&#34;
        Vizualize mineral saturation states in a sample as a bar plot.
        
        Parameters
        ----------
        sample_name : str
            Name of the sample to plot.
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Metric for mineral saturation state to plot. Can be &#34;affinity&#34; or
            &#34;logQoverK&#34;.
            
        yrange : list of numeric, optional
            Sets the lower and upper limits of the y axis.
        
        colors : list of two str, default [&#34;blue&#34;, &#34;orange&#34;]
            Sets the color of the bars representing supersaturated
            and undersaturated states, respectively.
        
        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        if sample_name not in self.report.index:
            msg = (&#34;Could not find &#39;{}&#39;&#34;.format(sample_name)+&#34; among sample &#34;
                   &#34;names in the speciation report. Sample names include &#34;
                   &#34;{}&#34;.format(list(self.report.index)))
            raise Exception(msg)
        

        
        if isinstance(self.sample_data[sample_name].get(&#39;mineral_sat&#39;, None), pd.DataFrame):
            mineral_data = self.sample_data[sample_name][&#39;mineral_sat&#39;][mineral_sat_type].astype(float).sort_values(ascending=False)
            x = mineral_data.index
        else:
            msg = (&#34;This sample does not have mineral saturation state data.&#34;
                   &#34;To generate this data, ensure get_mineral_sat=True when &#34;
                   &#34;running speciate(), or ensure this sample has &#34;
                   &#34;mineral-forming basis species.&#34;)
            raise Exception(msg)
            
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        plt.xticks(rotation = 45, ha=&#39;right&#39;)
        
        pos_sat = [m if m &gt;= 0 else float(&#34;nan&#34;) for m in mineral_data] # possibly: special list for m==0
        neg_sat = [m if m &lt; 0 else float(&#34;nan&#34;) for m in mineral_data]
        
        barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
        for i, y_plot in enumerate([pos_sat, neg_sat]):
            
            if i == 0:
                color = colors[0]
            else:
                color = colors[1]
                
            bars = ax.bar(x, y_plot, tick_label=x, color=color)
            
            barlist.append(bars)
            
            if mineral_sat_type == &#34;affinity&#34;:
                ylabel = &#39;affinity, kcal/mol&#39;
            if mineral_sat_type == &#34;logQoverK&#34;:
                ylabel = &#39;logQ/K&#39;
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])
        
        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    

    def barplot(self, y, yrange=None, convert_log=True, show_trace=True,
                show_legend=True, show_missing=True, legend_loc=&#34;best&#34;,
                colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
        
        &#34;&#34;&#34;
        Show a bar plot to vizualize one or more variables across all samples.
        
        Parameters
        ----------
        y : str or list of str
            Name (or list of names) of the variables to plot. Valid variables
            are columns in the speciation report.
       
        yrange : list of numeric, optional
            Sets the lower and upper limits of the y axis.
            
        convert_log : bool, default True
            Convert units &#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, and
            &#34;log_fugacity&#34; to &#34;activity&#34;, &#34;molality&#34;, &#34;gamma&#34;, and &#34;fugacity&#34;,
            respectively?
        
        show_trace : bool, default True
            Show asterisks for columns with numerical values but are too short
            to see clearly?
            
        show_legend : bool, default True
            Show a legend if there is more than one variable?
        
        show_missing : bool, default True
            Show samples that do not have bars?
        
        legend_loc : str or pair of float, default &#34;best&#34;
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        colormap : str, default &#34;viridis&#34;
            Name of the Matplotlib colormap to color the barplot. See
            https://matplotlib.org/stable/tutorials/colors/colormaps.html

        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        plt.xticks(rotation = 45, ha=&#39;right&#39;)

        if not isinstance(y, list):
            y = [y]
        
        y_cols = self.lookup(y)
        
        if not show_missing:
            y_cols = y_cols.dropna(how=&#39;all&#39;)
        
        x = y_cols.index # names of samples
        
        norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
        cmap = cm.__getattribute__(colormap)
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        X = np.arange(len(x))
        
        barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
        for i, yi in enumerate(y):
            y_col = y_cols.iloc[:, y_cols.columns.get_level_values(0)==yi]
            
            try:
                subheader = y_col.columns.get_level_values(1)[0]
            except:
                msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                       &#34;report. Available variables include &#34;
                      &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
                raise Exception(msg)
            try:
                unit_type, unit = self.__get_unit_info(subheader)
            except:
                unit_type = &#34;&#34;
                unit = &#34;&#34;
            
            try:
                y_vals = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
            except:
                msg = (&#34;One or more the values belonging to &#34;
                       &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0]))
                raise Exception(msg)
            
            if convert_log and [abs(y0) for y0 in y_vals] != y_vals: # convert to bar-friendly units if possible
                if subheader in [&#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, &#34;log_fugacity&#34;]:
                    y_plot, out_unit = self.__convert_aq_units_to_log_friendly(yi, rows=x)
                    unit_type, unit = self.__get_unit_info(out_unit)
                else:
                    y_plot = y_vals
            else:
                y_plot = y_vals
            
            if i == 0:
                subheader_previous = subheader
                unit_previous = unit
            if unit != unit_previous and i != 0:
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
                
            yi_previous = copy.deepcopy(yi)
            unit_previous = copy.deepcopy(unit)
            subheader_previous = copy.deepcopy(subheader)
            
            if len(y) != 1:
                color = m.to_rgba(i)
            else:
                color = &#34;black&#34;
            
            bars = ax.bar(X+i*(1/(len(y)+1)), y_plot, tick_label=x, color=color, width=1/(len(y)+1))
            
            barlist.append(bars)

        max_bar_height = 0
        for bars in barlist:
            for p in bars.patches:
                max_bar_height = np.nanmax([max_bar_height, abs(p.get_height())])
                
        for i,bars in enumerate(barlist):
            for p in bars.patches:
                if show_trace and abs(p.get_height())/max_bar_height &lt;= 0.009:
                    if len(y) != 1:
                        color = m.to_rgba(i)
                    else:
                        color = &#34;black&#34;
                
                    plt.annotate(&#34;*&#34;,
                                  (p.get_x() + p.get_width() / 2., p.get_height()),
                                  ha = &#39;center&#39;, va = &#39;center&#39;, xytext = (0, 10),
                                  color=color,
                                  weight=&#39;bold&#39;,
                                  fontsize=18,
                                  textcoords = &#39;offset points&#39;)
        
        if len(y) &gt; 1:
            if unit != &#34;&#34;:
                ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
            else:
                ylabel = unit_type
            if show_legend:
                ax.legend(labels=y, loc=legend_loc)
        else:
            if &#39;pH&#39; in y:
                ylabel = &#39;pH&#39;
            elif &#39;Temperature&#39; in y:
                ylabel = &#39;Temperature [°C]&#39;
            else:
                if unit != &#34;&#34;:
                    ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
                else:
                    ylabel = &#34;{} {}&#34;.format(y[0], unit_type)
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])
        
        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    
    
    def scatterplot(self, x=&#34;pH&#34;, y=&#34;Temperature&#34;, xrange=None, yrange=None,
                show_legend=True, legend_loc=&#34;best&#34;,
                colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
        
        &#34;&#34;&#34;
        Vizualize two or more sample variables with a scatterplot.
        
        Parameters
        ----------
        x, y : str, default for x is &#34;pH&#34;, default for y is &#34;Temperature&#34;
            Names of the variables to plot against each other. Valid variables
            are columns in the speciation report. `y` can be a list of
            of variable names for a multi-series scatterplot.
       
        xrange, yrange : list of numeric, optional
            Sets the lower and upper limits of the x and y axis.
            
        show_legend : bool, default True
            Show a legend if there is more than one variable?
        
        legend_loc : str or pair of float, default &#34;best&#34;
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        colormap : str, default &#34;viridis&#34;
            Name of the Matplotlib colormap to color the scatterpoints. See
            https://matplotlib.org/stable/tutorials/colors/colormaps.html

        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;

        if not isinstance(y, list):
            y = [y]
        
        if not isinstance(x, str):
            raise Exception(&#34;x must be a string.&#34;)
        
        x_col = self.lookup(x)
        
        try:
            xsubheader = x_col.columns.get_level_values(1)[0]
        except:
            msg = (&#34;Could not find &#39;{}&#39; &#34;.format(x)+&#34;in the speciation &#34;
                   &#34;report. Available variables include &#34;
                   &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
            raise Exception(msg)
            
        try:
            x_plot = [float(x0[0]) if x0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for x0 in x_col.values.tolist()]
        except:
            msg = (&#34;One or more the values belonging to &#34;
                   &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(x_col.columns.get_level_values(0)[0]))
            raise Exception(msg)
        
        try:
            xunit_type, xunit = self.__get_unit_info(xsubheader)
        except:
            xunit_type = &#34;&#34;
            xunit = &#34;&#34;
        
        norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
        cmap = cm.__getattribute__(colormap)
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        
        for i, yi in enumerate(y):
            y_col = self.lookup(yi)
            
            try:
                subheader = y_col.columns.get_level_values(1)[0]
            except:
                msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                       &#34;report. Available variables include &#34;
                      &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
                raise Exception(msg)
            try:
                unit_type, unit = self.__get_unit_info(subheader)
            except:
                unit_type = &#34;&#34;
                unit = &#34;&#34;
            
            try:
                y_plot = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
            except:
                msg = (&#34;One or more the values belonging to &#34;
                       &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0]))
                raise Exception(msg)
                
            if i == 0:
                subheader_previous = subheader
                unit_previous = unit
            if unit != unit_previous and i != 0:
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
                
            yi_previous = copy.deepcopy(yi)
            unit_previous = copy.deepcopy(unit)
            subheader_previous = copy.deepcopy(subheader)
            
            if len(y) != 1:
                color = m.to_rgba(i)
            else:
                color = &#34;black&#34;
            
            plt.scatter(x_plot, y_plot, marker=&#39;o&#39;, color=color)

        if len(y) &gt; 1:
            if unit != &#34;&#34;:
                ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
            else:
                ylabel = unit_type
            if show_legend:
                ax.legend(labels=y, loc=legend_loc)
        else:
            if &#39;pH&#39; in y:
                ylabel = &#39;pH&#39;
            elif &#39;Temperature&#39; in y:
                ylabel = &#39;Temperature [°C]&#39;
            else:
                if unit != &#34;&#34;:
                    ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
                else:
                    ylabel = &#34;{} {}&#34;.format(y[0], unit_type)
        
        if x == &#39;pH&#39;:
            xlabel = &#39;pH&#39;
        elif x == &#39;Temperature&#39;:
            xlabel = &#39;Temperature [°C]&#39;
        else:
            if xunit != &#34;&#34;:
                xlabel = &#34;{} {} [{}]&#34;.format(x, xunit_type, xunit)
            else:
                xlabel = &#34;{} {}&#34;.format(x, xunit_type)
        
        if xrange != None:
            plt.xlim(xrange[0], xrange[1])
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])

        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)
        plt.xlabel(xlabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    
    
    def plot_mass_contribution(self, basis, sort_by=None, ascending=True,
                                     sort_y_by=None, width=0.9,
                                     legend_loc=(1.02, 0.5),
                                     save_as=None):
        
        &#34;&#34;&#34;
        Plot basis species contributions to mass balance of aqueous species
        across all samples.
        
        Parameters
        ----------
        basis : str
            Name of the basis species.
            
        sort_by : str, optional
            Name of the variable used to sort samples. Variable names must be
            taken from the speciation report column names. No sorting is done by
            default.
        
        ascending : bool, default True
            Should sample sorting be in ascending order? Descending if False.
            Ignored unless `sort_by` is defined.
        
        sort_y_by : list of str, optional
            List of species names in the order that they should be stacked, from
            the bottom of the plot to the top.
        
        width : float, default 0.9
            Width of bars. No space between bars if width=1.0.
        
        legend_loc : str or pair of float, default (1.02, 0.5)
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        try:
            self.mass_contribution
        except:
            msg = (&#34;Results for basis species contributions to aqueous mass &#34;
                   &#34;balance could not be found. Ensure that &#34;
                   &#34;get_mass_contribution = True when running speciate().&#34;)
            raise Exception(msg)
            
        if basis not in set(self.mass_contribution[&#39;basis&#39;]):
            msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
                   &#34;among available basis species: &#34;
                   &#34;{}&#34;.format(str(list(set(self.mass_contribution[&#39;basis&#39;])))))
            raise Exception(msg)
            
        df_sp = copy.deepcopy(self.mass_contribution.loc[self.mass_contribution[&#39;basis&#39;] == basis])
        
        if sort_by != None:
            if sort_by in self.report.columns.get_level_values(0):
                sort_col = self.lookup(sort_by)
                sort_by_unit = sort_col.columns.get_level_values(1)[0]
                sort_index = sort_col.sort_values([(sort_by, sort_by_unit)], ascending=ascending).index
                
                df_list = []
                for i in sort_index:
                    df_list.append(df_sp[df_sp[&#39;sample&#39;]==i])

                df_sp = pd.concat(df_list)
                
            else:
                msg = (&#34;Could not find {}&#34;.format(sort_by)+&#34; in the &#34;
                       &#34;speciation report. Available variables include &#34;
                       &#34;{}&#34;.format(list(self.report.columns.get_level_values(0))))
                raise Exception(msg)
        
        df_sp[&#39;percent&#39;] = df_sp[&#39;percent&#39;].astype(float)
        
        unique_species = self.__unique(df_sp[&#34;species&#34;])
        
        if &#34;Other&#34; in unique_species:

            unique_species.append(unique_species.pop(unique_species.index(&#34;Other&#34;)))
        
        labels = self.__unique(df_sp[&#34;sample&#34;])

        bottom = np.array([0]*len(labels))

        if sort_y_by != None:
            if isinstance(sort_y_by, list):
                if len(unique_species) == len(sort_y_by):
                    if len([s for s in unique_species if s in sort_y_by]) == len(unique_species) and len([s for s in sort_y_by if s in unique_species]) == len(unique_species):
                        unique_species = sort_y_by
                    else:
                        valid_needed = [s for s in unique_species if s not in sort_y_by]
                        invalid = [s for s in sort_y_by if s not in unique_species]
                        msg = (&#34;sort_y_by is missing the following species: &#34;
                               &#34;{}&#34;.format(valid_needed)+&#34; and was provided &#34;
                               &#34;these invalid species: {}&#34;.format(invalid))
                        raise Exception(msg)
                        
                elif len(sort_y_by) &lt; len(unique_species):
                    msg = (&#34;sort_y_by must have of all of the &#34;
                           &#34;following species: {}&#34;.format(unique_species)+&#34;. &#34;
                           &#34;You are missing {}&#34;.format([s for s in unique_species if s not in sort_y_by]))
                    raise Exception(msg)
                else:
                    msg = (&#34;sort_y_by can only have the &#34;
                           &#34;following species: {}&#34;.format(unique_species)+&#34;.&#34;)
                    raise Exception(msg)
            else:
                raise Exception(&#34;sort_y_by must be a list of species names.&#34;)
                
        fig, ax = plt.subplots()
        
        for i,sp in enumerate(unique_species):
            percents = []
            for sample in labels:
                df_sample = df_sp[df_sp[&#34;sample&#34;]==sample]
                try:
                    percent = df_sample[df_sample[&#34;species&#34;]==sp][&#34;percent&#34;].iloc[0]
                    percents.append(percent)
                except:
                    percents.append(0.0)
            ax.bar(labels, percents, width, bottom=bottom, label=sp)
            bottom = bottom + np.array(percents)

        ax.set_ylabel(&#39;mole %&#39;)
        ax.set_title(&#39;Species accounting for mass balance of &#39;+basis)
        plt.xticks(rotation = 45, ha=&#39;right&#39;)
        ax.legend(loc=legend_loc)
        
        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
            
        plt.show()


class AqEquil():

    &#34;&#34;&#34;
    Class containing functions to speciate aqueous water chemistry data using
    existing or custom thermodynamic datasets.
    
    Parameters
    ----------
    eq36da : str, defaults to path given by the environment variable EQ36DA
        Path to directory where data1 files are stored. 
        
    eq36co : str, defaults to path given by the environment variable EQ36CO
        Path to directory where EQ3 executables are stored.
    
    Attributes
    ----------
    eq36da : str
        Path to directory where data1 files are stored.
        
    eq36co : str
        Path to directory where EQ3 executables are stored.
        
    df_input_processed : pd.Dataframe
        Pandas dataframe containing user-supplied sample chemistry data that has
        been processed by `speciate`.
        
    out_dict : pd.Dataframe
        Pandas dataframe reporting results of last speciation calculation
        performed by `speciate`.
    
    verbose : int, 0, 1, or 2, default 1
        Level determining how many messages are returned during a
        calculation. 2 for all messages, 1 for errors or warnings only,
        0 for silent.
        
    &#34;&#34;&#34;

    def __init__(self,
                 eq36da=os.environ.get(&#39;EQ36DA&#39;),
                 eq36co=os.environ.get(&#39;EQ36CO&#39;)):

        self.eq36da = eq36da
        self.eq36co = eq36co
        self.df_input_processed = None
        self.out_dict = None
        self.verbose = 1

        os.environ[&#39;EQ36DA&#39;] = self.eq36da  # set eq3 db directory
        os.environ[&#39;EQ36CO&#39;] = self.eq36co  # set eq3 .exe directory
    
    
    @staticmethod
    def __file_exists(filename, ext=&#39;.csv&#39;):
        &#34;&#34;&#34;
        Check that a file exists and that it has the correct extension.
        Returns True if so, raises exception if not.
        &#34;&#34;&#34;
        
        ext_dict = {
            &#34;.csv&#34; : &#34;comma separated values (.csv)&#34;,
            &#34;.txt&#34; : &#34;standard text (.txt)&#34;,
            &#34;.rds&#34; : &#34;R Data (.rds)&#34;,
        }
        
        if ext in filename[-4:]:
            if os.path.exists(filename) and os.path.isfile(filename):
                return True
            else:
                err = &#34;Cannot locate input file {}.&#34;.format(filename)
                raise Exception(err)
        else:
            err = (&#34;Input file {}&#34;.format(filename) + &#34; &#34;
                &#34;must be in {} format.&#34;.format(ext_dict[ext]))
            raise Exception(err)
        
        return False
    
    
    def _check_database_file(self, filename):
        
        &#34;&#34;&#34;
        Check for problems in the thermodynamic database CSV.
        &#34;&#34;&#34;
        
        # is the file a csv?
        self.__file_exists(filename)
        
        thermo_df = pd.read_csv(filename)
        
        # does this file have the proper headers?
        required_headers = [&#34;name&#34;, &#34;abbrv&#34;, &#34;formula&#34;, &#34;state&#34;,
                            &#34;ref1&#34;, &#34;ref2&#34;, &#34;date&#34;, &#34;E_units&#34;,
                            &#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;Cp&#34;, &#34;V&#34;,
                            &#34;a1.a&#34;, &#34;a2.b&#34;, &#34;a3.c&#34;, &#34;a4.d&#34;, &#34;c1.e&#34;, &#34;c2.f&#34;,
                            &#34;omega.lambda&#34;, &#34;z.T&#34;,
                            &#34;azero&#34;, &#34;neutral_ion_type&#34;,
                            &#34;dissrxn&#34;, &#34;tag&#34;, &#34;formula_ox&#34;]
        
        missing_headers = []
        for header in required_headers:
            if header not in thermo_df.columns:
                missing_headers.append(header)
        if len(missing_headers) &gt; 0:
            msg = (&#34;The thermodynamic database file &#39;{}&#39;&#34;.format(filename)+&#34; &#34;
                   &#34;is missing one or more required columns: &#34;
                   &#34;{}&#34;.format(&#34;, &#34;.join(missing_headers))+&#34;. &#34;
                   &#34;Are these headers spelled correctly in the file?&#34;)
            raise Exception(msg)
        
        # does Cl-, O2(g), and O2 exist in the file?
        required_species = [&#34;Cl-&#34;, &#34;O2&#34;, &#34;O2(g)&#34;]
        missing_species = []
        for species in required_species:
            if species not in list(thermo_df[&#34;name&#34;]):
                missing_species.append(species)
        if len(missing_species) &gt; 0:
            msg = (&#34;The thermodynamic database file &#39;{}&#39;&#34;.format(filename)+&#34; &#34;
                   &#34;is missing required species:&#34;
                   &#34;{}&#34;.format(missing_species)+&#34;. Default thermodynamic values&#34;
                   &#34; will be used.&#34;)
            warnings.warn(msg)
        
        return

    
    def _check_sample_input_file(self, input_filename, exclude, db, custom_db,
                                       charge_balance_on, suppress_missing):
        &#34;&#34;&#34;
        Check for problems in sample input file.
        &#34;&#34;&#34;
        
        # does the input file exist? Is it a CSV?
        if self.__file_exists(input_filename):
            df_in = pd.read_csv(input_filename, header=None) # no headers for now so colname dupes can be checked
        else:
            raise Exception(&#34;_check_sample_input() error!&#34;)
        
        # are there any samples?
        if df_in.shape[0] &lt;= 2:
            err_no_samples = (&#34;The file {}&#34;.format(input_filename) + &#34; &#34;
                &#34;must contain at least three rows: the &#34;
                &#34;first for column names, the second for column subheaders, &#34;
                &#34;followed by one or more rows for sample data.&#34;)
            raise Exception(err_no_samples)
        
        err_list = [] # for appending errors found in the sample input file
        
        # get header list
        col_list = list(df_in.iloc[0, 1:])
        
        # are there blank headers?
        if True in [isinstance(x, float) and x != x for x in col_list]:
            # isinstance(x, float) and x != x is a typesafe way to check for nan
            err_blank_header = (&#34;One or more columns in the sample input &#34;
                &#34;file have blank headers. These might be empty columns. &#34;
                &#34;Only the first column may have a blank header. Remove any &#34;
                &#34;empty columns and/or give each header a name.&#34;)
            raise Exception(err_blank_header)
        
        # are there duplicate headers?
        dupe_cols = list(set([x for x in col_list if col_list.count(x) &gt; 1]))
        if len(dupe_cols) &gt; 0:
            err_dupe_cols = (&#34;Duplicate column names are not allowed. &#34;
                &#34;Duplicate column names were found for:\n&#34;
                &#34;{}&#34;.format(str(dupe_cols)))
            err_list.append(err_dupe_cols)
        
        df_in.columns = df_in.iloc[0] # set column names
        df_in = df_in.drop(df_in.index[0], axis=0) # drop column name row
        df_in_headercheck = copy.deepcopy(df_in.iloc[:,1:]) # drop first column. Deepcopy slice because drop() doesn&#39;t work well with unnamed columns.
        
        # drop excluded headers
        for exc in exclude:
            if exc == df_in.columns[0]: # skip if &#39;sample&#39; column is excluded
                continue
            try:
                df_in_headercheck = df_in_headercheck.drop(exc, axis=1) # drop excluded columns
            except:
                err_bad_exclude = (&#34;Could not exclude the header &#39;{}&#39;&#34;.format(exc)+&#34;. &#34;
                                   &#34;This header could not be found in {}&#34;.format(input_filename)+&#34;&#34;)
                err_list.append(err_bad_exclude)
        
        # get row list
        row_list = list(df_in.iloc[1:, 0])
        
        # are there blank rows?
        if True in [isinstance(x, float) and x != x for x in row_list]:
            # isinstance(x, float) and x != x is a typesafe way to check for nan
            err_blank_row = (&#34;One or more rows in the sample input &#34;
                &#34;file have blank sample names. These might be empty rows. &#34;
                &#34;Remove any empty rows and/or give each sample a name. Sample &#34;
                &#34;names go in the first column.&#34;)
            raise Exception(err_blank_row)
            
        # are there duplicate rows?
        dupe_rows = list(set([x for x in row_list if row_list.count(x) &gt; 1]))
        if len(dupe_rows) &gt; 0:
            err_dupe_rows = (&#34;Duplicate sample names are not allowed. &#34;
                &#34;Duplicate sample names were found for:\n&#34;
                &#34;{}&#34;.format(str(dupe_rows)))
            err_list.append(err_dupe_rows)
        
        # are column names valid entries in the database?
        if custom_db:
            data0_path = &#34;data0.&#34; + db
        else:
            data0_path = self.eq36da + &#34;/data0.&#34; + db
        if os.path.exists(data0_path) and os.path.isfile(data0_path):
            with open(data0_path) as data0:
                data0_lines = data0.readlines()
                start_index = [i+1 for i, s in enumerate(data0_lines) if &#39;*  species name&#39; in s]
                end_index = [i-1 for i, s in enumerate(data0_lines) if &#39;elements&#39; in s]
                db_species = [i.split()[0] for i in data0_lines[start_index[0]:end_index[0]]]
                if charge_balance_on == &#39;pH&#39;:
                    err_charge_balance_on_pH = (&#34;To balance charge on pH, use &#34;
                        &#34;charge_balance_on=&#39;H+&#39;&#34;)
                    err_list.append(err_charge_balance_on_pH)
                elif charge_balance_on in [&#39;Temperature&#39;, &#39;logfO2&#39;]:
                    err_charge_balance_invalid_type = (&#34;Cannot balance charge &#34;
                        &#34;on {}.&#34;.format(charge_balance_on))
                    err_list.append(err_charge_balance_invalid_type)
                elif charge_balance_on != &#34;none&#34; and charge_balance_on not in list(set(df_in_headercheck.columns)):
                    err_charge_balance_invalid_sp = (&#34;The species chosen for charge balance&#34;
                        &#34; &#39;{}&#39;&#34;.format(charge_balance_on)+&#34;&#34;
                        &#34; was not found among the headers of the sample input file.&#34;)
                    err_list.append(err_charge_balance_invalid_sp)
                for species in list(set(df_in_headercheck.columns)):
                    if species not in db_species and species not in [&#39;Temperature&#39;, &#39;logfO2&#39;, &#39;pH&#39;]:
                        err_species_not_in_db = (&#34;The species &#39;{}&#39;&#34;.format(species) + &#34; &#34;
                            &#34;was not found in {}&#34;.format(data0_path) + &#34;. &#34;
                            &#34;If the column contains data that should not be &#34;
                            &#34;included in the speciation calculation, add the &#34;
                            &#34;column name to the &#39;exclude&#39; argument. Try &#34;
                            &#34;help(AqEquil.AqEquil.speciate) &#34;
                            &#34;for more information about &#39;exclude&#39;.&#34;)
                        err_list.append(err_species_not_in_db)
                    elif species == &#39;pH&#39;:
                        err_species_pH = (&#34;Please rename the &#39;pH&#39; column in &#34;
                            &#34;the sample input file to &#39;H+&#39; with the subheader &#34;
                            &#34;unit &#39;pH&#39;.&#34;)
                        err_list.append(err_species_pH)
                    
        else:
            err_no_data0 = (&#34;Could not locate {}.&#34;.format(data0_path) + &#34; &#34;
                &#34;Unable to determine if column headers included in &#34;
                &#34;{} &#34;.format(input_filename) + &#34;match entries for species &#34;
                &#34;in the requested thermodynamic database &#39;{}&#39;.&#34;.format(db))
            err_list.append(err_no_data0)
        
        
        # are subheader units valid?
        subheaders = df_in_headercheck.iloc[0,]
        valid_subheaders = [&#34;degC&#34;, &#34;ppm&#34;, &#34;ppb&#34;, &#34;Suppressed&#34;, &#34;Molality&#34;,
                            &#34;Molarity&#34;, &#34;mg/L&#34;, &#34;mg/kg.sol&#34;, &#34;Alk., eq/kg.H2O&#34;,
                            &#34;Alk., eq/L&#34;, &#34;Alk., eq/kg.sol&#34;, &#34;Alk., mg/L CaCO3&#34;,
                            &#34;Alk., mg/L HCO3-&#34;, &#34;Log activity&#34;, &#34;Log act combo&#34;,
                            &#34;Log mean act&#34;, &#34;pX&#34;, &#34;pH&#34;, &#34;pHCl&#34;, &#34;pmH&#34;, &#34;pmX&#34;,
                            &#34;Hetero. equil.&#34;, &#34;Homo. equil.&#34;, &#34;Make non-basis&#34;,
                            &#34;logfO2&#34;, &#34;Mineral&#34;]
        for i, subheader in enumerate(subheaders):
            if subheader not in valid_subheaders:
                err_valid_sub = (&#34;The subheader &#39;{}&#39;&#34;.format(subheader) + &#34; &#34;
                    &#34;for the column &#39;{}&#39;&#34;.format(df_in_headercheck.columns[i]) + &#34; &#34;
                    &#34;is not recognized. Valid subheaders are {}&#34;.format(str(valid_subheaders)) + &#34;. &#34;
                    &#34;If the column {}&#34;.format(df_in_headercheck.columns[i]) + &#34; &#34;
                    &#34;contains data that is not meant for the &#34;
                    &#34;speciation calculation, add the column name &#34;
                    &#34;to the &#39;exclude&#39; argument. Try help(AqEquil.AqEquil.speciate) &#34;
                    &#34;for more information about &#39;exclude&#39;.&#34;)
                err_list.append(err_valid_sub)
            
        # is a &#39;Temperature&#39; column present?
        if &#34;Temperature&#34; not in df_in_headercheck.columns and &#34;Temperature&#34; not in exclude:
            err_temp = (&#34;The column &#39;Temperature&#39; was not found in the input file. &#34;
                &#34;Please include a column with &#39;Temperature&#39; in the first row, &#34;
                &#34;&#39;degC&#39; in the second row, and a temperature value for each &#34;
                &#34;sample in degrees Celsius.&#34;)
            err_list.append(err_temp)
        
        # raise exception that outlines all errors found
        if len(err_list) &gt; 0:
            errs = &#34;\n\n*&#34;.join(err_list)
            errs = (&#34;The input file {}&#34;.format(input_filename)+&#34; encountered&#34;
                &#34; errors:\n\n*&#34; + errs)
            raise Exception(errs)
        
        return
        
        
    def __clear_eqpt_extra_output(self):
        
        &#34;&#34;&#34;
        Deletes all EQPT output except data1.
        &#34;&#34;&#34;
        
        if os.path.exists(&#34;eqpt_log.txt&#34;) and os.path.isfile(&#34;eqpt_log.txt&#34;):
            os.remove(&#34;eqpt_log.txt&#34;)
        if os.path.exists(&#34;data1f.txt&#34;) and os.path.isfile(&#34;data1f.txt&#34;):
            os.remove(&#34;data1f.txt&#34;)
        if os.path.exists(&#34;slist.txt&#34;) and os.path.isfile(&#34;slist.txt&#34;):
            os.remove(&#34;slist.txt&#34;)

            
    def runeqpt(self, db, extra_eqpt_output=False):
        
        &#34;&#34;&#34;
        Convert a data0 into a data1 file with EQPT.
        
        Parameters
        ----------
        db : str
            Three letter code of database.
        
        extra_eqpt_output : bool, default False
            Keep additional output files from EQPT? These files include
            eqpt_log.txt, data1f.txt, and slist.txt.
        &#34;&#34;&#34;

        if os.path.exists(&#34;data0.&#34;+db) and os.path.isfile(&#34;data0.&#34;+db):
            pass
        else:
            raise Exception(&#34;Error: could not locate custom database&#34;,
                            &#34;data0.{} in {}.&#34;.format(db, os.getcwd()))

        if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
            os.remove(&#34;data1.&#34;+db)

        self.__clear_eqpt_extra_output()

        os.environ[&#39;EQ36DA&#39;] = os.getcwd()

        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeqpt&#39;, db]

        try:
            self.__run_script_and_wait(args) # run EQPT
        except:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da
            raise Exception(
                &#34;Error: EQPT failed to run on {}.&#34;.format(&#34;data0.&#34;+db))

        if os.path.exists(&#34;data1&#34;) and os.path.isfile(&#34;data1&#34;):
            os.rename(&#34;data1&#34;, &#34;data1.&#34;+db)
        if os.path.exists(&#34;output&#34;) and os.path.isfile(&#34;output&#34;):
            os.rename(&#34;output&#34;, &#34;eqpt_log.txt&#34;)
        if os.path.exists(&#34;data1f&#34;) and os.path.isfile(&#34;data1f&#34;):
            os.rename(&#34;data1f&#34;, &#34;data1f.txt&#34;)
        if os.path.exists(&#34;slist&#34;) and os.path.isfile(&#34;slist&#34;):
            os.rename(&#34;slist&#34;, &#34;slist.txt&#34;)

        if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
            if self.verbose &gt; 0:
                print(&#34;Successfully created a data1.&#34;+db+&#34; from data0.&#34;+db)
        else:
            msg = (&#34;EQPT could not create data1.&#34;+db+&#34; from &#34;
                   &#34;data0.&#34;+db+&#34;. Check eqpt_log.txt for details.&#34;)
            raise Exception(msg)

        if not extra_eqpt_output:
            self.__clear_eqpt_extra_output()

        os.environ[&#39;EQ36DA&#39;] = self.eq36da  # reset default EQ36 db path

        
    def runeq3(self, filename_3i, db,
               samplename=None,
               path_3i=os.getcwd(),
               path_3o=os.getcwd(),
               path_3p=os.getcwd()):
        
        &#34;&#34;&#34;
        Call EQ3 on a .3i input file.
        
        Parameters
        ----------
        filename_3i : str
            Name of 3i input file.
        
        db : str
            Three letter code of database.
        
        path_3i : path str, default current working directory
            Path of .3i input files.
            
        path_3o : path str, default current working directory
            Path of .3o output files.
        
        path_3p : path str, default current working directory
            Path of .3p pickup files.
        &#34;&#34;&#34;

        # get current working dir
        cwd = os.getcwd()
        
        if samplename == None:
            samplename = filename_3i[:-3]
        
        if self.verbose &gt; 0:
            print(&#39;Using &#39; + db + &#39; to speciate &#39; + samplename)
        os.chdir(path_3i)  # step into 3i folder
        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq3&#39;, db, filename_3i]

        self.__run_script_and_wait(args) # run EQ3

        # restore working dir
        os.chdir(cwd)

        filename_3o = filename_3i[:-1] + &#39;o&#39;
        filename_3p = filename_3i[:-1] + &#39;p&#39;

        try:
            # rename output
            os.rename(path_3i + &#39;/output&#39;, path_3i + &#34;/&#34; + filename_3o)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: EQ3 failed to produce output for &#39; + filename_3i)

        try:
            # move output
            shutil.move(path_3i + &#34;/&#34; + filename_3o,
                        path_3o + &#34;/&#34; + filename_3o)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: Could not move&#39;, filename_3o, &#34;to&#34;, path_3o)

        try:
            # rename pickup
            os.rename(path_3i + &#39;/pickup&#39;, path_3i + &#34;/&#34; + filename_3p)
            move_pickup = True
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: EQ3 failed to produce a pickup file for &#39; + filename_3i)
            move_pickup = False
        
        if move_pickup:
            try:
                # move pickup
                shutil.move(path_3i + &#34;/&#34; + filename_3p,
                            path_3p + &#34;/&#34; + filename_3p)
            except:
                if self.verbose &gt; 0:
                    print(&#39;Error: Could not move&#39;, filename_3p, &#34;to&#34;, path_3p)

                    
    def runeq6(self, filename_6i, db,
               samplename=None,
               path_6i=os.getcwd(),
               path_6o=os.getcwd(),
               path_6p=os.getcwd()):
        
        &#34;&#34;&#34;
        Call EQ6 on a .6i input file.
        
        Parameters
        ----------
        filename_6i : str
            Name of 6i input file.
        
        db : str
            Three letter code of database.
        
        path_6i : path str, default current working directory
            Path of .6i input files.
            
        path_6o : path str, default current working directory
            Path of .6o output files.
        
        path_6p : path str, default current working directory
            Path of .6p pickup files.
        &#34;&#34;&#34;

        # get current working dir
        cwd = os.getcwd()
        
        if samplename == None:
            samplename = filename_6i[:-3]
        
        if self.verbose &gt; 0:
            print(&#39;Using &#39; + db + &#39; to speciate &#39; + samplename)
        os.chdir(path_6i)  # step into 6i folder
        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq6&#39;, db, filename_6i]

        self.__run_script_and_wait(args) # run EQ6

        # restore working dir
        os.chdir(cwd)

        filename_6o = filename_6i[:-1] + &#39;o&#39;
        filename_6p = filename_6i[:-1] + &#39;p&#39;

        try:
            # rename output
            os.rename(path_6i + &#39;/output&#39;, path_6i + &#34;/&#34; + filename_6o)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: EQ6 failed to produce output for &#39; + filename_6i)

        try:
            # move output
            shutil.move(path_6i + &#34;/&#34; + filename_6o,
                        path_6o + &#34;/&#34; + filename_6o)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: Could not move&#39;, filename_6o, &#34;to&#34;, path_6o)

        try:
            # rename pickup
            os.rename(path_6i + &#39;/pickup&#39;, path_6i + &#34;/&#34; + filename_6p)
            move_pickup = True
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: EQ6 failed to produce a pickup file for &#39; + filename_6i)
            move_pickup = False
        
        if move_pickup:
            try:
                # move pickup
                shutil.move(path_6i + &#34;/&#34; + filename_6p,
                            path_6p + &#34;/&#34; + filename_6p)
            except:
                if self.verbose &gt; 0:
                    print(&#39;Error: Could not move&#39;, filename_6p, &#34;to&#34;, path_6p)
                    
                    
    def __mk_check_del_directory(self, path):
        
        &#34;&#34;&#34;
        Checks for the dir being created. If it is already present, delete it
        before recreating it.
        &#34;&#34;&#34;
        
        if not os.path.exists(path):
            os.makedirs(path)
        else:
            shutil.rmtree(path)
            os.makedirs(path)

            
    def __read_inputs(self, file_type, location):
        
        &#34;&#34;&#34;
        Finds all files of a filetype in all downstream folders.
        &#34;&#34;&#34;
        
        file_name = []  # file names
        file_list = []  # file names with paths
        for root, dirs, files in os.walk(location):
            for file in files:
                if file.endswith(file_type):
                    if &#34;-checkpoint&#34; not in file:
                        file_name.append(file)
                        file_list.append(os.path.join(root, file))
        return file_name, file_list

    
    def __run_script_and_wait(self, args):
        
        &#34;&#34;&#34;
        Runs shell commands.
        &#34;&#34;&#34;
        
        with open(os.devnull, &#39;w&#39;) as fp:  # devnull supresses written output
            Popen(args, stdout=fp).wait()

            
    def _delete_rxn_folders(self):
        
        &#34;&#34;&#34;
        Deletes folders storing raw EQ3/6 input and output.
        &#34;&#34;&#34;
        
        if os.path.exists(&#39;rxn_3i&#39;) and os.path.isdir(&#39;rxn_3i&#39;):
            shutil.rmtree(&#39;rxn_3i&#39;)
        if os.path.exists(&#39;rxn_3o&#39;) and os.path.isdir(&#39;rxn_3o&#39;):
            shutil.rmtree(&#39;rxn_3o&#39;)
        if os.path.exists(&#39;rxn_3p&#39;) and os.path.isdir(&#39;rxn_3p&#39;):
            shutil.rmtree(&#39;rxn_3p&#39;)
        if os.path.exists(&#39;rxn_6i&#39;) and os.path.isdir(&#39;rxn_6i&#39;):
            shutil.rmtree(&#39;rxn_6i&#39;)
        if os.path.exists(&#39;rxn_6o&#39;) and os.path.isdir(&#39;rxn_6o&#39;):
            shutil.rmtree(&#39;rxn_6o&#39;)
        if os.path.exists(&#39;rxn_6p&#39;) and os.path.isdir(&#39;rxn_6p&#39;):
            shutil.rmtree(&#39;rxn_6p&#39;)
            

    def speciate(self,
                 input_filename,
                 db=&#34;wrm&#34;,
                 redox_flag=&#34;logfO2&#34;,
                 redox_aux=&#34;Fe+3&#34;,
                 default_logfO2=-6,
                 exclude=[],
                 suppress=[],
                 charge_balance_on=&#34;none&#34;,
                 suppress_missing=True,
                 verbose=1,
                 report_filename=None,
                 get_aq_dist=True,
                 aq_dist_type=&#34;log_activity&#34;,
                 get_mass_contribution=True,
                 mass_contribution_other=True,
                 get_mineral_sat=True,
                 mineral_sat_type=&#34;affinity&#34;,
                 get_redox=True,
                 redox_type=&#34;Eh&#34;,
                 get_ion_activity_ratios=True,
                 get_fugacity=True,
                 get_affinity_energy=False,
                 rxn_filename=None,
                 not_limiting=[&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;],
                 get_charge_balance=True,
                 custom_db=False,
                 extra_eqpt_output=False,
                 batch_3o_filename=None,
                 delete_generated_folders=False):
        
        &#34;&#34;&#34;
        Calculate the equilibrium distribution of chemical species in solution.
        Additionally, calculate chemical affinities and energy supplies for
        user-specified reactions.
        
        Parameters
        ----------
        input_filename : str
            User-supplied utf8-encoded comma separated value (csv) file
            containing sample data intended for speciation. The file must
            follow this format:
            
            - the first row is a header row that must contain the names of the
              species to be included in the speciation calculation. There
              cannot be duplicate headers.
            - the second row must contain subheaders for each species in the
              header row. These subheaders must be taken from the following:
              
                    degC
                    ppm
                    ppb
                    Suppressed
                    Molality
                    Molarity
                    mg/L
                    mg/kg.sol
                    Alk., eq/kg.H2O
                    Alk., eq/L
                    Alk., eq/kg.sol
                    Alk., mg/L CaCO3
                    Alk., mg/L HCO3-
                    Log activity
                    Log act combo
                    Log mean act
                    pX
                    pH
                    pHCl
                    pmH
                    pmX
                    Hetero. equil.
                    Homo. equil.
                    Make non-basis
                    
            - &#39;Temperature&#39; must be included as a header, with &#39;degC&#39; as its
              subheader.
            - The first column must contain sample names. There cannot be
              duplicate sample names.
        
        db : three letter str, default &#34;wrm&#34;
            Three letter file extension for the desired thermodynamic database.
            If `custom_db` is False, this database must be named data1.xyz
            (where xyz is your desired three letter extension) and located
            in the EQ3/6 &#39;EQ36DA&#39; path. Otherwise, the database must be named
            data0.xyz and located in your current working directory. Note that
            data1 files are already compiled by EQPT, while data0 files will be
            automatically compiled for you if `custom_db` is True.
        
        redox_flag : str, default &#34;O2(g)&#34;
            Determines which column in the sample input file sets the overall
            redox state of the samples. Options for redox_flag include &#39;O2(g)&#39;,
            &#39;pe&#39;, &#39;Eh&#39;, &#39;logfO2&#39;, and &#39;redox aux&#39;. The code will search your
            sample spreadsheet file (see `filename`) for a column corresponding
            to the option you chose:
            
            * &#39;O2(g)&#39; with a valid subheader for a gas
            * &#39;pe&#39; with subheader pe
            * &#39;Eh&#39; with subheader volts
            * &#39;logfO2&#39; with subheader logfO2
            * &#39;redox aux&#39; will search for a column corresponding to the
              auxilliary basis species selected to form a redox couple with its
              linked strict basis species (see `redox_aux`). For example, the
              redox couple Fe+2/Fe+3 would require a column named Fe+3
            
            If an appropriate header or redox data cannot be found to define
            redox state, `default_logfO2` is used to set sample logfO2.
            
            There is a special case where dissolved oxygen can be used to impose
            sample redox state if `redox_flag` is set to logfO2 and a column named
            logfO2 does not appear in your sample spreadsheet. If there is a
            column corresponding to dissolved oxygen measurements, logfO2 is
            calculated from the equilibrium reaction O2(aq) = O2(g) at the
            temperature and pressure of the sample using the revised Helgeson-
            Kirkham-Flowers (HKF) equation of state (JC Tanger IV and HC
            Helgeson, Am. J. Sci., 1988, 288, 19).
        
        redox_aux : default &#34;Fe+3&#34;, optional
            Ignored unless `redox_flag` equals 1. Name of the auxilliary species
            whose reaction links it to a basis species (or another auxilliary
            species) such that they form a redox couple that controls sample
            fO2. For instance, Fe+3 is linked to Fe+2 in many supporting data
            files, so selecting `redox_flag` = 1 and `redox_aux` = &#34;Fe+3&#34; will
            set sample fO2 based on the Fe+2/Fe+3 redox couple.
        
        default_logfO2 : float, default -6
            Default value for sample logfO2 in case redox data cannot be found
            in the user-supplied sample spreadsheet.
        
        exclude : list of str, default []
            Names of columns in the user-supplied sample spreadsheet that should
            not be considered aqueous species. Useful for excluding columns
            containing sample metatadata, such as &#34;Year&#34; and &#34;Location&#34;.
            
        suppress : list of str, default []
            Names of chemical species that will be prevented from forming in the
            speciation calculation.
            
        charge_balance_on : str, default &#34;none&#34;
            If &#34;none&#34;, will not balance electrical charge between cations and
            anions in the speciation calculation. If a name of a species is
            supplied instead, the activity of that species will be allowed to
            change until charge balance is obtained. For example,
            charge_balance_on = &#34;H+&#34; will calculate what pH a sample must have
            to have zero net charge.
        
        suppress_missing : bool, default True
            Suppress the formation of an aqueous species if it is missing a
            value in the user-supplied sample spreadsheet?
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
            
        report_filename : str, optional
            Name of the comma separated values (csv) report file generated when
            the calculation is complete. If this argument is not defined, a
            report file is not generated.
            
        get_aq_dist : bool, default True
            Calculate distributions of aqueous species?
        
        aq_dist_type : str, default &#34;log_activity&#34;
            Desired units of measurement for reported distributions of aqueous
            species. Can be &#34;molality&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, or
            &#34;log_activity&#34;. Ignored if `get_aq_dist` is False.
        
        get_mass_contribution : bool, default True
            Calculate basis species contributions to mass balance of aqueous
            species?
        
        mass_contribution_other : bool, default True
            Include an &#34;other&#34; species for the sake of summing percents of basis
            species contributions to 100%? Ignored if `get_mass_contribution` is
            False.
        
        get_mineral_sat : bool, default True
            Calculate saturation states of pure solids?
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Desired units of measurement for reported saturation states of pure
            solids. Can be &#34;logQoverK&#34; or &#34;affinity&#34;. Ignored if
            `get_mineral_sat` is False.
        
        get_redox : bool, default True
            Calculate potentials of redox couples?
            
        redox_type : str, default &#34;Eh&#34;
            Desired units of measurement for reported redox potentials. Can be
            &#34;Eh&#34;, &#34;pe&#34;, &#34;logfO2&#34;, or &#34;Ah&#34;. Ignored if `get_redox` is False.
        
        get_ion_activity_ratios : bool, default True
            Calculate ion/H+ activity ratios and neutral species activities?
        
        get_fugacity : bool, default True
            Calculate gas fugacities?
        
        get_affinity_energy : bool, default False
            Calculate affinities and energy supplies of reactions listed in a
            separate user-supplied file?
        
        rxn_filename : str, optional
            Name of .txt file containing reactions used to calculate affinities
            and energy supplies. Ignored if `get_affinity_energy` is False.
        
        not_limiting : list, default [&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;]
            List containing names of species that are not considered limiting
            when calculating energy supplies. Ignored if `get_affinity_energy`
            is False.
        
        get_charge_balance : bool, default True
            Calculate charge balance and ionic strength?
            
        custom_db : bool, default False
            Is the database defined by `db` a custom user-supplied database? If
            this is set to True, searches for a data0.xyz file in the current
            working directory, where &#39;xyz&#39; corresponds to the three letter code
            assigned to `db`. This data0 file is automatically converted into a
            machine-readable file called data1 by software called EQPT. This
            data1 file is then used in speciation calculations.
        
        extra_eqpt_output : bool, default False
            Keep additional output files created by EQPT (see `custom_db`)?
            Ignored if `custom_db` is False.
        
        batch_3o_filename : str, optional
            Name of rds (R object) file exported after the speciation
            calculation? No file will be generated if this argument is not
            defined.
            
        delete_generated_folders : bool, default False
            Delete the &#39;rxn_3i&#39;, &#39;rxn_3o&#39;, and &#39;rxn_3p&#39; folders containing raw
            EQ3NR input, output, and pickup files once the speciation
            calculation is complete?
        
        Returns
        -------
        speciation : object of class Speciation
            Contains the results of the speciation calculation.
        
        &#34;&#34;&#34;
        
        self.verbose = verbose
        
        # check input sample file for errors
        self._check_sample_input_file(input_filename, exclude, db, custom_db,
                                      charge_balance_on, suppress_missing)
        
        if redox_flag == &#34;O2(g)&#34; or redox_flag == -3:
            redox_flag = -3
        elif redox_flag == &#34;pe&#34; or redox_flag == -2:
            redox_flag = -2
        elif redox_flag == &#34;Eh&#34; or redox_flag == -1:
            redox_flag = -1
        elif redox_flag == &#34;logfO2&#34; or redox_flag == 0:
            redox_flag = 0
        elif redox_flag == &#34;redox aux&#34; or redox_flag == 1:
            redox_flag = 1
        else:
            raise Exception(&#34;Unrecognized redox flag. Valid options are &#39;O2(g)&#39;&#34;
                            &#34;, &#39;pe&#39;, &#39;Eh&#39;, &#39;logfO2&#39;, &#39;redox aux&#39;&#34;)
            
        # handle batch_3o naming
        if batch_3o_filename != None:
            if &#34;.rds&#34; in batch_3o_filename[-4:]:
                batch_3o_filename = batch_3o_filename
            else:
                batch_3o_filename = &#34;batch_3o_{}.rds&#34;.format(db)
        else:
            batch_3o_filename = ro.r(&#34;NULL&#34;)

        if custom_db:
            # EQ3/6 cannot handle spaces in the &#39;EQ36DA&#39; path name.
            if &#34; &#34; in os.getcwd():
                msg = (&#34;Error: the path to the custom database &#34;
                    &#34;cannot contain spaces. The current path &#34;
                    &#34;is: [ &#34; + os.getcwd() + &#34; ]. Remove or &#34;
                    &#34;replace spaces in folder names for this &#34;
                    &#34;feature. Example: [ &#34; + os.getcwd().replace(&#34; &#34;, &#34;-&#34;) + &#34; ].&#34;)
                raise Exception(msg)

            self.runeqpt(db, extra_eqpt_output)
            os.environ[&#39;EQ36DA&#39;] = os.getcwd()
            
            data0_path = &#34;data0.&#34; + db
            
        else:
            data0_path = self.eq36da + &#34;/data0.&#34; + db
            
        if os.path.exists(data0_path) and os.path.isfile(data0_path):
            with open(data0_path) as data0:
                data0_lines = data0.readlines()
                start_index = [i+1 for i, s in enumerate(data0_lines) if s == &#39;temperatures\n&#39;]
                end_index = [i for i, s in enumerate(data0_lines) if s == &#39;debye huckel a (adh)\n&#39;]
                db_grids_unformatted = [i.split(&#34;pressures&#34;)[0] for i in data0_lines[start_index[0]:end_index[0]]]
                db_grids = [&#34; &#34;.join(i.split()) for i in db_grids_unformatted if i != &#39;&#39;]
                grid_temp = db_grids[0] + &#34; &#34; + db_grids[1]
                grid_press = db_grids[2] + &#34; &#34; + db_grids[3]
                grid_temp = grid_temp.split(&#34; &#34;)
                grid_press = grid_press.split(&#34; &#34;)
                try:
                    water_model = data0_lines[1].split(&#34;model: &#34;)[1] # extract water model from the second line of data0 file
                    water_model = water_model.replace(&#34;\n&#34;, &#34;&#34;)
                except:
                    water_model = &#34;SUPCRT92&#34;
#                     print(&#34;Water model could not be referenced from {}&#34;.format(data0_path)+&#34;&#34;
#                           &#34;. Defaulting to SUPCRT92 water model...&#34;)
                
                if(water_model not in [&#34;SUPCRT92&#34;, &#34;IAPWS95&#34;, &#34;DEW&#34;]):
                    water_model = &#34;SUPCRT92&#34; # the default for EQ3/6
                    print(&#34;Water model given in {}&#34;.format(data0_path)+&#34; was not &#34;
                          &#34;recognized. Defaulting to SUPCRT92 water model...&#34;)
            
        else: # if a data0 file can&#39;t be found, assume default water model, 0-350 C and PSAT
            water_model = &#34;SUPCRT92&#34;
            grid_temp = [&#34;0.0100&#34;, &#34;50.0000&#34;, &#34;100.0000&#34;, &#34;150.0000&#34;,
                         &#34;200.0000&#34;, &#34;250.0000&#34;, &#34;300.0000&#34;, &#34;350.0000&#34;]
            grid_press = [&#34;1.0000&#34;, &#34;1.0000&#34;, &#34;1.0132&#34;, &#34;4.7572&#34;,
                          &#34;15.5365&#34;, &#34;39.7365&#34;, &#34;85.8378&#34;, &#34;165.2113&#34;]

        if get_affinity_energy:
            if rxn_filename == None:
                err = (&#34;A get_affinity_energy was set to True but a reaction &#34;
                       &#34;file was not specified.&#34;)
                raise Exception(err)
            elif self.__file_exists(rxn_filename, &#39;.txt&#39;):
                pass
        else:
            rxn_filename = &#34;&#34;
            
        # preprocess for EQ3 using R scripts
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_prescript = pkg_resources.resource_string(
                __name__, &#39;preprocess_for_EQ3.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_prescript)
            df_input_processed = ro.r.preprocess(input_filename=input_filename,
                                                 exclude=convert_to_RVector(
                                                     exclude),
                                                 redox_flag=redox_flag,
                                                 redox_aux=redox_aux,
                                                 default_logfO2=default_logfO2,
                                                 charge_balance_on=charge_balance_on,
                                                 suppress_missing=suppress_missing,
                                                 suppress=convert_to_RVector(
                                                     suppress),
                                                 water_model=water_model,
                                                 grid_temp=convert_to_RVector(grid_temp),
                                                 grid_press=convert_to_RVector(grid_press),
                                                 verbose=self.verbose)

        for warning in w:
            print(warning.message)

        self.df_input_processed = pandas2ri.ri2py_dataframe(df_input_processed)

        # run EQ3 on each input file
        cwd = os.getcwd()

        self.__mk_check_del_directory(&#39;rxn_3o&#39;)
        self.__mk_check_del_directory(&#39;rxn_3p&#39;)
        files_3i, files_3i_paths = self.__read_inputs(&#39;3i&#39;, &#39;rxn_3i&#39;)

        input_dir = cwd + &#34;/rxn_3i/&#34;
        output_dir = cwd + &#34;/rxn_3o/&#34;
        pickup_dir = cwd + &#34;/rxn_3p/&#34;
        
        for file in files_3i:
            samplename = self.df_input_processed.loc[file[:-3], &#34;Sample&#34;]
            self.runeq3(filename_3i=file, db=db, samplename=samplename,
                        path_3i=input_dir, path_3o=output_dir,
                        path_3p=pickup_dir)

        if custom_db:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da

        files_3o = [file+&#34;.3o&#34; for file in self.df_input_processed.index]
        
        df_input_processed_names = convert_to_RVector(list(self.df_input_processed.columns))
        
        # mine output
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_3o_mine = pkg_resources.resource_string(
                __name__, &#39;3o_mine.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_3o_mine)
            batch_3o = ro.r.main_3o_mine(
                files_3o=convert_to_RVector(files_3o),
                input_filename=input_filename,
                rxn_filename=rxn_filename,
                get_aq_dist=get_aq_dist,
                aq_dist_type=aq_dist_type,
                get_mass_contribution=get_mass_contribution,
                mass_contribution_other=mass_contribution_other,
                get_mineral_sat=get_mineral_sat,
                mineral_sat_type=mineral_sat_type,
                get_redox=get_redox,
                redox_type=redox_type,
                get_charge_balance=get_charge_balance,
                get_ion_activity_ratios=get_ion_activity_ratios,
                get_fugacity=get_fugacity,
                get_affinity_energy=get_affinity_energy,
                not_limiting=convert_to_RVector(not_limiting),
                batch_3o_filename=batch_3o_filename,
                df_input_processed=pandas2ri.py2ri(self.df_input_processed),
                # Needed for keeping symbols in column names after porting
                #   df_input_processed in the line above. Some kind of check.names
                #   option for pandas2ri.py2ri would be nice. Workaround:
                df_input_processed_names=df_input_processed_names,
                verbose=self.verbose,
            )
        for warning in w:
            print(warning.message)
        
        if get_mass_contribution:
            mass_contribution = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;mass_contribution&#39;))
        df_report = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;report&#39;))
        df_input = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;input&#39;))
        report_divs = batch_3o.rx2(&#39;report_divs&#39;)

        input_cols = list(report_divs.rx2(&#39;input&#39;))
        df_input = df_report[input_cols]

        # handle headers and subheaders of input section
        headers = [col.split(&#34;_&#34;)[0] for col in list(df_input.columns)]
        headers = [&#34;pH&#34; if header == &#34;H+&#34; else header for header in headers]
        headers = [header+&#34;_(input)&#34; if header not in [&#34;Temperature&#34;, &#34;logfO2&#34;]+exclude else header for header in headers]
        report_divs[0] = convert_to_RVector(headers) # modify headers in the &#39;input&#39; section, report_divs[0]
        subheaders = [subheader[1] if len(subheader) &gt; 1 else &#34;&#34; for subheader in [
            col.split(&#34;_&#34;) for col in list(df_input.columns)]]
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_input.columns = multicolumns

        df_join = df_input

        if get_aq_dist:
            aq_distribution_cols = list(report_divs.rx2(&#39;aq_distribution&#39;))
            df_aq_distribution = df_report[aq_distribution_cols]
            df_aq_distribution = df_aq_distribution.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # create a pH column from H+
            df_aq_distribution[&#34;pH&#34;] = -df_aq_distribution[&#34;H+&#34;]
            
            # handle headers of aq_distribution section
            headers = df_aq_distribution.columns
            subheaders = [aq_dist_type]*(len(headers)-1) # -1 because the last column will have subheader pH (see next line)
            subheaders = subheaders + [&#34;pH&#34;]
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_aq_distribution.columns = multicolumns
            
            # ensure final pH column is included in report_divs aq_distribution section
            aq_dist_indx = report_divs.names.index(&#34;aq_distribution&#34;)
            report_divs[aq_dist_indx] = convert_to_RVector(list(headers))
            
            df_join = df_join.join(df_aq_distribution)

        if get_mineral_sat:
            mineral_sat_cols = list(report_divs.rx2(&#39;mineral_sat&#39;))
            df_mineral_sat = df_report[mineral_sat_cols]
            df_mineral_sat = df_mineral_sat.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_mineral_sat section
            if mineral_sat_type == &#34;affinity&#34;:
                mineral_sat_unit = &#34;affinity_kcal&#34;
            elif mineral_sat_type == &#34;logQoverK&#34;:
                mineral_sat_unit = &#34;logQ/K&#34;
            else:
                raise Exception(
                    &#34;mineral_sat_type must be either &#39;affinity&#39; or &#39;logQoverK&#39;&#34;)

            headers = df_mineral_sat.columns
            subheaders = [mineral_sat_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_mineral_sat.columns = multicolumns
            df_join = df_join.join(df_mineral_sat)

        if get_redox:
            redox_cols = list(report_divs.rx2(&#39;redox&#39;))
            df_redox = df_report[redox_cols]
            df_redox = df_redox.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_redox section
            if redox_type == &#34;Eh&#34;:
                redox_unit = &#34;Eh_volts&#34;
            elif redox_type == &#34;pe&#34;:
                redox_unit = &#34;pe&#34;
            elif redox_type == &#34;logfO2&#34;:
                redox_unit = &#34;logfO2&#34;
            elif redox_type == &#34;Ah&#34;:
                redox_unit = &#34;Ah_kcal&#34;
            else:
                raise Exception(
                    &#34;redox_type must be either &#39;Eh&#39;, &#39;pe&#39;, &#39;logfO2&#39;, or &#39;Ah&#39;&#34;)

            headers = df_redox.columns
            subheaders = [redox_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_redox.columns = multicolumns
            df_join = df_join.join(df_redox)

        if get_charge_balance:
            charge_balance_cols = list(report_divs.rx2(&#39;charge_balance&#39;))
            df_charge_balance = df_report[charge_balance_cols]
            df_charge_balance = df_charge_balance.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_charge_balance section
            headers = df_charge_balance.columns
            subheaders = [&#34;%&#34;]*2 + [&#39;eq/kg.H2O&#39;, &#39;molality&#39;] + \
                [&#39;eq/kg.H2O&#39;]*4 + [&#39;molality&#39;]
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_charge_balance.columns = multicolumns
            df_join = df_join.join(df_charge_balance)
            
        if get_ion_activity_ratios:
            ion_activity_ratio_cols = list(report_divs.rx2(&#39;ion_activity_ratios&#39;))
            df_ion_activity_ratios = df_report[ion_activity_ratio_cols]
            df_ion_activity_ratios = df_ion_activity_ratios.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            
            # handle headers of df_ion_activity_ratios section
            headers = df_ion_activity_ratios.columns
            subheaders = [&#34;Log ion-H+ activity ratio&#34;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_ion_activity_ratios.columns = multicolumns
            df_join = df_join.join(df_ion_activity_ratios)
            
        if get_fugacity:
            fugacity_cols = list(report_divs.rx2(&#39;fugacity&#39;))
            df_fugacity = df_report[fugacity_cols]
            df_fugacity = df_fugacity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            
            # handle headers of fugacity section
            headers = df_fugacity.columns
            subheaders = [&#34;log_fugacity&#34;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_fugacity.columns = multicolumns
            df_join = df_join.join(df_fugacity)
            
        if get_affinity_energy:
            affinity_cols = list(report_divs.rx2(&#39;affinity&#39;))
            energy_cols = list(report_divs.rx2(&#39;energy&#39;))
            df_affinity = df_report[affinity_cols]
            df_energy = df_report[energy_cols]
            df_affinity = df_affinity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            df_energy = df_energy.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_affinity section
            headers = df_affinity.columns
            subheaders = [&#39;cal/mol e-&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_affinity.columns = multicolumns

            # handle headers of df_energy section
            headers = df_energy.columns
            subheaders = [&#39;cal/kg.H2O&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_energy.columns = multicolumns
            df_join = df_join.join(df_affinity)
            df_join = df_join.join(df_energy)

        out_dict = {&#39;sample_data&#39;: {},
                    &#39;report&#39;: df_join,
                    &#39;input&#39;: df_input, &#39;report_divs&#39;: report_divs}
        
        if get_mass_contribution:
            out_dict[&#39;mass_contribution&#39;] = mass_contribution

        sample_data = batch_3o.rx2(&#39;sample_data&#39;)

        # assemble sample data
        for i, sample in enumerate(sample_data):
            dict_sample_data = {
                &#34;filename&#34;: str(sample.rx2(&#39;filename&#39;)[0]),
                &#34;name&#34;: str(sample.rx2(&#39;name&#39;)[0]),
                &#34;temperature&#34;: float(sample.rx2(&#39;temperature&#39;)[0]),
                &#34;pressure&#34;: float(sample.rx2(&#39;pressure&#39;)[0]),
                &#34;logact_H2O&#34;: float(sample.rx2(&#39;logact_H2O&#39;)[0]),
                &#34;H2O_density&#34;: float(sample.rx2(&#39;H2O_density&#39;)[0]),
                &#34;H2O_molality&#34;: float(sample.rx2(&#39;H2O_molality&#39;)[0]),
                &#34;H2O_log_molality&#34;: float(sample.rx2(&#39;H2O_log_molality&#39;)[0]),
                }

            if get_aq_dist:
                sample_aq_dist = pandas2ri.ri2py_dataframe(sample.rx2(&#39;aq_distribution&#39;))
                sample_aq_dist = sample_aq_dist.apply(pd.to_numeric, errors=&#39;coerce&#39;)
                dict_sample_data.update({&#34;aq_distribution&#34;: sample_aq_dist})

            if get_mass_contribution:
                sample_mass_contribution = mass_contribution[mass_contribution[&#34;sample&#34;] == sample.rx2(&#39;name&#39;)[0]]
                dict_sample_data.update(
                    {&#34;mass_contribution&#34;: sample_mass_contribution})

            if get_mineral_sat:
                dict_sample_data.update(
                    {&#34;mineral_sat&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;mineral_sat&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                # replace sample mineral_sat entry with None if there is no mineral saturation data.
                if(len(dict_sample_data[&#39;mineral_sat&#39;].index) == 1 and dict_sample_data[&#39;mineral_sat&#39;].index[0] == &#39;None&#39;):
                    dict_sample_data[&#39;mineral_sat&#39;] = None

            if get_redox:
                dict_sample_data.update(
                    {&#34;redox&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;redox&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            if get_charge_balance:
                dict_sample_data.update({&#34;charge_balance&#34;: df_charge_balance.loc[sample.rx2(&#39;name&#39;)[0], :]})
            
            if get_ion_activity_ratios:
                try:
                    dict_sample_data.update(
                        {&#34;ion_activity_ratios&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;ion_activity_ratios&#39;))})
                except:
                    dict_sample_data[&#39;ion_activity_ratios&#39;] = None
            
            if get_fugacity:
                dict_sample_data.update(
                    {&#34;fugacity&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;fugacity&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                # replace sample fugacity entry with None if there is no fugacity data.
                if(len(dict_sample_data[&#39;fugacity&#39;].index) == 1 and dict_sample_data[&#39;fugacity&#39;].index[0] == &#39;None&#39;):
                    dict_sample_data[&#39;fugacity&#39;] = None
                else:
                    dict_sample_data[&#34;fugacity&#34;][&#34;fugacity&#34;] = 10**dict_sample_data[&#34;fugacity&#34;][&#34;log_fugacity&#34;]
            
            if get_affinity_energy:
                dict_sample_data.update({&#34;affinity_energy_raw&#34;: pandas2ri.ri2py_dataframe(
                    sample.rx2(&#39;affinity_energy_raw&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                dict_sample_data.update(
                    {&#34;affinity_energy&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;affinity_energy&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            out_dict[&#34;sample_data&#34;].update(
                {sample_data.names[i]: dict_sample_data})

        out_dict.update({&#34;batch_3o&#34;: batch_3o})
        
        out_dict.update({&#34;water_model&#34;:water_model, &#34;grid_temp&#34;:grid_temp, &#34;grid_press&#34;:grid_press})
        
        speciation = Speciation(out_dict)

        if report_filename != None:
            if &#34;.csv&#34; in report_filename[-4:]:
                out_dict[&#34;report&#34;].to_csv(report_filename)
            else:
                out_dict[&#34;report&#34;].to_csv(report_filename+&#34;.csv&#34;)

        if delete_generated_folders:
            self._delete_rxn_folders()
        
        if self.verbose &gt; 0:
            print(&#34;Finished!&#34;)
        
        return speciation


    def create_data0(self,
                     db,
                     filename,
                     filename_ss=None,
                     data0_formula_ox_name=None,
                     suppress_redox=[],
                     water_model=&#34;SUPCRT92&#34;,
                     exceed_Ttr=True,
                     grid_temps=[0.0100, 50.0000, 100.0000, 150.0000,
                                 200.0000, 250.0000, 300.0000, 350.0000],
                     grid_press=&#34;Psat&#34;,
                     infer_formula_ox=False,
                     generate_template=True,
                     template_name=None,
                     template_type=&#34;strict&#34;,
                     verbose=1):
        &#34;&#34;&#34;
        Create a data0 file from a custom thermodynamic dataset.
        
        Parameters
        ----------
        db : str
            Desired three letter code of data0 output.
            
        filename : str
            Name of csv file containing thermodynamic data in the OBIGT format.
            
        filename_ss : str, optional
            Name of file containing solid solution parameters.
        
        data0_formula_ox_name : str, optional
            Name of supplementary file containing data0 parameters and inferred
            formula oxidation states. Ignored if `infer_formula_ox` is False.
            See `infer_formula_ox` for more detail.
        
        suppress_redox : list of str, default []
            Suppress equilibrium between oxidation states of listed elements
            (Cl, H, and O cannot be included).

        water_model : str, default &#34;SUPCRT92&#34;
            This is an experimental feature that is not yet fully supported.
            Desired water model. Can be either &#34;SUPCRT92&#34;, &#34;IAPWS95&#34;, or &#34;DEW&#34;.
            These models are described here: http://chnosz.net/manual/water.html

        exceed_Ttr : bool, default True
            Calculate Gibbs energies of mineral phases and other species
            beyond their transition temperatures?

        grid_temps : list of eight float, default [0.0100, 50.0000, 100.0000, 150.0000, 200.0000, 250.0000, 300.0000, 350.0000]
            Eight temperature values that make up the T-P grid.
        
        grid_press : list of float, default &#34;Psat&#34;
            Eight pressure values that make up the T-P grid. &#34;Psat&#34; for
            calculations along the liquid-vapor saturation curve.

        infer_formula_ox : bool, default False
            Create a supplementary file containing data0 parameters and
            inferred formula oxidation states? This option is useful for
            creating as many entries in the formula_ox column when creating a
            new supplementary file. Note that compounds like DySO4+ result in
            blank entries in formula_ox because the redox states of two
            elements, Dy and S, would have to be estimated together; S has many
            oxidation states and Dy&#39;s oxidation states are not hard-coded.
        
        generate_template : bool, default True
            Generate a CSV sample input template customized to this data0?
            Columns include &#39;Sample&#39;, &#39;Temperature&#39;, &#39;logfO2&#39;, and all strict
            basis species.
        
        template_name : str, optional
            Name of the sample input template file generated. If no name is
            supplied, defaults to &#39;sample_template_xyz.csv&#39;, where &#39;xyz&#39; is
            the three letter code given to `db`. Ignored if `generate_template`
            is False.
        
        template_type : str, either &#39;strict&#39;, &#39;all basis&#39;, or &#39;all species&#39;
            Determines which columns are written to the sample template.
            - &#39;strict&#39; includes strict basis species
            - &#39;all basis&#39; includes strict and auxiliary basis species
            - &#39;all species&#39; includes all species in the thermodynamic database
            Ignored if `generate_template` is False.
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
        &#34;&#34;&#34;
        
        # Check that thermodynamic database input files exist and are formatted
        # correctly.
        self._check_database_file(filename)
        if filename_ss != None:
            self.__file_exists(filename_ss)
        
        self.verbose = verbose
        
        if self.verbose &gt;= 1:
            print(&#34;Creating data0.{}...&#34;.format(db), flush=True)
        
        if len(grid_temps) &gt; 8 or len(grid_temps) &lt; 1:
            raise Exception(&#34;&#39;grid_temps&#39; must have eight values.&#34;)
        if isinstance(grid_press, list):
            if len(grid_press) &gt; 8 or len(grid_press) &lt; 1:
                raise Exception(&#34;&#39;grid_press&#39; must have eight values.&#34;)
        
        if sum([T &gt;= 10000 for T in grid_temps]):
            raise Exception(&#34;Grid temperatures must be below 10000 °C.&#34;)
        
        if isinstance(grid_press, list):
            if sum([P &gt;= 10000 for P in grid_press]):
                raise Exception(&#34;Grid pressures must be below 10000 bars.&#34;)
            
        if water_model == &#34;SUPCRT92&#34;:
            min_T = 0
            max_T = 2250
            min_P = 1
            max_P = 30000
        elif water_model == &#34;IAPWS95&#34;:
            min_T = 0
            max_T = 1000
            min_P = 1
            max_P = 10000
        elif water_model == &#34;DEW&#34;:
            min_T = 0
            max_T = 1000
            min_P = 1
            max_P = 60000
        else:
            raise Exception(&#34;The water model &#39;{}&#39; &#34;.format(water_model)+&#34;is not &#34;
                            &#34;recognized. Try &#39;SUPCRT92&#39;, &#39;IAPWS95&#39;, or &#39;DEW&#39;.&#34;)
        
        # check that T and P are above minimum values
        if sum([T &lt;= min_T for T in grid_temps]):
            print(&#34;WARNING: one or more temperatures in &#39;grid_temps&#39; is below &#34;
                  &#34;or equal to {} °C&#34;.format(min_T)+&#34; and is outside the valid &#34;
                  &#34;temperature range for the {} water model.&#34;.format(water_model))
        if isinstance(grid_press, list):
            if sum([P &lt; min_P for P in grid_press]):
                print(&#34;WARNING: one or more pressures in &#39;grid_press&#39; is below &#34;
                      &#34;{} bar&#34;.format(min_P)+&#34;, the minimum valid &#34;
                      &#34;pressure for the {} water model.&#34;.format(water_model))
        
        # check that T and P are below maximum values
        if sum([T &gt; max_T for T in grid_temps]):
            print(&#34;WARNING: one or more temperatures in &#39;grid_temps&#39; is above &#34;
                  &#34;{} °C&#34;.format(max_T)+&#34;, the maximum valid &#34;
                  &#34;temperature for the {} water model.&#34;.format(water_model))
        if isinstance(grid_press, list):
            if sum([P &gt; max_P for P in grid_press]):
                print(&#34;WARNING: one or more pressures in &#39;grid_press&#39; is above &#34;
                      &#34;{} bar&#34;.format(max_P)+&#34;, the maximum valid &#34;
                      &#34;pressure for the {} water model.&#34;.format(water_model))
            
        if water_model != &#34;SUPCRT92&#34;:
            print(&#34;WARNING: water models other than SUPCRT92 are not yet fully supported.&#34;)
        
        template = pkg_resources.resource_string(
            __name__, &#39;data0.min&#39;).decode(&#34;utf-8&#34;)
        grid_temps = convert_to_RVector(grid_temps)
        grid_press = convert_to_RVector(grid_press)
        suppress_redox = convert_to_RVector(suppress_redox)
        
        if filename_ss == None:
            filename_ss = ro.r(&#34;NULL&#34;)
        if data0_formula_ox_name == None:
            data0_formula_ox_name = ro.r(&#34;NULL&#34;)
        if template_name == None:
            template_name = &#34;sample_template_{}.csv&#34;.format(db)
        if template_type not in [&#39;strict&#39;, &#39;all basis&#39;, &#39;all species&#39;]:
            raise Exception(&#34;template_type {} &#34;.format(template_type)+&#34;is not&#34;
                            &#34;recognized. Try &#39;strict&#39;, &#39;all basis&#39;, or &#39;all species&#39;&#34;)

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_create_data0 = pkg_resources.resource_string(
                __name__, &#39;create_data0.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_create_data0)
            ro.r.main_create_data0(filename=filename,
                                   filename_ss=filename_ss,
                                   grid_temps=grid_temps,
                                   grid_press=grid_press,
                                   db=db,
                                   water_model=water_model,
                                   template=template,
                                   exceed_Ttr=exceed_Ttr,
                                   data0_formula_ox_name=data0_formula_ox_name,
                                   suppress_redox=suppress_redox,
                                   infer_formula_ox=infer_formula_ox,
                                   generate_template=generate_template,
                                   template_name=template_name,
                                   template_type=template_type,
                                   verbose=self.verbose)
    
        for warning in w:
            print(warning.message)
        
        if self.verbose &gt; 0:
            print(&#34;Finished creating data0.{}.&#34;.format(db))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="AqEquil.AqSpeciation.convert_to_RVector"><code class="name flex">
<span>def <span class="ident">convert_to_RVector</span></span>(<span>value, force_Rvec=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a value or list into an R vector of the appropriate type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>numeric</code> or <code>str,</code> or <code>list</code> of <code>numeric</code> or <code>str</code></dt>
<dd>Value to be converted.</dd>
<dt><strong><code>force_Rvec</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If <code>value</code> is not a list, force conversion into a R vector?
False will return an int, float, or str if value is non-list.
True will always return an R vector.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int, float, str,</code> or <code>an rpy2 R vector</code></dt>
<dd>A value or R vector of an appropriate data type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_RVector(value, force_Rvec=True):
    
    &#34;&#34;&#34;
    Convert a value or list into an R vector of the appropriate type.
    
    Parameters
    ----------
    value : numeric or str, or list of numeric or str
        Value to be converted.
    
    force_Rvec : bool, default True
        If `value` is not a list, force conversion into a R vector?
        False will return an int, float, or str if value is non-list.
        True will always return an R vector.
    
    Returns
    -------
    int, float, str, or an rpy2 R vector
        A value or R vector of an appropriate data type.
    &#34;&#34;&#34;

    if not isinstance(value, list) and not force_Rvec:
        return value
    elif not isinstance(value, list) and force_Rvec:
        value = [value]
    else:
        pass

    if all(isinstance(x, bool) for x in value):
        return ro.BoolVector(value)
    elif all(isinstance(x, int) for x in value):
        return ro.IntVector(value)
    elif all(isinstance(x, float) or isinstance(x, int) for x in value):
        return ro.FloatVector(value)
    else:
        return ro.StrVector(value)</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename, messages=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a speciation file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the speciation file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An object of class <code><a title="AqEquil.AqSpeciation.Speciation" href="#AqEquil.AqSpeciation.Speciation">Speciation</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(filename, messages=True):
    &#34;&#34;&#34;
    Load a speciation file.

    Parameters
    ----------
    filename : str
        Name of the speciation file.

    Returns
    ----------
    An object of class `Speciation`.
    &#34;&#34;&#34;

    with open(filename, &#39;rb&#39;) as handle:
        speciation = pickle.load(handle)
        if messages:
            print(&#34;Loaded &#39;{}&#39;&#34;.format(filename))
        return speciation</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AqEquil.AqSpeciation.AqEquil"><code class="flex name class">
<span>class <span class="ident">AqEquil</span></span>
<span>(</span><span>eq36da=None, eq36co=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class containing functions to speciate aqueous water chemistry data using
existing or custom thermodynamic datasets.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eq36da</code></strong> :&ensp;<code>str, defaults to path given by the environment variable EQ36DA</code></dt>
<dd>Path to directory where data1 files are stored.</dd>
<dt><strong><code>eq36co</code></strong> :&ensp;<code>str, defaults to path given by the environment variable EQ36CO</code></dt>
<dd>Path to directory where EQ3 executables are stored.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>eq36da</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory where data1 files are stored.</dd>
<dt><strong><code>eq36co</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to directory where EQ3 executables are stored.</dd>
<dt><strong><code>df_input_processed</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe containing user-supplied sample chemistry data that has
been processed by <code>speciate</code>.</dd>
<dt><strong><code>out_dict</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe reporting results of last speciation calculation
performed by <code>speciate</code>.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int, 0, 1,</code> or <code>2</code>, default <code>1</code></dt>
<dd>Level determining how many messages are returned during a
calculation. 2 for all messages, 1 for errors or warnings only,
0 for silent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AqEquil():

    &#34;&#34;&#34;
    Class containing functions to speciate aqueous water chemistry data using
    existing or custom thermodynamic datasets.
    
    Parameters
    ----------
    eq36da : str, defaults to path given by the environment variable EQ36DA
        Path to directory where data1 files are stored. 
        
    eq36co : str, defaults to path given by the environment variable EQ36CO
        Path to directory where EQ3 executables are stored.
    
    Attributes
    ----------
    eq36da : str
        Path to directory where data1 files are stored.
        
    eq36co : str
        Path to directory where EQ3 executables are stored.
        
    df_input_processed : pd.Dataframe
        Pandas dataframe containing user-supplied sample chemistry data that has
        been processed by `speciate`.
        
    out_dict : pd.Dataframe
        Pandas dataframe reporting results of last speciation calculation
        performed by `speciate`.
    
    verbose : int, 0, 1, or 2, default 1
        Level determining how many messages are returned during a
        calculation. 2 for all messages, 1 for errors or warnings only,
        0 for silent.
        
    &#34;&#34;&#34;

    def __init__(self,
                 eq36da=os.environ.get(&#39;EQ36DA&#39;),
                 eq36co=os.environ.get(&#39;EQ36CO&#39;)):

        self.eq36da = eq36da
        self.eq36co = eq36co
        self.df_input_processed = None
        self.out_dict = None
        self.verbose = 1

        os.environ[&#39;EQ36DA&#39;] = self.eq36da  # set eq3 db directory
        os.environ[&#39;EQ36CO&#39;] = self.eq36co  # set eq3 .exe directory
    
    
    @staticmethod
    def __file_exists(filename, ext=&#39;.csv&#39;):
        &#34;&#34;&#34;
        Check that a file exists and that it has the correct extension.
        Returns True if so, raises exception if not.
        &#34;&#34;&#34;
        
        ext_dict = {
            &#34;.csv&#34; : &#34;comma separated values (.csv)&#34;,
            &#34;.txt&#34; : &#34;standard text (.txt)&#34;,
            &#34;.rds&#34; : &#34;R Data (.rds)&#34;,
        }
        
        if ext in filename[-4:]:
            if os.path.exists(filename) and os.path.isfile(filename):
                return True
            else:
                err = &#34;Cannot locate input file {}.&#34;.format(filename)
                raise Exception(err)
        else:
            err = (&#34;Input file {}&#34;.format(filename) + &#34; &#34;
                &#34;must be in {} format.&#34;.format(ext_dict[ext]))
            raise Exception(err)
        
        return False
    
    
    def _check_database_file(self, filename):
        
        &#34;&#34;&#34;
        Check for problems in the thermodynamic database CSV.
        &#34;&#34;&#34;
        
        # is the file a csv?
        self.__file_exists(filename)
        
        thermo_df = pd.read_csv(filename)
        
        # does this file have the proper headers?
        required_headers = [&#34;name&#34;, &#34;abbrv&#34;, &#34;formula&#34;, &#34;state&#34;,
                            &#34;ref1&#34;, &#34;ref2&#34;, &#34;date&#34;, &#34;E_units&#34;,
                            &#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;Cp&#34;, &#34;V&#34;,
                            &#34;a1.a&#34;, &#34;a2.b&#34;, &#34;a3.c&#34;, &#34;a4.d&#34;, &#34;c1.e&#34;, &#34;c2.f&#34;,
                            &#34;omega.lambda&#34;, &#34;z.T&#34;,
                            &#34;azero&#34;, &#34;neutral_ion_type&#34;,
                            &#34;dissrxn&#34;, &#34;tag&#34;, &#34;formula_ox&#34;]
        
        missing_headers = []
        for header in required_headers:
            if header not in thermo_df.columns:
                missing_headers.append(header)
        if len(missing_headers) &gt; 0:
            msg = (&#34;The thermodynamic database file &#39;{}&#39;&#34;.format(filename)+&#34; &#34;
                   &#34;is missing one or more required columns: &#34;
                   &#34;{}&#34;.format(&#34;, &#34;.join(missing_headers))+&#34;. &#34;
                   &#34;Are these headers spelled correctly in the file?&#34;)
            raise Exception(msg)
        
        # does Cl-, O2(g), and O2 exist in the file?
        required_species = [&#34;Cl-&#34;, &#34;O2&#34;, &#34;O2(g)&#34;]
        missing_species = []
        for species in required_species:
            if species not in list(thermo_df[&#34;name&#34;]):
                missing_species.append(species)
        if len(missing_species) &gt; 0:
            msg = (&#34;The thermodynamic database file &#39;{}&#39;&#34;.format(filename)+&#34; &#34;
                   &#34;is missing required species:&#34;
                   &#34;{}&#34;.format(missing_species)+&#34;. Default thermodynamic values&#34;
                   &#34; will be used.&#34;)
            warnings.warn(msg)
        
        return

    
    def _check_sample_input_file(self, input_filename, exclude, db, custom_db,
                                       charge_balance_on, suppress_missing):
        &#34;&#34;&#34;
        Check for problems in sample input file.
        &#34;&#34;&#34;
        
        # does the input file exist? Is it a CSV?
        if self.__file_exists(input_filename):
            df_in = pd.read_csv(input_filename, header=None) # no headers for now so colname dupes can be checked
        else:
            raise Exception(&#34;_check_sample_input() error!&#34;)
        
        # are there any samples?
        if df_in.shape[0] &lt;= 2:
            err_no_samples = (&#34;The file {}&#34;.format(input_filename) + &#34; &#34;
                &#34;must contain at least three rows: the &#34;
                &#34;first for column names, the second for column subheaders, &#34;
                &#34;followed by one or more rows for sample data.&#34;)
            raise Exception(err_no_samples)
        
        err_list = [] # for appending errors found in the sample input file
        
        # get header list
        col_list = list(df_in.iloc[0, 1:])
        
        # are there blank headers?
        if True in [isinstance(x, float) and x != x for x in col_list]:
            # isinstance(x, float) and x != x is a typesafe way to check for nan
            err_blank_header = (&#34;One or more columns in the sample input &#34;
                &#34;file have blank headers. These might be empty columns. &#34;
                &#34;Only the first column may have a blank header. Remove any &#34;
                &#34;empty columns and/or give each header a name.&#34;)
            raise Exception(err_blank_header)
        
        # are there duplicate headers?
        dupe_cols = list(set([x for x in col_list if col_list.count(x) &gt; 1]))
        if len(dupe_cols) &gt; 0:
            err_dupe_cols = (&#34;Duplicate column names are not allowed. &#34;
                &#34;Duplicate column names were found for:\n&#34;
                &#34;{}&#34;.format(str(dupe_cols)))
            err_list.append(err_dupe_cols)
        
        df_in.columns = df_in.iloc[0] # set column names
        df_in = df_in.drop(df_in.index[0], axis=0) # drop column name row
        df_in_headercheck = copy.deepcopy(df_in.iloc[:,1:]) # drop first column. Deepcopy slice because drop() doesn&#39;t work well with unnamed columns.
        
        # drop excluded headers
        for exc in exclude:
            if exc == df_in.columns[0]: # skip if &#39;sample&#39; column is excluded
                continue
            try:
                df_in_headercheck = df_in_headercheck.drop(exc, axis=1) # drop excluded columns
            except:
                err_bad_exclude = (&#34;Could not exclude the header &#39;{}&#39;&#34;.format(exc)+&#34;. &#34;
                                   &#34;This header could not be found in {}&#34;.format(input_filename)+&#34;&#34;)
                err_list.append(err_bad_exclude)
        
        # get row list
        row_list = list(df_in.iloc[1:, 0])
        
        # are there blank rows?
        if True in [isinstance(x, float) and x != x for x in row_list]:
            # isinstance(x, float) and x != x is a typesafe way to check for nan
            err_blank_row = (&#34;One or more rows in the sample input &#34;
                &#34;file have blank sample names. These might be empty rows. &#34;
                &#34;Remove any empty rows and/or give each sample a name. Sample &#34;
                &#34;names go in the first column.&#34;)
            raise Exception(err_blank_row)
            
        # are there duplicate rows?
        dupe_rows = list(set([x for x in row_list if row_list.count(x) &gt; 1]))
        if len(dupe_rows) &gt; 0:
            err_dupe_rows = (&#34;Duplicate sample names are not allowed. &#34;
                &#34;Duplicate sample names were found for:\n&#34;
                &#34;{}&#34;.format(str(dupe_rows)))
            err_list.append(err_dupe_rows)
        
        # are column names valid entries in the database?
        if custom_db:
            data0_path = &#34;data0.&#34; + db
        else:
            data0_path = self.eq36da + &#34;/data0.&#34; + db
        if os.path.exists(data0_path) and os.path.isfile(data0_path):
            with open(data0_path) as data0:
                data0_lines = data0.readlines()
                start_index = [i+1 for i, s in enumerate(data0_lines) if &#39;*  species name&#39; in s]
                end_index = [i-1 for i, s in enumerate(data0_lines) if &#39;elements&#39; in s]
                db_species = [i.split()[0] for i in data0_lines[start_index[0]:end_index[0]]]
                if charge_balance_on == &#39;pH&#39;:
                    err_charge_balance_on_pH = (&#34;To balance charge on pH, use &#34;
                        &#34;charge_balance_on=&#39;H+&#39;&#34;)
                    err_list.append(err_charge_balance_on_pH)
                elif charge_balance_on in [&#39;Temperature&#39;, &#39;logfO2&#39;]:
                    err_charge_balance_invalid_type = (&#34;Cannot balance charge &#34;
                        &#34;on {}.&#34;.format(charge_balance_on))
                    err_list.append(err_charge_balance_invalid_type)
                elif charge_balance_on != &#34;none&#34; and charge_balance_on not in list(set(df_in_headercheck.columns)):
                    err_charge_balance_invalid_sp = (&#34;The species chosen for charge balance&#34;
                        &#34; &#39;{}&#39;&#34;.format(charge_balance_on)+&#34;&#34;
                        &#34; was not found among the headers of the sample input file.&#34;)
                    err_list.append(err_charge_balance_invalid_sp)
                for species in list(set(df_in_headercheck.columns)):
                    if species not in db_species and species not in [&#39;Temperature&#39;, &#39;logfO2&#39;, &#39;pH&#39;]:
                        err_species_not_in_db = (&#34;The species &#39;{}&#39;&#34;.format(species) + &#34; &#34;
                            &#34;was not found in {}&#34;.format(data0_path) + &#34;. &#34;
                            &#34;If the column contains data that should not be &#34;
                            &#34;included in the speciation calculation, add the &#34;
                            &#34;column name to the &#39;exclude&#39; argument. Try &#34;
                            &#34;help(AqEquil.AqEquil.speciate) &#34;
                            &#34;for more information about &#39;exclude&#39;.&#34;)
                        err_list.append(err_species_not_in_db)
                    elif species == &#39;pH&#39;:
                        err_species_pH = (&#34;Please rename the &#39;pH&#39; column in &#34;
                            &#34;the sample input file to &#39;H+&#39; with the subheader &#34;
                            &#34;unit &#39;pH&#39;.&#34;)
                        err_list.append(err_species_pH)
                    
        else:
            err_no_data0 = (&#34;Could not locate {}.&#34;.format(data0_path) + &#34; &#34;
                &#34;Unable to determine if column headers included in &#34;
                &#34;{} &#34;.format(input_filename) + &#34;match entries for species &#34;
                &#34;in the requested thermodynamic database &#39;{}&#39;.&#34;.format(db))
            err_list.append(err_no_data0)
        
        
        # are subheader units valid?
        subheaders = df_in_headercheck.iloc[0,]
        valid_subheaders = [&#34;degC&#34;, &#34;ppm&#34;, &#34;ppb&#34;, &#34;Suppressed&#34;, &#34;Molality&#34;,
                            &#34;Molarity&#34;, &#34;mg/L&#34;, &#34;mg/kg.sol&#34;, &#34;Alk., eq/kg.H2O&#34;,
                            &#34;Alk., eq/L&#34;, &#34;Alk., eq/kg.sol&#34;, &#34;Alk., mg/L CaCO3&#34;,
                            &#34;Alk., mg/L HCO3-&#34;, &#34;Log activity&#34;, &#34;Log act combo&#34;,
                            &#34;Log mean act&#34;, &#34;pX&#34;, &#34;pH&#34;, &#34;pHCl&#34;, &#34;pmH&#34;, &#34;pmX&#34;,
                            &#34;Hetero. equil.&#34;, &#34;Homo. equil.&#34;, &#34;Make non-basis&#34;,
                            &#34;logfO2&#34;, &#34;Mineral&#34;]
        for i, subheader in enumerate(subheaders):
            if subheader not in valid_subheaders:
                err_valid_sub = (&#34;The subheader &#39;{}&#39;&#34;.format(subheader) + &#34; &#34;
                    &#34;for the column &#39;{}&#39;&#34;.format(df_in_headercheck.columns[i]) + &#34; &#34;
                    &#34;is not recognized. Valid subheaders are {}&#34;.format(str(valid_subheaders)) + &#34;. &#34;
                    &#34;If the column {}&#34;.format(df_in_headercheck.columns[i]) + &#34; &#34;
                    &#34;contains data that is not meant for the &#34;
                    &#34;speciation calculation, add the column name &#34;
                    &#34;to the &#39;exclude&#39; argument. Try help(AqEquil.AqEquil.speciate) &#34;
                    &#34;for more information about &#39;exclude&#39;.&#34;)
                err_list.append(err_valid_sub)
            
        # is a &#39;Temperature&#39; column present?
        if &#34;Temperature&#34; not in df_in_headercheck.columns and &#34;Temperature&#34; not in exclude:
            err_temp = (&#34;The column &#39;Temperature&#39; was not found in the input file. &#34;
                &#34;Please include a column with &#39;Temperature&#39; in the first row, &#34;
                &#34;&#39;degC&#39; in the second row, and a temperature value for each &#34;
                &#34;sample in degrees Celsius.&#34;)
            err_list.append(err_temp)
        
        # raise exception that outlines all errors found
        if len(err_list) &gt; 0:
            errs = &#34;\n\n*&#34;.join(err_list)
            errs = (&#34;The input file {}&#34;.format(input_filename)+&#34; encountered&#34;
                &#34; errors:\n\n*&#34; + errs)
            raise Exception(errs)
        
        return
        
        
    def __clear_eqpt_extra_output(self):
        
        &#34;&#34;&#34;
        Deletes all EQPT output except data1.
        &#34;&#34;&#34;
        
        if os.path.exists(&#34;eqpt_log.txt&#34;) and os.path.isfile(&#34;eqpt_log.txt&#34;):
            os.remove(&#34;eqpt_log.txt&#34;)
        if os.path.exists(&#34;data1f.txt&#34;) and os.path.isfile(&#34;data1f.txt&#34;):
            os.remove(&#34;data1f.txt&#34;)
        if os.path.exists(&#34;slist.txt&#34;) and os.path.isfile(&#34;slist.txt&#34;):
            os.remove(&#34;slist.txt&#34;)

            
    def runeqpt(self, db, extra_eqpt_output=False):
        
        &#34;&#34;&#34;
        Convert a data0 into a data1 file with EQPT.
        
        Parameters
        ----------
        db : str
            Three letter code of database.
        
        extra_eqpt_output : bool, default False
            Keep additional output files from EQPT? These files include
            eqpt_log.txt, data1f.txt, and slist.txt.
        &#34;&#34;&#34;

        if os.path.exists(&#34;data0.&#34;+db) and os.path.isfile(&#34;data0.&#34;+db):
            pass
        else:
            raise Exception(&#34;Error: could not locate custom database&#34;,
                            &#34;data0.{} in {}.&#34;.format(db, os.getcwd()))

        if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
            os.remove(&#34;data1.&#34;+db)

        self.__clear_eqpt_extra_output()

        os.environ[&#39;EQ36DA&#39;] = os.getcwd()

        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeqpt&#39;, db]

        try:
            self.__run_script_and_wait(args) # run EQPT
        except:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da
            raise Exception(
                &#34;Error: EQPT failed to run on {}.&#34;.format(&#34;data0.&#34;+db))

        if os.path.exists(&#34;data1&#34;) and os.path.isfile(&#34;data1&#34;):
            os.rename(&#34;data1&#34;, &#34;data1.&#34;+db)
        if os.path.exists(&#34;output&#34;) and os.path.isfile(&#34;output&#34;):
            os.rename(&#34;output&#34;, &#34;eqpt_log.txt&#34;)
        if os.path.exists(&#34;data1f&#34;) and os.path.isfile(&#34;data1f&#34;):
            os.rename(&#34;data1f&#34;, &#34;data1f.txt&#34;)
        if os.path.exists(&#34;slist&#34;) and os.path.isfile(&#34;slist&#34;):
            os.rename(&#34;slist&#34;, &#34;slist.txt&#34;)

        if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
            if self.verbose &gt; 0:
                print(&#34;Successfully created a data1.&#34;+db+&#34; from data0.&#34;+db)
        else:
            msg = (&#34;EQPT could not create data1.&#34;+db+&#34; from &#34;
                   &#34;data0.&#34;+db+&#34;. Check eqpt_log.txt for details.&#34;)
            raise Exception(msg)

        if not extra_eqpt_output:
            self.__clear_eqpt_extra_output()

        os.environ[&#39;EQ36DA&#39;] = self.eq36da  # reset default EQ36 db path

        
    def runeq3(self, filename_3i, db,
               samplename=None,
               path_3i=os.getcwd(),
               path_3o=os.getcwd(),
               path_3p=os.getcwd()):
        
        &#34;&#34;&#34;
        Call EQ3 on a .3i input file.
        
        Parameters
        ----------
        filename_3i : str
            Name of 3i input file.
        
        db : str
            Three letter code of database.
        
        path_3i : path str, default current working directory
            Path of .3i input files.
            
        path_3o : path str, default current working directory
            Path of .3o output files.
        
        path_3p : path str, default current working directory
            Path of .3p pickup files.
        &#34;&#34;&#34;

        # get current working dir
        cwd = os.getcwd()
        
        if samplename == None:
            samplename = filename_3i[:-3]
        
        if self.verbose &gt; 0:
            print(&#39;Using &#39; + db + &#39; to speciate &#39; + samplename)
        os.chdir(path_3i)  # step into 3i folder
        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq3&#39;, db, filename_3i]

        self.__run_script_and_wait(args) # run EQ3

        # restore working dir
        os.chdir(cwd)

        filename_3o = filename_3i[:-1] + &#39;o&#39;
        filename_3p = filename_3i[:-1] + &#39;p&#39;

        try:
            # rename output
            os.rename(path_3i + &#39;/output&#39;, path_3i + &#34;/&#34; + filename_3o)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: EQ3 failed to produce output for &#39; + filename_3i)

        try:
            # move output
            shutil.move(path_3i + &#34;/&#34; + filename_3o,
                        path_3o + &#34;/&#34; + filename_3o)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: Could not move&#39;, filename_3o, &#34;to&#34;, path_3o)

        try:
            # rename pickup
            os.rename(path_3i + &#39;/pickup&#39;, path_3i + &#34;/&#34; + filename_3p)
            move_pickup = True
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: EQ3 failed to produce a pickup file for &#39; + filename_3i)
            move_pickup = False
        
        if move_pickup:
            try:
                # move pickup
                shutil.move(path_3i + &#34;/&#34; + filename_3p,
                            path_3p + &#34;/&#34; + filename_3p)
            except:
                if self.verbose &gt; 0:
                    print(&#39;Error: Could not move&#39;, filename_3p, &#34;to&#34;, path_3p)

                    
    def runeq6(self, filename_6i, db,
               samplename=None,
               path_6i=os.getcwd(),
               path_6o=os.getcwd(),
               path_6p=os.getcwd()):
        
        &#34;&#34;&#34;
        Call EQ6 on a .6i input file.
        
        Parameters
        ----------
        filename_6i : str
            Name of 6i input file.
        
        db : str
            Three letter code of database.
        
        path_6i : path str, default current working directory
            Path of .6i input files.
            
        path_6o : path str, default current working directory
            Path of .6o output files.
        
        path_6p : path str, default current working directory
            Path of .6p pickup files.
        &#34;&#34;&#34;

        # get current working dir
        cwd = os.getcwd()
        
        if samplename == None:
            samplename = filename_6i[:-3]
        
        if self.verbose &gt; 0:
            print(&#39;Using &#39; + db + &#39; to speciate &#39; + samplename)
        os.chdir(path_6i)  # step into 6i folder
        args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq6&#39;, db, filename_6i]

        self.__run_script_and_wait(args) # run EQ6

        # restore working dir
        os.chdir(cwd)

        filename_6o = filename_6i[:-1] + &#39;o&#39;
        filename_6p = filename_6i[:-1] + &#39;p&#39;

        try:
            # rename output
            os.rename(path_6i + &#39;/output&#39;, path_6i + &#34;/&#34; + filename_6o)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: EQ6 failed to produce output for &#39; + filename_6i)

        try:
            # move output
            shutil.move(path_6i + &#34;/&#34; + filename_6o,
                        path_6o + &#34;/&#34; + filename_6o)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: Could not move&#39;, filename_6o, &#34;to&#34;, path_6o)

        try:
            # rename pickup
            os.rename(path_6i + &#39;/pickup&#39;, path_6i + &#34;/&#34; + filename_6p)
            move_pickup = True
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: EQ6 failed to produce a pickup file for &#39; + filename_6i)
            move_pickup = False
        
        if move_pickup:
            try:
                # move pickup
                shutil.move(path_6i + &#34;/&#34; + filename_6p,
                            path_6p + &#34;/&#34; + filename_6p)
            except:
                if self.verbose &gt; 0:
                    print(&#39;Error: Could not move&#39;, filename_6p, &#34;to&#34;, path_6p)
                    
                    
    def __mk_check_del_directory(self, path):
        
        &#34;&#34;&#34;
        Checks for the dir being created. If it is already present, delete it
        before recreating it.
        &#34;&#34;&#34;
        
        if not os.path.exists(path):
            os.makedirs(path)
        else:
            shutil.rmtree(path)
            os.makedirs(path)

            
    def __read_inputs(self, file_type, location):
        
        &#34;&#34;&#34;
        Finds all files of a filetype in all downstream folders.
        &#34;&#34;&#34;
        
        file_name = []  # file names
        file_list = []  # file names with paths
        for root, dirs, files in os.walk(location):
            for file in files:
                if file.endswith(file_type):
                    if &#34;-checkpoint&#34; not in file:
                        file_name.append(file)
                        file_list.append(os.path.join(root, file))
        return file_name, file_list

    
    def __run_script_and_wait(self, args):
        
        &#34;&#34;&#34;
        Runs shell commands.
        &#34;&#34;&#34;
        
        with open(os.devnull, &#39;w&#39;) as fp:  # devnull supresses written output
            Popen(args, stdout=fp).wait()

            
    def _delete_rxn_folders(self):
        
        &#34;&#34;&#34;
        Deletes folders storing raw EQ3/6 input and output.
        &#34;&#34;&#34;
        
        if os.path.exists(&#39;rxn_3i&#39;) and os.path.isdir(&#39;rxn_3i&#39;):
            shutil.rmtree(&#39;rxn_3i&#39;)
        if os.path.exists(&#39;rxn_3o&#39;) and os.path.isdir(&#39;rxn_3o&#39;):
            shutil.rmtree(&#39;rxn_3o&#39;)
        if os.path.exists(&#39;rxn_3p&#39;) and os.path.isdir(&#39;rxn_3p&#39;):
            shutil.rmtree(&#39;rxn_3p&#39;)
        if os.path.exists(&#39;rxn_6i&#39;) and os.path.isdir(&#39;rxn_6i&#39;):
            shutil.rmtree(&#39;rxn_6i&#39;)
        if os.path.exists(&#39;rxn_6o&#39;) and os.path.isdir(&#39;rxn_6o&#39;):
            shutil.rmtree(&#39;rxn_6o&#39;)
        if os.path.exists(&#39;rxn_6p&#39;) and os.path.isdir(&#39;rxn_6p&#39;):
            shutil.rmtree(&#39;rxn_6p&#39;)
            

    def speciate(self,
                 input_filename,
                 db=&#34;wrm&#34;,
                 redox_flag=&#34;logfO2&#34;,
                 redox_aux=&#34;Fe+3&#34;,
                 default_logfO2=-6,
                 exclude=[],
                 suppress=[],
                 charge_balance_on=&#34;none&#34;,
                 suppress_missing=True,
                 verbose=1,
                 report_filename=None,
                 get_aq_dist=True,
                 aq_dist_type=&#34;log_activity&#34;,
                 get_mass_contribution=True,
                 mass_contribution_other=True,
                 get_mineral_sat=True,
                 mineral_sat_type=&#34;affinity&#34;,
                 get_redox=True,
                 redox_type=&#34;Eh&#34;,
                 get_ion_activity_ratios=True,
                 get_fugacity=True,
                 get_affinity_energy=False,
                 rxn_filename=None,
                 not_limiting=[&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;],
                 get_charge_balance=True,
                 custom_db=False,
                 extra_eqpt_output=False,
                 batch_3o_filename=None,
                 delete_generated_folders=False):
        
        &#34;&#34;&#34;
        Calculate the equilibrium distribution of chemical species in solution.
        Additionally, calculate chemical affinities and energy supplies for
        user-specified reactions.
        
        Parameters
        ----------
        input_filename : str
            User-supplied utf8-encoded comma separated value (csv) file
            containing sample data intended for speciation. The file must
            follow this format:
            
            - the first row is a header row that must contain the names of the
              species to be included in the speciation calculation. There
              cannot be duplicate headers.
            - the second row must contain subheaders for each species in the
              header row. These subheaders must be taken from the following:
              
                    degC
                    ppm
                    ppb
                    Suppressed
                    Molality
                    Molarity
                    mg/L
                    mg/kg.sol
                    Alk., eq/kg.H2O
                    Alk., eq/L
                    Alk., eq/kg.sol
                    Alk., mg/L CaCO3
                    Alk., mg/L HCO3-
                    Log activity
                    Log act combo
                    Log mean act
                    pX
                    pH
                    pHCl
                    pmH
                    pmX
                    Hetero. equil.
                    Homo. equil.
                    Make non-basis
                    
            - &#39;Temperature&#39; must be included as a header, with &#39;degC&#39; as its
              subheader.
            - The first column must contain sample names. There cannot be
              duplicate sample names.
        
        db : three letter str, default &#34;wrm&#34;
            Three letter file extension for the desired thermodynamic database.
            If `custom_db` is False, this database must be named data1.xyz
            (where xyz is your desired three letter extension) and located
            in the EQ3/6 &#39;EQ36DA&#39; path. Otherwise, the database must be named
            data0.xyz and located in your current working directory. Note that
            data1 files are already compiled by EQPT, while data0 files will be
            automatically compiled for you if `custom_db` is True.
        
        redox_flag : str, default &#34;O2(g)&#34;
            Determines which column in the sample input file sets the overall
            redox state of the samples. Options for redox_flag include &#39;O2(g)&#39;,
            &#39;pe&#39;, &#39;Eh&#39;, &#39;logfO2&#39;, and &#39;redox aux&#39;. The code will search your
            sample spreadsheet file (see `filename`) for a column corresponding
            to the option you chose:
            
            * &#39;O2(g)&#39; with a valid subheader for a gas
            * &#39;pe&#39; with subheader pe
            * &#39;Eh&#39; with subheader volts
            * &#39;logfO2&#39; with subheader logfO2
            * &#39;redox aux&#39; will search for a column corresponding to the
              auxilliary basis species selected to form a redox couple with its
              linked strict basis species (see `redox_aux`). For example, the
              redox couple Fe+2/Fe+3 would require a column named Fe+3
            
            If an appropriate header or redox data cannot be found to define
            redox state, `default_logfO2` is used to set sample logfO2.
            
            There is a special case where dissolved oxygen can be used to impose
            sample redox state if `redox_flag` is set to logfO2 and a column named
            logfO2 does not appear in your sample spreadsheet. If there is a
            column corresponding to dissolved oxygen measurements, logfO2 is
            calculated from the equilibrium reaction O2(aq) = O2(g) at the
            temperature and pressure of the sample using the revised Helgeson-
            Kirkham-Flowers (HKF) equation of state (JC Tanger IV and HC
            Helgeson, Am. J. Sci., 1988, 288, 19).
        
        redox_aux : default &#34;Fe+3&#34;, optional
            Ignored unless `redox_flag` equals 1. Name of the auxilliary species
            whose reaction links it to a basis species (or another auxilliary
            species) such that they form a redox couple that controls sample
            fO2. For instance, Fe+3 is linked to Fe+2 in many supporting data
            files, so selecting `redox_flag` = 1 and `redox_aux` = &#34;Fe+3&#34; will
            set sample fO2 based on the Fe+2/Fe+3 redox couple.
        
        default_logfO2 : float, default -6
            Default value for sample logfO2 in case redox data cannot be found
            in the user-supplied sample spreadsheet.
        
        exclude : list of str, default []
            Names of columns in the user-supplied sample spreadsheet that should
            not be considered aqueous species. Useful for excluding columns
            containing sample metatadata, such as &#34;Year&#34; and &#34;Location&#34;.
            
        suppress : list of str, default []
            Names of chemical species that will be prevented from forming in the
            speciation calculation.
            
        charge_balance_on : str, default &#34;none&#34;
            If &#34;none&#34;, will not balance electrical charge between cations and
            anions in the speciation calculation. If a name of a species is
            supplied instead, the activity of that species will be allowed to
            change until charge balance is obtained. For example,
            charge_balance_on = &#34;H+&#34; will calculate what pH a sample must have
            to have zero net charge.
        
        suppress_missing : bool, default True
            Suppress the formation of an aqueous species if it is missing a
            value in the user-supplied sample spreadsheet?
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
            
        report_filename : str, optional
            Name of the comma separated values (csv) report file generated when
            the calculation is complete. If this argument is not defined, a
            report file is not generated.
            
        get_aq_dist : bool, default True
            Calculate distributions of aqueous species?
        
        aq_dist_type : str, default &#34;log_activity&#34;
            Desired units of measurement for reported distributions of aqueous
            species. Can be &#34;molality&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, or
            &#34;log_activity&#34;. Ignored if `get_aq_dist` is False.
        
        get_mass_contribution : bool, default True
            Calculate basis species contributions to mass balance of aqueous
            species?
        
        mass_contribution_other : bool, default True
            Include an &#34;other&#34; species for the sake of summing percents of basis
            species contributions to 100%? Ignored if `get_mass_contribution` is
            False.
        
        get_mineral_sat : bool, default True
            Calculate saturation states of pure solids?
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Desired units of measurement for reported saturation states of pure
            solids. Can be &#34;logQoverK&#34; or &#34;affinity&#34;. Ignored if
            `get_mineral_sat` is False.
        
        get_redox : bool, default True
            Calculate potentials of redox couples?
            
        redox_type : str, default &#34;Eh&#34;
            Desired units of measurement for reported redox potentials. Can be
            &#34;Eh&#34;, &#34;pe&#34;, &#34;logfO2&#34;, or &#34;Ah&#34;. Ignored if `get_redox` is False.
        
        get_ion_activity_ratios : bool, default True
            Calculate ion/H+ activity ratios and neutral species activities?
        
        get_fugacity : bool, default True
            Calculate gas fugacities?
        
        get_affinity_energy : bool, default False
            Calculate affinities and energy supplies of reactions listed in a
            separate user-supplied file?
        
        rxn_filename : str, optional
            Name of .txt file containing reactions used to calculate affinities
            and energy supplies. Ignored if `get_affinity_energy` is False.
        
        not_limiting : list, default [&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;]
            List containing names of species that are not considered limiting
            when calculating energy supplies. Ignored if `get_affinity_energy`
            is False.
        
        get_charge_balance : bool, default True
            Calculate charge balance and ionic strength?
            
        custom_db : bool, default False
            Is the database defined by `db` a custom user-supplied database? If
            this is set to True, searches for a data0.xyz file in the current
            working directory, where &#39;xyz&#39; corresponds to the three letter code
            assigned to `db`. This data0 file is automatically converted into a
            machine-readable file called data1 by software called EQPT. This
            data1 file is then used in speciation calculations.
        
        extra_eqpt_output : bool, default False
            Keep additional output files created by EQPT (see `custom_db`)?
            Ignored if `custom_db` is False.
        
        batch_3o_filename : str, optional
            Name of rds (R object) file exported after the speciation
            calculation? No file will be generated if this argument is not
            defined.
            
        delete_generated_folders : bool, default False
            Delete the &#39;rxn_3i&#39;, &#39;rxn_3o&#39;, and &#39;rxn_3p&#39; folders containing raw
            EQ3NR input, output, and pickup files once the speciation
            calculation is complete?
        
        Returns
        -------
        speciation : object of class Speciation
            Contains the results of the speciation calculation.
        
        &#34;&#34;&#34;
        
        self.verbose = verbose
        
        # check input sample file for errors
        self._check_sample_input_file(input_filename, exclude, db, custom_db,
                                      charge_balance_on, suppress_missing)
        
        if redox_flag == &#34;O2(g)&#34; or redox_flag == -3:
            redox_flag = -3
        elif redox_flag == &#34;pe&#34; or redox_flag == -2:
            redox_flag = -2
        elif redox_flag == &#34;Eh&#34; or redox_flag == -1:
            redox_flag = -1
        elif redox_flag == &#34;logfO2&#34; or redox_flag == 0:
            redox_flag = 0
        elif redox_flag == &#34;redox aux&#34; or redox_flag == 1:
            redox_flag = 1
        else:
            raise Exception(&#34;Unrecognized redox flag. Valid options are &#39;O2(g)&#39;&#34;
                            &#34;, &#39;pe&#39;, &#39;Eh&#39;, &#39;logfO2&#39;, &#39;redox aux&#39;&#34;)
            
        # handle batch_3o naming
        if batch_3o_filename != None:
            if &#34;.rds&#34; in batch_3o_filename[-4:]:
                batch_3o_filename = batch_3o_filename
            else:
                batch_3o_filename = &#34;batch_3o_{}.rds&#34;.format(db)
        else:
            batch_3o_filename = ro.r(&#34;NULL&#34;)

        if custom_db:
            # EQ3/6 cannot handle spaces in the &#39;EQ36DA&#39; path name.
            if &#34; &#34; in os.getcwd():
                msg = (&#34;Error: the path to the custom database &#34;
                    &#34;cannot contain spaces. The current path &#34;
                    &#34;is: [ &#34; + os.getcwd() + &#34; ]. Remove or &#34;
                    &#34;replace spaces in folder names for this &#34;
                    &#34;feature. Example: [ &#34; + os.getcwd().replace(&#34; &#34;, &#34;-&#34;) + &#34; ].&#34;)
                raise Exception(msg)

            self.runeqpt(db, extra_eqpt_output)
            os.environ[&#39;EQ36DA&#39;] = os.getcwd()
            
            data0_path = &#34;data0.&#34; + db
            
        else:
            data0_path = self.eq36da + &#34;/data0.&#34; + db
            
        if os.path.exists(data0_path) and os.path.isfile(data0_path):
            with open(data0_path) as data0:
                data0_lines = data0.readlines()
                start_index = [i+1 for i, s in enumerate(data0_lines) if s == &#39;temperatures\n&#39;]
                end_index = [i for i, s in enumerate(data0_lines) if s == &#39;debye huckel a (adh)\n&#39;]
                db_grids_unformatted = [i.split(&#34;pressures&#34;)[0] for i in data0_lines[start_index[0]:end_index[0]]]
                db_grids = [&#34; &#34;.join(i.split()) for i in db_grids_unformatted if i != &#39;&#39;]
                grid_temp = db_grids[0] + &#34; &#34; + db_grids[1]
                grid_press = db_grids[2] + &#34; &#34; + db_grids[3]
                grid_temp = grid_temp.split(&#34; &#34;)
                grid_press = grid_press.split(&#34; &#34;)
                try:
                    water_model = data0_lines[1].split(&#34;model: &#34;)[1] # extract water model from the second line of data0 file
                    water_model = water_model.replace(&#34;\n&#34;, &#34;&#34;)
                except:
                    water_model = &#34;SUPCRT92&#34;
#                     print(&#34;Water model could not be referenced from {}&#34;.format(data0_path)+&#34;&#34;
#                           &#34;. Defaulting to SUPCRT92 water model...&#34;)
                
                if(water_model not in [&#34;SUPCRT92&#34;, &#34;IAPWS95&#34;, &#34;DEW&#34;]):
                    water_model = &#34;SUPCRT92&#34; # the default for EQ3/6
                    print(&#34;Water model given in {}&#34;.format(data0_path)+&#34; was not &#34;
                          &#34;recognized. Defaulting to SUPCRT92 water model...&#34;)
            
        else: # if a data0 file can&#39;t be found, assume default water model, 0-350 C and PSAT
            water_model = &#34;SUPCRT92&#34;
            grid_temp = [&#34;0.0100&#34;, &#34;50.0000&#34;, &#34;100.0000&#34;, &#34;150.0000&#34;,
                         &#34;200.0000&#34;, &#34;250.0000&#34;, &#34;300.0000&#34;, &#34;350.0000&#34;]
            grid_press = [&#34;1.0000&#34;, &#34;1.0000&#34;, &#34;1.0132&#34;, &#34;4.7572&#34;,
                          &#34;15.5365&#34;, &#34;39.7365&#34;, &#34;85.8378&#34;, &#34;165.2113&#34;]

        if get_affinity_energy:
            if rxn_filename == None:
                err = (&#34;A get_affinity_energy was set to True but a reaction &#34;
                       &#34;file was not specified.&#34;)
                raise Exception(err)
            elif self.__file_exists(rxn_filename, &#39;.txt&#39;):
                pass
        else:
            rxn_filename = &#34;&#34;
            
        # preprocess for EQ3 using R scripts
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_prescript = pkg_resources.resource_string(
                __name__, &#39;preprocess_for_EQ3.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_prescript)
            df_input_processed = ro.r.preprocess(input_filename=input_filename,
                                                 exclude=convert_to_RVector(
                                                     exclude),
                                                 redox_flag=redox_flag,
                                                 redox_aux=redox_aux,
                                                 default_logfO2=default_logfO2,
                                                 charge_balance_on=charge_balance_on,
                                                 suppress_missing=suppress_missing,
                                                 suppress=convert_to_RVector(
                                                     suppress),
                                                 water_model=water_model,
                                                 grid_temp=convert_to_RVector(grid_temp),
                                                 grid_press=convert_to_RVector(grid_press),
                                                 verbose=self.verbose)

        for warning in w:
            print(warning.message)

        self.df_input_processed = pandas2ri.ri2py_dataframe(df_input_processed)

        # run EQ3 on each input file
        cwd = os.getcwd()

        self.__mk_check_del_directory(&#39;rxn_3o&#39;)
        self.__mk_check_del_directory(&#39;rxn_3p&#39;)
        files_3i, files_3i_paths = self.__read_inputs(&#39;3i&#39;, &#39;rxn_3i&#39;)

        input_dir = cwd + &#34;/rxn_3i/&#34;
        output_dir = cwd + &#34;/rxn_3o/&#34;
        pickup_dir = cwd + &#34;/rxn_3p/&#34;
        
        for file in files_3i:
            samplename = self.df_input_processed.loc[file[:-3], &#34;Sample&#34;]
            self.runeq3(filename_3i=file, db=db, samplename=samplename,
                        path_3i=input_dir, path_3o=output_dir,
                        path_3p=pickup_dir)

        if custom_db:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da

        files_3o = [file+&#34;.3o&#34; for file in self.df_input_processed.index]
        
        df_input_processed_names = convert_to_RVector(list(self.df_input_processed.columns))
        
        # mine output
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_3o_mine = pkg_resources.resource_string(
                __name__, &#39;3o_mine.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_3o_mine)
            batch_3o = ro.r.main_3o_mine(
                files_3o=convert_to_RVector(files_3o),
                input_filename=input_filename,
                rxn_filename=rxn_filename,
                get_aq_dist=get_aq_dist,
                aq_dist_type=aq_dist_type,
                get_mass_contribution=get_mass_contribution,
                mass_contribution_other=mass_contribution_other,
                get_mineral_sat=get_mineral_sat,
                mineral_sat_type=mineral_sat_type,
                get_redox=get_redox,
                redox_type=redox_type,
                get_charge_balance=get_charge_balance,
                get_ion_activity_ratios=get_ion_activity_ratios,
                get_fugacity=get_fugacity,
                get_affinity_energy=get_affinity_energy,
                not_limiting=convert_to_RVector(not_limiting),
                batch_3o_filename=batch_3o_filename,
                df_input_processed=pandas2ri.py2ri(self.df_input_processed),
                # Needed for keeping symbols in column names after porting
                #   df_input_processed in the line above. Some kind of check.names
                #   option for pandas2ri.py2ri would be nice. Workaround:
                df_input_processed_names=df_input_processed_names,
                verbose=self.verbose,
            )
        for warning in w:
            print(warning.message)
        
        if get_mass_contribution:
            mass_contribution = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;mass_contribution&#39;))
        df_report = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;report&#39;))
        df_input = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;input&#39;))
        report_divs = batch_3o.rx2(&#39;report_divs&#39;)

        input_cols = list(report_divs.rx2(&#39;input&#39;))
        df_input = df_report[input_cols]

        # handle headers and subheaders of input section
        headers = [col.split(&#34;_&#34;)[0] for col in list(df_input.columns)]
        headers = [&#34;pH&#34; if header == &#34;H+&#34; else header for header in headers]
        headers = [header+&#34;_(input)&#34; if header not in [&#34;Temperature&#34;, &#34;logfO2&#34;]+exclude else header for header in headers]
        report_divs[0] = convert_to_RVector(headers) # modify headers in the &#39;input&#39; section, report_divs[0]
        subheaders = [subheader[1] if len(subheader) &gt; 1 else &#34;&#34; for subheader in [
            col.split(&#34;_&#34;) for col in list(df_input.columns)]]
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_input.columns = multicolumns

        df_join = df_input

        if get_aq_dist:
            aq_distribution_cols = list(report_divs.rx2(&#39;aq_distribution&#39;))
            df_aq_distribution = df_report[aq_distribution_cols]
            df_aq_distribution = df_aq_distribution.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # create a pH column from H+
            df_aq_distribution[&#34;pH&#34;] = -df_aq_distribution[&#34;H+&#34;]
            
            # handle headers of aq_distribution section
            headers = df_aq_distribution.columns
            subheaders = [aq_dist_type]*(len(headers)-1) # -1 because the last column will have subheader pH (see next line)
            subheaders = subheaders + [&#34;pH&#34;]
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_aq_distribution.columns = multicolumns
            
            # ensure final pH column is included in report_divs aq_distribution section
            aq_dist_indx = report_divs.names.index(&#34;aq_distribution&#34;)
            report_divs[aq_dist_indx] = convert_to_RVector(list(headers))
            
            df_join = df_join.join(df_aq_distribution)

        if get_mineral_sat:
            mineral_sat_cols = list(report_divs.rx2(&#39;mineral_sat&#39;))
            df_mineral_sat = df_report[mineral_sat_cols]
            df_mineral_sat = df_mineral_sat.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_mineral_sat section
            if mineral_sat_type == &#34;affinity&#34;:
                mineral_sat_unit = &#34;affinity_kcal&#34;
            elif mineral_sat_type == &#34;logQoverK&#34;:
                mineral_sat_unit = &#34;logQ/K&#34;
            else:
                raise Exception(
                    &#34;mineral_sat_type must be either &#39;affinity&#39; or &#39;logQoverK&#39;&#34;)

            headers = df_mineral_sat.columns
            subheaders = [mineral_sat_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_mineral_sat.columns = multicolumns
            df_join = df_join.join(df_mineral_sat)

        if get_redox:
            redox_cols = list(report_divs.rx2(&#39;redox&#39;))
            df_redox = df_report[redox_cols]
            df_redox = df_redox.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_redox section
            if redox_type == &#34;Eh&#34;:
                redox_unit = &#34;Eh_volts&#34;
            elif redox_type == &#34;pe&#34;:
                redox_unit = &#34;pe&#34;
            elif redox_type == &#34;logfO2&#34;:
                redox_unit = &#34;logfO2&#34;
            elif redox_type == &#34;Ah&#34;:
                redox_unit = &#34;Ah_kcal&#34;
            else:
                raise Exception(
                    &#34;redox_type must be either &#39;Eh&#39;, &#39;pe&#39;, &#39;logfO2&#39;, or &#39;Ah&#39;&#34;)

            headers = df_redox.columns
            subheaders = [redox_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_redox.columns = multicolumns
            df_join = df_join.join(df_redox)

        if get_charge_balance:
            charge_balance_cols = list(report_divs.rx2(&#39;charge_balance&#39;))
            df_charge_balance = df_report[charge_balance_cols]
            df_charge_balance = df_charge_balance.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_charge_balance section
            headers = df_charge_balance.columns
            subheaders = [&#34;%&#34;]*2 + [&#39;eq/kg.H2O&#39;, &#39;molality&#39;] + \
                [&#39;eq/kg.H2O&#39;]*4 + [&#39;molality&#39;]
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_charge_balance.columns = multicolumns
            df_join = df_join.join(df_charge_balance)
            
        if get_ion_activity_ratios:
            ion_activity_ratio_cols = list(report_divs.rx2(&#39;ion_activity_ratios&#39;))
            df_ion_activity_ratios = df_report[ion_activity_ratio_cols]
            df_ion_activity_ratios = df_ion_activity_ratios.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            
            # handle headers of df_ion_activity_ratios section
            headers = df_ion_activity_ratios.columns
            subheaders = [&#34;Log ion-H+ activity ratio&#34;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_ion_activity_ratios.columns = multicolumns
            df_join = df_join.join(df_ion_activity_ratios)
            
        if get_fugacity:
            fugacity_cols = list(report_divs.rx2(&#39;fugacity&#39;))
            df_fugacity = df_report[fugacity_cols]
            df_fugacity = df_fugacity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            
            # handle headers of fugacity section
            headers = df_fugacity.columns
            subheaders = [&#34;log_fugacity&#34;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_fugacity.columns = multicolumns
            df_join = df_join.join(df_fugacity)
            
        if get_affinity_energy:
            affinity_cols = list(report_divs.rx2(&#39;affinity&#39;))
            energy_cols = list(report_divs.rx2(&#39;energy&#39;))
            df_affinity = df_report[affinity_cols]
            df_energy = df_report[energy_cols]
            df_affinity = df_affinity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            df_energy = df_energy.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_affinity section
            headers = df_affinity.columns
            subheaders = [&#39;cal/mol e-&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_affinity.columns = multicolumns

            # handle headers of df_energy section
            headers = df_energy.columns
            subheaders = [&#39;cal/kg.H2O&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_energy.columns = multicolumns
            df_join = df_join.join(df_affinity)
            df_join = df_join.join(df_energy)

        out_dict = {&#39;sample_data&#39;: {},
                    &#39;report&#39;: df_join,
                    &#39;input&#39;: df_input, &#39;report_divs&#39;: report_divs}
        
        if get_mass_contribution:
            out_dict[&#39;mass_contribution&#39;] = mass_contribution

        sample_data = batch_3o.rx2(&#39;sample_data&#39;)

        # assemble sample data
        for i, sample in enumerate(sample_data):
            dict_sample_data = {
                &#34;filename&#34;: str(sample.rx2(&#39;filename&#39;)[0]),
                &#34;name&#34;: str(sample.rx2(&#39;name&#39;)[0]),
                &#34;temperature&#34;: float(sample.rx2(&#39;temperature&#39;)[0]),
                &#34;pressure&#34;: float(sample.rx2(&#39;pressure&#39;)[0]),
                &#34;logact_H2O&#34;: float(sample.rx2(&#39;logact_H2O&#39;)[0]),
                &#34;H2O_density&#34;: float(sample.rx2(&#39;H2O_density&#39;)[0]),
                &#34;H2O_molality&#34;: float(sample.rx2(&#39;H2O_molality&#39;)[0]),
                &#34;H2O_log_molality&#34;: float(sample.rx2(&#39;H2O_log_molality&#39;)[0]),
                }

            if get_aq_dist:
                sample_aq_dist = pandas2ri.ri2py_dataframe(sample.rx2(&#39;aq_distribution&#39;))
                sample_aq_dist = sample_aq_dist.apply(pd.to_numeric, errors=&#39;coerce&#39;)
                dict_sample_data.update({&#34;aq_distribution&#34;: sample_aq_dist})

            if get_mass_contribution:
                sample_mass_contribution = mass_contribution[mass_contribution[&#34;sample&#34;] == sample.rx2(&#39;name&#39;)[0]]
                dict_sample_data.update(
                    {&#34;mass_contribution&#34;: sample_mass_contribution})

            if get_mineral_sat:
                dict_sample_data.update(
                    {&#34;mineral_sat&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;mineral_sat&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                # replace sample mineral_sat entry with None if there is no mineral saturation data.
                if(len(dict_sample_data[&#39;mineral_sat&#39;].index) == 1 and dict_sample_data[&#39;mineral_sat&#39;].index[0] == &#39;None&#39;):
                    dict_sample_data[&#39;mineral_sat&#39;] = None

            if get_redox:
                dict_sample_data.update(
                    {&#34;redox&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;redox&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            if get_charge_balance:
                dict_sample_data.update({&#34;charge_balance&#34;: df_charge_balance.loc[sample.rx2(&#39;name&#39;)[0], :]})
            
            if get_ion_activity_ratios:
                try:
                    dict_sample_data.update(
                        {&#34;ion_activity_ratios&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;ion_activity_ratios&#39;))})
                except:
                    dict_sample_data[&#39;ion_activity_ratios&#39;] = None
            
            if get_fugacity:
                dict_sample_data.update(
                    {&#34;fugacity&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;fugacity&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                # replace sample fugacity entry with None if there is no fugacity data.
                if(len(dict_sample_data[&#39;fugacity&#39;].index) == 1 and dict_sample_data[&#39;fugacity&#39;].index[0] == &#39;None&#39;):
                    dict_sample_data[&#39;fugacity&#39;] = None
                else:
                    dict_sample_data[&#34;fugacity&#34;][&#34;fugacity&#34;] = 10**dict_sample_data[&#34;fugacity&#34;][&#34;log_fugacity&#34;]
            
            if get_affinity_energy:
                dict_sample_data.update({&#34;affinity_energy_raw&#34;: pandas2ri.ri2py_dataframe(
                    sample.rx2(&#39;affinity_energy_raw&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                dict_sample_data.update(
                    {&#34;affinity_energy&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;affinity_energy&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            out_dict[&#34;sample_data&#34;].update(
                {sample_data.names[i]: dict_sample_data})

        out_dict.update({&#34;batch_3o&#34;: batch_3o})
        
        out_dict.update({&#34;water_model&#34;:water_model, &#34;grid_temp&#34;:grid_temp, &#34;grid_press&#34;:grid_press})
        
        speciation = Speciation(out_dict)

        if report_filename != None:
            if &#34;.csv&#34; in report_filename[-4:]:
                out_dict[&#34;report&#34;].to_csv(report_filename)
            else:
                out_dict[&#34;report&#34;].to_csv(report_filename+&#34;.csv&#34;)

        if delete_generated_folders:
            self._delete_rxn_folders()
        
        if self.verbose &gt; 0:
            print(&#34;Finished!&#34;)
        
        return speciation


    def create_data0(self,
                     db,
                     filename,
                     filename_ss=None,
                     data0_formula_ox_name=None,
                     suppress_redox=[],
                     water_model=&#34;SUPCRT92&#34;,
                     exceed_Ttr=True,
                     grid_temps=[0.0100, 50.0000, 100.0000, 150.0000,
                                 200.0000, 250.0000, 300.0000, 350.0000],
                     grid_press=&#34;Psat&#34;,
                     infer_formula_ox=False,
                     generate_template=True,
                     template_name=None,
                     template_type=&#34;strict&#34;,
                     verbose=1):
        &#34;&#34;&#34;
        Create a data0 file from a custom thermodynamic dataset.
        
        Parameters
        ----------
        db : str
            Desired three letter code of data0 output.
            
        filename : str
            Name of csv file containing thermodynamic data in the OBIGT format.
            
        filename_ss : str, optional
            Name of file containing solid solution parameters.
        
        data0_formula_ox_name : str, optional
            Name of supplementary file containing data0 parameters and inferred
            formula oxidation states. Ignored if `infer_formula_ox` is False.
            See `infer_formula_ox` for more detail.
        
        suppress_redox : list of str, default []
            Suppress equilibrium between oxidation states of listed elements
            (Cl, H, and O cannot be included).

        water_model : str, default &#34;SUPCRT92&#34;
            This is an experimental feature that is not yet fully supported.
            Desired water model. Can be either &#34;SUPCRT92&#34;, &#34;IAPWS95&#34;, or &#34;DEW&#34;.
            These models are described here: http://chnosz.net/manual/water.html

        exceed_Ttr : bool, default True
            Calculate Gibbs energies of mineral phases and other species
            beyond their transition temperatures?

        grid_temps : list of eight float, default [0.0100, 50.0000, 100.0000, 150.0000, 200.0000, 250.0000, 300.0000, 350.0000]
            Eight temperature values that make up the T-P grid.
        
        grid_press : list of float, default &#34;Psat&#34;
            Eight pressure values that make up the T-P grid. &#34;Psat&#34; for
            calculations along the liquid-vapor saturation curve.

        infer_formula_ox : bool, default False
            Create a supplementary file containing data0 parameters and
            inferred formula oxidation states? This option is useful for
            creating as many entries in the formula_ox column when creating a
            new supplementary file. Note that compounds like DySO4+ result in
            blank entries in formula_ox because the redox states of two
            elements, Dy and S, would have to be estimated together; S has many
            oxidation states and Dy&#39;s oxidation states are not hard-coded.
        
        generate_template : bool, default True
            Generate a CSV sample input template customized to this data0?
            Columns include &#39;Sample&#39;, &#39;Temperature&#39;, &#39;logfO2&#39;, and all strict
            basis species.
        
        template_name : str, optional
            Name of the sample input template file generated. If no name is
            supplied, defaults to &#39;sample_template_xyz.csv&#39;, where &#39;xyz&#39; is
            the three letter code given to `db`. Ignored if `generate_template`
            is False.
        
        template_type : str, either &#39;strict&#39;, &#39;all basis&#39;, or &#39;all species&#39;
            Determines which columns are written to the sample template.
            - &#39;strict&#39; includes strict basis species
            - &#39;all basis&#39; includes strict and auxiliary basis species
            - &#39;all species&#39; includes all species in the thermodynamic database
            Ignored if `generate_template` is False.
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
        &#34;&#34;&#34;
        
        # Check that thermodynamic database input files exist and are formatted
        # correctly.
        self._check_database_file(filename)
        if filename_ss != None:
            self.__file_exists(filename_ss)
        
        self.verbose = verbose
        
        if self.verbose &gt;= 1:
            print(&#34;Creating data0.{}...&#34;.format(db), flush=True)
        
        if len(grid_temps) &gt; 8 or len(grid_temps) &lt; 1:
            raise Exception(&#34;&#39;grid_temps&#39; must have eight values.&#34;)
        if isinstance(grid_press, list):
            if len(grid_press) &gt; 8 or len(grid_press) &lt; 1:
                raise Exception(&#34;&#39;grid_press&#39; must have eight values.&#34;)
        
        if sum([T &gt;= 10000 for T in grid_temps]):
            raise Exception(&#34;Grid temperatures must be below 10000 °C.&#34;)
        
        if isinstance(grid_press, list):
            if sum([P &gt;= 10000 for P in grid_press]):
                raise Exception(&#34;Grid pressures must be below 10000 bars.&#34;)
            
        if water_model == &#34;SUPCRT92&#34;:
            min_T = 0
            max_T = 2250
            min_P = 1
            max_P = 30000
        elif water_model == &#34;IAPWS95&#34;:
            min_T = 0
            max_T = 1000
            min_P = 1
            max_P = 10000
        elif water_model == &#34;DEW&#34;:
            min_T = 0
            max_T = 1000
            min_P = 1
            max_P = 60000
        else:
            raise Exception(&#34;The water model &#39;{}&#39; &#34;.format(water_model)+&#34;is not &#34;
                            &#34;recognized. Try &#39;SUPCRT92&#39;, &#39;IAPWS95&#39;, or &#39;DEW&#39;.&#34;)
        
        # check that T and P are above minimum values
        if sum([T &lt;= min_T for T in grid_temps]):
            print(&#34;WARNING: one or more temperatures in &#39;grid_temps&#39; is below &#34;
                  &#34;or equal to {} °C&#34;.format(min_T)+&#34; and is outside the valid &#34;
                  &#34;temperature range for the {} water model.&#34;.format(water_model))
        if isinstance(grid_press, list):
            if sum([P &lt; min_P for P in grid_press]):
                print(&#34;WARNING: one or more pressures in &#39;grid_press&#39; is below &#34;
                      &#34;{} bar&#34;.format(min_P)+&#34;, the minimum valid &#34;
                      &#34;pressure for the {} water model.&#34;.format(water_model))
        
        # check that T and P are below maximum values
        if sum([T &gt; max_T for T in grid_temps]):
            print(&#34;WARNING: one or more temperatures in &#39;grid_temps&#39; is above &#34;
                  &#34;{} °C&#34;.format(max_T)+&#34;, the maximum valid &#34;
                  &#34;temperature for the {} water model.&#34;.format(water_model))
        if isinstance(grid_press, list):
            if sum([P &gt; max_P for P in grid_press]):
                print(&#34;WARNING: one or more pressures in &#39;grid_press&#39; is above &#34;
                      &#34;{} bar&#34;.format(max_P)+&#34;, the maximum valid &#34;
                      &#34;pressure for the {} water model.&#34;.format(water_model))
            
        if water_model != &#34;SUPCRT92&#34;:
            print(&#34;WARNING: water models other than SUPCRT92 are not yet fully supported.&#34;)
        
        template = pkg_resources.resource_string(
            __name__, &#39;data0.min&#39;).decode(&#34;utf-8&#34;)
        grid_temps = convert_to_RVector(grid_temps)
        grid_press = convert_to_RVector(grid_press)
        suppress_redox = convert_to_RVector(suppress_redox)
        
        if filename_ss == None:
            filename_ss = ro.r(&#34;NULL&#34;)
        if data0_formula_ox_name == None:
            data0_formula_ox_name = ro.r(&#34;NULL&#34;)
        if template_name == None:
            template_name = &#34;sample_template_{}.csv&#34;.format(db)
        if template_type not in [&#39;strict&#39;, &#39;all basis&#39;, &#39;all species&#39;]:
            raise Exception(&#34;template_type {} &#34;.format(template_type)+&#34;is not&#34;
                            &#34;recognized. Try &#39;strict&#39;, &#39;all basis&#39;, or &#39;all species&#39;&#34;)

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_create_data0 = pkg_resources.resource_string(
                __name__, &#39;create_data0.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_create_data0)
            ro.r.main_create_data0(filename=filename,
                                   filename_ss=filename_ss,
                                   grid_temps=grid_temps,
                                   grid_press=grid_press,
                                   db=db,
                                   water_model=water_model,
                                   template=template,
                                   exceed_Ttr=exceed_Ttr,
                                   data0_formula_ox_name=data0_formula_ox_name,
                                   suppress_redox=suppress_redox,
                                   infer_formula_ox=infer_formula_ox,
                                   generate_template=generate_template,
                                   template_name=template_name,
                                   template_type=template_type,
                                   verbose=self.verbose)
    
        for warning in w:
            print(warning.message)
        
        if self.verbose &gt; 0:
            print(&#34;Finished creating data0.{}.&#34;.format(db))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AqEquil.AqSpeciation.AqEquil.create_data0"><code class="name flex">
<span>def <span class="ident">create_data0</span></span>(<span>self, db, filename, filename_ss=None, data0_formula_ox_name=None, suppress_redox=[], water_model='SUPCRT92', exceed_Ttr=True, grid_temps=[0.01, 50.0, 100.0, 150.0, 200.0, 250.0, 300.0, 350.0], grid_press='Psat', infer_formula_ox=False, generate_template=True, template_name=None, template_type='strict', verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a data0 file from a custom thermodynamic dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db</code></strong> :&ensp;<code>str</code></dt>
<dd>Desired three letter code of data0 output.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of csv file containing thermodynamic data in the OBIGT format.</dd>
<dt><strong><code>filename_ss</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of file containing solid solution parameters.</dd>
<dt><strong><code>data0_formula_ox_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of supplementary file containing data0 parameters and inferred
formula oxidation states. Ignored if <code>infer_formula_ox</code> is False.
See <code>infer_formula_ox</code> for more detail.</dd>
<dt><strong><code>suppress_redox</code></strong> :&ensp;<code>list</code> of <code>str</code>, default <code>[]</code></dt>
<dd>Suppress equilibrium between oxidation states of listed elements
(Cl, H, and O cannot be included).</dd>
<dt><strong><code>water_model</code></strong> :&ensp;<code>str</code>, default <code>"SUPCRT92"</code></dt>
<dd>This is an experimental feature that is not yet fully supported.
Desired water model. Can be either "SUPCRT92", "IAPWS95", or "DEW".
These models are described here: <a href="http://chnosz.net/manual/water.html">http://chnosz.net/manual/water.html</a></dd>
<dt><strong><code>exceed_Ttr</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate Gibbs energies of mineral phases and other species
beyond their transition temperatures?</dd>
<dt><strong><code>grid_temps</code></strong> :&ensp;<code>list</code> of <code>eight float</code>, default <code>[0.0100, 50.0000, 100.0000, 150.0000, 200.0000, 250.0000, 300.0000, 350.0000]</code></dt>
<dd>Eight temperature values that make up the T-P grid.</dd>
<dt><strong><code>grid_press</code></strong> :&ensp;<code>list</code> of <code>float</code>, default <code>"Psat"</code></dt>
<dd>Eight pressure values that make up the T-P grid. "Psat" for
calculations along the liquid-vapor saturation curve.</dd>
<dt><strong><code>infer_formula_ox</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Create a supplementary file containing data0 parameters and
inferred formula oxidation states? This option is useful for
creating as many entries in the formula_ox column when creating a
new supplementary file. Note that compounds like DySO4+ result in
blank entries in formula_ox because the redox states of two
elements, Dy and S, would have to be estimated together; S has many
oxidation states and Dy's oxidation states are not hard-coded.</dd>
<dt><strong><code>generate_template</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Generate a CSV sample input template customized to this data0?
Columns include 'Sample', 'Temperature', 'logfO2', and all strict
basis species.</dd>
<dt><strong><code>template_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the sample input template file generated. If no name is
supplied, defaults to 'sample_template_xyz.csv', where 'xyz' is
the three letter code given to <code>db</code>. Ignored if <code>generate_template</code>
is False.</dd>
<dt><strong><code>template_type</code></strong> :&ensp;<code>str, either 'strict', 'all basis',</code> or <code>'all species'</code></dt>
<dd>Determines which columns are written to the sample template.
- 'strict' includes strict basis species
- 'all basis' includes strict and auxiliary basis species
- 'all species' includes all species in the thermodynamic database
Ignored if <code>generate_template</code> is False.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int, 0, 1,</code> or <code>2</code>, default <code>1</code></dt>
<dd>Level determining how many messages are returned during a
calculation. 2 for all messages, 1 for errors or warnings only,
0 for silent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_data0(self,
                 db,
                 filename,
                 filename_ss=None,
                 data0_formula_ox_name=None,
                 suppress_redox=[],
                 water_model=&#34;SUPCRT92&#34;,
                 exceed_Ttr=True,
                 grid_temps=[0.0100, 50.0000, 100.0000, 150.0000,
                             200.0000, 250.0000, 300.0000, 350.0000],
                 grid_press=&#34;Psat&#34;,
                 infer_formula_ox=False,
                 generate_template=True,
                 template_name=None,
                 template_type=&#34;strict&#34;,
                 verbose=1):
    &#34;&#34;&#34;
    Create a data0 file from a custom thermodynamic dataset.
    
    Parameters
    ----------
    db : str
        Desired three letter code of data0 output.
        
    filename : str
        Name of csv file containing thermodynamic data in the OBIGT format.
        
    filename_ss : str, optional
        Name of file containing solid solution parameters.
    
    data0_formula_ox_name : str, optional
        Name of supplementary file containing data0 parameters and inferred
        formula oxidation states. Ignored if `infer_formula_ox` is False.
        See `infer_formula_ox` for more detail.
    
    suppress_redox : list of str, default []
        Suppress equilibrium between oxidation states of listed elements
        (Cl, H, and O cannot be included).

    water_model : str, default &#34;SUPCRT92&#34;
        This is an experimental feature that is not yet fully supported.
        Desired water model. Can be either &#34;SUPCRT92&#34;, &#34;IAPWS95&#34;, or &#34;DEW&#34;.
        These models are described here: http://chnosz.net/manual/water.html

    exceed_Ttr : bool, default True
        Calculate Gibbs energies of mineral phases and other species
        beyond their transition temperatures?

    grid_temps : list of eight float, default [0.0100, 50.0000, 100.0000, 150.0000, 200.0000, 250.0000, 300.0000, 350.0000]
        Eight temperature values that make up the T-P grid.
    
    grid_press : list of float, default &#34;Psat&#34;
        Eight pressure values that make up the T-P grid. &#34;Psat&#34; for
        calculations along the liquid-vapor saturation curve.

    infer_formula_ox : bool, default False
        Create a supplementary file containing data0 parameters and
        inferred formula oxidation states? This option is useful for
        creating as many entries in the formula_ox column when creating a
        new supplementary file. Note that compounds like DySO4+ result in
        blank entries in formula_ox because the redox states of two
        elements, Dy and S, would have to be estimated together; S has many
        oxidation states and Dy&#39;s oxidation states are not hard-coded.
    
    generate_template : bool, default True
        Generate a CSV sample input template customized to this data0?
        Columns include &#39;Sample&#39;, &#39;Temperature&#39;, &#39;logfO2&#39;, and all strict
        basis species.
    
    template_name : str, optional
        Name of the sample input template file generated. If no name is
        supplied, defaults to &#39;sample_template_xyz.csv&#39;, where &#39;xyz&#39; is
        the three letter code given to `db`. Ignored if `generate_template`
        is False.
    
    template_type : str, either &#39;strict&#39;, &#39;all basis&#39;, or &#39;all species&#39;
        Determines which columns are written to the sample template.
        - &#39;strict&#39; includes strict basis species
        - &#39;all basis&#39; includes strict and auxiliary basis species
        - &#39;all species&#39; includes all species in the thermodynamic database
        Ignored if `generate_template` is False.
    
    verbose : int, 0, 1, or 2, default 1
        Level determining how many messages are returned during a
        calculation. 2 for all messages, 1 for errors or warnings only,
        0 for silent.
    &#34;&#34;&#34;
    
    # Check that thermodynamic database input files exist and are formatted
    # correctly.
    self._check_database_file(filename)
    if filename_ss != None:
        self.__file_exists(filename_ss)
    
    self.verbose = verbose
    
    if self.verbose &gt;= 1:
        print(&#34;Creating data0.{}...&#34;.format(db), flush=True)
    
    if len(grid_temps) &gt; 8 or len(grid_temps) &lt; 1:
        raise Exception(&#34;&#39;grid_temps&#39; must have eight values.&#34;)
    if isinstance(grid_press, list):
        if len(grid_press) &gt; 8 or len(grid_press) &lt; 1:
            raise Exception(&#34;&#39;grid_press&#39; must have eight values.&#34;)
    
    if sum([T &gt;= 10000 for T in grid_temps]):
        raise Exception(&#34;Grid temperatures must be below 10000 °C.&#34;)
    
    if isinstance(grid_press, list):
        if sum([P &gt;= 10000 for P in grid_press]):
            raise Exception(&#34;Grid pressures must be below 10000 bars.&#34;)
        
    if water_model == &#34;SUPCRT92&#34;:
        min_T = 0
        max_T = 2250
        min_P = 1
        max_P = 30000
    elif water_model == &#34;IAPWS95&#34;:
        min_T = 0
        max_T = 1000
        min_P = 1
        max_P = 10000
    elif water_model == &#34;DEW&#34;:
        min_T = 0
        max_T = 1000
        min_P = 1
        max_P = 60000
    else:
        raise Exception(&#34;The water model &#39;{}&#39; &#34;.format(water_model)+&#34;is not &#34;
                        &#34;recognized. Try &#39;SUPCRT92&#39;, &#39;IAPWS95&#39;, or &#39;DEW&#39;.&#34;)
    
    # check that T and P are above minimum values
    if sum([T &lt;= min_T for T in grid_temps]):
        print(&#34;WARNING: one or more temperatures in &#39;grid_temps&#39; is below &#34;
              &#34;or equal to {} °C&#34;.format(min_T)+&#34; and is outside the valid &#34;
              &#34;temperature range for the {} water model.&#34;.format(water_model))
    if isinstance(grid_press, list):
        if sum([P &lt; min_P for P in grid_press]):
            print(&#34;WARNING: one or more pressures in &#39;grid_press&#39; is below &#34;
                  &#34;{} bar&#34;.format(min_P)+&#34;, the minimum valid &#34;
                  &#34;pressure for the {} water model.&#34;.format(water_model))
    
    # check that T and P are below maximum values
    if sum([T &gt; max_T for T in grid_temps]):
        print(&#34;WARNING: one or more temperatures in &#39;grid_temps&#39; is above &#34;
              &#34;{} °C&#34;.format(max_T)+&#34;, the maximum valid &#34;
              &#34;temperature for the {} water model.&#34;.format(water_model))
    if isinstance(grid_press, list):
        if sum([P &gt; max_P for P in grid_press]):
            print(&#34;WARNING: one or more pressures in &#39;grid_press&#39; is above &#34;
                  &#34;{} bar&#34;.format(max_P)+&#34;, the maximum valid &#34;
                  &#34;pressure for the {} water model.&#34;.format(water_model))
        
    if water_model != &#34;SUPCRT92&#34;:
        print(&#34;WARNING: water models other than SUPCRT92 are not yet fully supported.&#34;)
    
    template = pkg_resources.resource_string(
        __name__, &#39;data0.min&#39;).decode(&#34;utf-8&#34;)
    grid_temps = convert_to_RVector(grid_temps)
    grid_press = convert_to_RVector(grid_press)
    suppress_redox = convert_to_RVector(suppress_redox)
    
    if filename_ss == None:
        filename_ss = ro.r(&#34;NULL&#34;)
    if data0_formula_ox_name == None:
        data0_formula_ox_name = ro.r(&#34;NULL&#34;)
    if template_name == None:
        template_name = &#34;sample_template_{}.csv&#34;.format(db)
    if template_type not in [&#39;strict&#39;, &#39;all basis&#39;, &#39;all species&#39;]:
        raise Exception(&#34;template_type {} &#34;.format(template_type)+&#34;is not&#34;
                        &#34;recognized. Try &#39;strict&#39;, &#39;all basis&#39;, or &#39;all species&#39;&#34;)

    with warnings.catch_warnings(record=True) as w:
        warnings.simplefilter(&#34;always&#34;)
        r_create_data0 = pkg_resources.resource_string(
            __name__, &#39;create_data0.r&#39;).decode(&#34;utf-8&#34;)
        ro.r(r_create_data0)
        ro.r.main_create_data0(filename=filename,
                               filename_ss=filename_ss,
                               grid_temps=grid_temps,
                               grid_press=grid_press,
                               db=db,
                               water_model=water_model,
                               template=template,
                               exceed_Ttr=exceed_Ttr,
                               data0_formula_ox_name=data0_formula_ox_name,
                               suppress_redox=suppress_redox,
                               infer_formula_ox=infer_formula_ox,
                               generate_template=generate_template,
                               template_name=template_name,
                               template_type=template_type,
                               verbose=self.verbose)

    for warning in w:
        print(warning.message)
    
    if self.verbose &gt; 0:
        print(&#34;Finished creating data0.{}.&#34;.format(db))</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.AqEquil.runeq3"><code class="name flex">
<span>def <span class="ident">runeq3</span></span>(<span>self, filename_3i, db, samplename=None, path_3i='C:\\Users\\gmboy\\Desktop\\aqequil', path_3o='C:\\Users\\gmboy\\Desktop\\aqequil', path_3p='C:\\Users\\gmboy\\Desktop\\aqequil')</span>
</code></dt>
<dd>
<div class="desc"><p>Call EQ3 on a .3i input file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename_3i</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of 3i input file.</dd>
<dt><strong><code>db</code></strong> :&ensp;<code>str</code></dt>
<dd>Three letter code of database.</dd>
<dt><strong><code>path_3i</code></strong> :&ensp;<code>path str</code>, default <code>current working directory</code></dt>
<dd>Path of .3i input files.</dd>
<dt><strong><code>path_3o</code></strong> :&ensp;<code>path str</code>, default <code>current working directory</code></dt>
<dd>Path of .3o output files.</dd>
<dt><strong><code>path_3p</code></strong> :&ensp;<code>path str</code>, default <code>current working directory</code></dt>
<dd>Path of .3p pickup files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runeq3(self, filename_3i, db,
           samplename=None,
           path_3i=os.getcwd(),
           path_3o=os.getcwd(),
           path_3p=os.getcwd()):
    
    &#34;&#34;&#34;
    Call EQ3 on a .3i input file.
    
    Parameters
    ----------
    filename_3i : str
        Name of 3i input file.
    
    db : str
        Three letter code of database.
    
    path_3i : path str, default current working directory
        Path of .3i input files.
        
    path_3o : path str, default current working directory
        Path of .3o output files.
    
    path_3p : path str, default current working directory
        Path of .3p pickup files.
    &#34;&#34;&#34;

    # get current working dir
    cwd = os.getcwd()
    
    if samplename == None:
        samplename = filename_3i[:-3]
    
    if self.verbose &gt; 0:
        print(&#39;Using &#39; + db + &#39; to speciate &#39; + samplename)
    os.chdir(path_3i)  # step into 3i folder
    args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq3&#39;, db, filename_3i]

    self.__run_script_and_wait(args) # run EQ3

    # restore working dir
    os.chdir(cwd)

    filename_3o = filename_3i[:-1] + &#39;o&#39;
    filename_3p = filename_3i[:-1] + &#39;p&#39;

    try:
        # rename output
        os.rename(path_3i + &#39;/output&#39;, path_3i + &#34;/&#34; + filename_3o)
    except:
        if self.verbose &gt; 0:
            print(&#39;Error: EQ3 failed to produce output for &#39; + filename_3i)

    try:
        # move output
        shutil.move(path_3i + &#34;/&#34; + filename_3o,
                    path_3o + &#34;/&#34; + filename_3o)
    except:
        if self.verbose &gt; 0:
            print(&#39;Error: Could not move&#39;, filename_3o, &#34;to&#34;, path_3o)

    try:
        # rename pickup
        os.rename(path_3i + &#39;/pickup&#39;, path_3i + &#34;/&#34; + filename_3p)
        move_pickup = True
    except:
        if self.verbose &gt; 0:
            print(&#39;Error: EQ3 failed to produce a pickup file for &#39; + filename_3i)
        move_pickup = False
    
    if move_pickup:
        try:
            # move pickup
            shutil.move(path_3i + &#34;/&#34; + filename_3p,
                        path_3p + &#34;/&#34; + filename_3p)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: Could not move&#39;, filename_3p, &#34;to&#34;, path_3p)</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.AqEquil.runeq6"><code class="name flex">
<span>def <span class="ident">runeq6</span></span>(<span>self, filename_6i, db, samplename=None, path_6i='C:\\Users\\gmboy\\Desktop\\aqequil', path_6o='C:\\Users\\gmboy\\Desktop\\aqequil', path_6p='C:\\Users\\gmboy\\Desktop\\aqequil')</span>
</code></dt>
<dd>
<div class="desc"><p>Call EQ6 on a .6i input file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename_6i</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of 6i input file.</dd>
<dt><strong><code>db</code></strong> :&ensp;<code>str</code></dt>
<dd>Three letter code of database.</dd>
<dt><strong><code>path_6i</code></strong> :&ensp;<code>path str</code>, default <code>current working directory</code></dt>
<dd>Path of .6i input files.</dd>
<dt><strong><code>path_6o</code></strong> :&ensp;<code>path str</code>, default <code>current working directory</code></dt>
<dd>Path of .6o output files.</dd>
<dt><strong><code>path_6p</code></strong> :&ensp;<code>path str</code>, default <code>current working directory</code></dt>
<dd>Path of .6p pickup files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runeq6(self, filename_6i, db,
           samplename=None,
           path_6i=os.getcwd(),
           path_6o=os.getcwd(),
           path_6p=os.getcwd()):
    
    &#34;&#34;&#34;
    Call EQ6 on a .6i input file.
    
    Parameters
    ----------
    filename_6i : str
        Name of 6i input file.
    
    db : str
        Three letter code of database.
    
    path_6i : path str, default current working directory
        Path of .6i input files.
        
    path_6o : path str, default current working directory
        Path of .6o output files.
    
    path_6p : path str, default current working directory
        Path of .6p pickup files.
    &#34;&#34;&#34;

    # get current working dir
    cwd = os.getcwd()
    
    if samplename == None:
        samplename = filename_6i[:-3]
    
    if self.verbose &gt; 0:
        print(&#39;Using &#39; + db + &#39; to speciate &#39; + samplename)
    os.chdir(path_6i)  # step into 6i folder
    args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeq6&#39;, db, filename_6i]

    self.__run_script_and_wait(args) # run EQ6

    # restore working dir
    os.chdir(cwd)

    filename_6o = filename_6i[:-1] + &#39;o&#39;
    filename_6p = filename_6i[:-1] + &#39;p&#39;

    try:
        # rename output
        os.rename(path_6i + &#39;/output&#39;, path_6i + &#34;/&#34; + filename_6o)
    except:
        if self.verbose &gt; 0:
            print(&#39;Error: EQ6 failed to produce output for &#39; + filename_6i)

    try:
        # move output
        shutil.move(path_6i + &#34;/&#34; + filename_6o,
                    path_6o + &#34;/&#34; + filename_6o)
    except:
        if self.verbose &gt; 0:
            print(&#39;Error: Could not move&#39;, filename_6o, &#34;to&#34;, path_6o)

    try:
        # rename pickup
        os.rename(path_6i + &#39;/pickup&#39;, path_6i + &#34;/&#34; + filename_6p)
        move_pickup = True
    except:
        if self.verbose &gt; 0:
            print(&#39;Error: EQ6 failed to produce a pickup file for &#39; + filename_6i)
        move_pickup = False
    
    if move_pickup:
        try:
            # move pickup
            shutil.move(path_6i + &#34;/&#34; + filename_6p,
                        path_6p + &#34;/&#34; + filename_6p)
        except:
            if self.verbose &gt; 0:
                print(&#39;Error: Could not move&#39;, filename_6p, &#34;to&#34;, path_6p)</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.AqEquil.runeqpt"><code class="name flex">
<span>def <span class="ident">runeqpt</span></span>(<span>self, db, extra_eqpt_output=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a data0 into a data1 file with EQPT.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db</code></strong> :&ensp;<code>str</code></dt>
<dd>Three letter code of database.</dd>
<dt><strong><code>extra_eqpt_output</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Keep additional output files from EQPT? These files include
eqpt_log.txt, data1f.txt, and slist.txt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runeqpt(self, db, extra_eqpt_output=False):
    
    &#34;&#34;&#34;
    Convert a data0 into a data1 file with EQPT.
    
    Parameters
    ----------
    db : str
        Three letter code of database.
    
    extra_eqpt_output : bool, default False
        Keep additional output files from EQPT? These files include
        eqpt_log.txt, data1f.txt, and slist.txt.
    &#34;&#34;&#34;

    if os.path.exists(&#34;data0.&#34;+db) and os.path.isfile(&#34;data0.&#34;+db):
        pass
    else:
        raise Exception(&#34;Error: could not locate custom database&#34;,
                        &#34;data0.{} in {}.&#34;.format(db, os.getcwd()))

    if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
        os.remove(&#34;data1.&#34;+db)

    self.__clear_eqpt_extra_output()

    os.environ[&#39;EQ36DA&#39;] = os.getcwd()

    args = [&#39;/bin/csh&#39;, self.eq36co+&#39;/runeqpt&#39;, db]

    try:
        self.__run_script_and_wait(args) # run EQPT
    except:
        os.environ[&#39;EQ36DA&#39;] = self.eq36da
        raise Exception(
            &#34;Error: EQPT failed to run on {}.&#34;.format(&#34;data0.&#34;+db))

    if os.path.exists(&#34;data1&#34;) and os.path.isfile(&#34;data1&#34;):
        os.rename(&#34;data1&#34;, &#34;data1.&#34;+db)
    if os.path.exists(&#34;output&#34;) and os.path.isfile(&#34;output&#34;):
        os.rename(&#34;output&#34;, &#34;eqpt_log.txt&#34;)
    if os.path.exists(&#34;data1f&#34;) and os.path.isfile(&#34;data1f&#34;):
        os.rename(&#34;data1f&#34;, &#34;data1f.txt&#34;)
    if os.path.exists(&#34;slist&#34;) and os.path.isfile(&#34;slist&#34;):
        os.rename(&#34;slist&#34;, &#34;slist.txt&#34;)

    if os.path.exists(&#34;data1.&#34;+db) and os.path.isfile(&#34;data1.&#34;+db):
        if self.verbose &gt; 0:
            print(&#34;Successfully created a data1.&#34;+db+&#34; from data0.&#34;+db)
    else:
        msg = (&#34;EQPT could not create data1.&#34;+db+&#34; from &#34;
               &#34;data0.&#34;+db+&#34;. Check eqpt_log.txt for details.&#34;)
        raise Exception(msg)

    if not extra_eqpt_output:
        self.__clear_eqpt_extra_output()

    os.environ[&#39;EQ36DA&#39;] = self.eq36da  # reset default EQ36 db path</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.AqEquil.speciate"><code class="name flex">
<span>def <span class="ident">speciate</span></span>(<span>self, input_filename, db='wrm', redox_flag='logfO2', redox_aux='Fe+3', default_logfO2=-6, exclude=[], suppress=[], charge_balance_on='none', suppress_missing=True, verbose=1, report_filename=None, get_aq_dist=True, aq_dist_type='log_activity', get_mass_contribution=True, mass_contribution_other=True, get_mineral_sat=True, mineral_sat_type='affinity', get_redox=True, redox_type='Eh', get_ion_activity_ratios=True, get_fugacity=True, get_affinity_energy=False, rxn_filename=None, not_limiting=['H+', 'OH-', 'H2O'], get_charge_balance=True, custom_db=False, extra_eqpt_output=False, batch_3o_filename=None, delete_generated_folders=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the equilibrium distribution of chemical species in solution.
Additionally, calculate chemical affinities and energy supplies for
user-specified reactions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>User-supplied utf8-encoded comma separated value (csv) file
containing sample data intended for speciation. The file must
follow this format:</p>
<ul>
<li>the first row is a header row that must contain the names of the
species to be included in the speciation calculation. There
cannot be duplicate headers.</li>
<li>
<p>the second row must contain subheaders for each species in the
header row. These subheaders must be taken from the following:</p>
<pre><code>degC
ppm
ppb
Suppressed
Molality
Molarity
mg/L
mg/kg.sol
Alk., eq/kg.H2O
Alk., eq/L
Alk., eq/kg.sol
Alk., mg/L CaCO3
Alk., mg/L HCO3-
Log activity
Log act combo
Log mean act
pX
pH
pHCl
pmH
pmX
Hetero. equil.
Homo. equil.
Make non-basis
</code></pre>
</li>
<li>
<p>'Temperature' must be included as a header, with 'degC' as its
subheader.</p>
</li>
<li>The first column must contain sample names. There cannot be
duplicate sample names.</li>
</ul>
</dd>
<dt><strong><code>db</code></strong> :&ensp;<code>three letter str</code>, default <code>"wrm"</code></dt>
<dd>Three letter file extension for the desired thermodynamic database.
If <code>custom_db</code> is False, this database must be named data1.xyz
(where xyz is your desired three letter extension) and located
in the EQ3/6 'EQ36DA' path. Otherwise, the database must be named
data0.xyz and located in your current working directory. Note that
data1 files are already compiled by EQPT, while data0 files will be
automatically compiled for you if <code>custom_db</code> is True.</dd>
<dt><strong><code>redox_flag</code></strong> :&ensp;<code>str</code>, default <code>"O2(g)"</code></dt>
<dd>
<p>Determines which column in the sample input file sets the overall
redox state of the samples. Options for redox_flag include 'O2(g)',
'pe', 'Eh', 'logfO2', and 'redox aux'. The code will search your
sample spreadsheet file (see <code>filename</code>) for a column corresponding
to the option you chose:</p>
<ul>
<li>'O2(g)' with a valid subheader for a gas</li>
<li>'pe' with subheader pe</li>
<li>'Eh' with subheader volts</li>
<li>'logfO2' with subheader logfO2</li>
<li>'redox aux' will search for a column corresponding to the
auxilliary basis species selected to form a redox couple with its
linked strict basis species (see <code>redox_aux</code>). For example, the
redox couple Fe+2/Fe+3 would require a column named Fe+3</li>
</ul>
<p>If an appropriate header or redox data cannot be found to define
redox state, <code>default_logfO2</code> is used to set sample logfO2.</p>
<p>There is a special case where dissolved oxygen can be used to impose
sample redox state if <code>redox_flag</code> is set to logfO2 and a column named
logfO2 does not appear in your sample spreadsheet. If there is a
column corresponding to dissolved oxygen measurements, logfO2 is
calculated from the equilibrium reaction O2(aq) = O2(g) at the
temperature and pressure of the sample using the revised Helgeson-
Kirkham-Flowers (HKF) equation of state (JC Tanger IV and HC
Helgeson, Am. J. Sci., 1988, 288, 19).</p>
</dd>
<dt><strong><code>redox_aux</code></strong> :&ensp;<code>default "Fe+3"</code>, optional</dt>
<dd>Ignored unless <code>redox_flag</code> equals 1. Name of the auxilliary species
whose reaction links it to a basis species (or another auxilliary
species) such that they form a redox couple that controls sample
fO2. For instance, Fe+3 is linked to Fe+2 in many supporting data
files, so selecting <code>redox_flag</code> = 1 and <code>redox_aux</code> = "Fe+3" will
set sample fO2 based on the Fe+2/Fe+3 redox couple.</dd>
<dt><strong><code>default_logfO2</code></strong> :&ensp;<code>float</code>, default <code>-6</code></dt>
<dd>Default value for sample logfO2 in case redox data cannot be found
in the user-supplied sample spreadsheet.</dd>
<dt><strong><code>exclude</code></strong> :&ensp;<code>list</code> of <code>str</code>, default <code>[]</code></dt>
<dd>Names of columns in the user-supplied sample spreadsheet that should
not be considered aqueous species. Useful for excluding columns
containing sample metatadata, such as "Year" and "Location".</dd>
<dt><strong><code>suppress</code></strong> :&ensp;<code>list</code> of <code>str</code>, default <code>[]</code></dt>
<dd>Names of chemical species that will be prevented from forming in the
speciation calculation.</dd>
<dt><strong><code>charge_balance_on</code></strong> :&ensp;<code>str</code>, default <code>"none"</code></dt>
<dd>If "none", will not balance electrical charge between cations and
anions in the speciation calculation. If a name of a species is
supplied instead, the activity of that species will be allowed to
change until charge balance is obtained. For example,
charge_balance_on = "H+" will calculate what pH a sample must have
to have zero net charge.</dd>
<dt><strong><code>suppress_missing</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Suppress the formation of an aqueous species if it is missing a
value in the user-supplied sample spreadsheet?</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int, 0, 1,</code> or <code>2</code>, default <code>1</code></dt>
<dd>Level determining how many messages are returned during a
calculation. 2 for all messages, 1 for errors or warnings only,
0 for silent.</dd>
<dt><strong><code>report_filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the comma separated values (csv) report file generated when
the calculation is complete. If this argument is not defined, a
report file is not generated.</dd>
<dt><strong><code>get_aq_dist</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate distributions of aqueous species?</dd>
<dt><strong><code>aq_dist_type</code></strong> :&ensp;<code>str</code>, default <code>"log_activity"</code></dt>
<dd>Desired units of measurement for reported distributions of aqueous
species. Can be "molality", "log_molality", "log_gamma", or
"log_activity". Ignored if <code>get_aq_dist</code> is False.</dd>
<dt><strong><code>get_mass_contribution</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate basis species contributions to mass balance of aqueous
species?</dd>
<dt><strong><code>mass_contribution_other</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Include an "other" species for the sake of summing percents of basis
species contributions to 100%? Ignored if <code>get_mass_contribution</code> is
False.</dd>
<dt><strong><code>get_mineral_sat</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate saturation states of pure solids?</dd>
<dt><strong><code>mineral_sat_type</code></strong> :&ensp;<code>str</code>, default <code>"affinity"</code></dt>
<dd>Desired units of measurement for reported saturation states of pure
solids. Can be "logQoverK" or "affinity". Ignored if
<code>get_mineral_sat</code> is False.</dd>
<dt><strong><code>get_redox</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate potentials of redox couples?</dd>
<dt><strong><code>redox_type</code></strong> :&ensp;<code>str</code>, default <code>"Eh"</code></dt>
<dd>Desired units of measurement for reported redox potentials. Can be
"Eh", "pe", "logfO2", or "Ah". Ignored if <code>get_redox</code> is False.</dd>
<dt><strong><code>get_ion_activity_ratios</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate ion/H+ activity ratios and neutral species activities?</dd>
<dt><strong><code>get_fugacity</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate gas fugacities?</dd>
<dt><strong><code>get_affinity_energy</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Calculate affinities and energy supplies of reactions listed in a
separate user-supplied file?</dd>
<dt><strong><code>rxn_filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of .txt file containing reactions used to calculate affinities
and energy supplies. Ignored if <code>get_affinity_energy</code> is False.</dd>
<dt><strong><code>not_limiting</code></strong> :&ensp;<code>list</code>, default <code>["H+", "OH-", "H2O"]</code></dt>
<dd>List containing names of species that are not considered limiting
when calculating energy supplies. Ignored if <code>get_affinity_energy</code>
is False.</dd>
<dt><strong><code>get_charge_balance</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Calculate charge balance and ionic strength?</dd>
<dt><strong><code>custom_db</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Is the database defined by <code>db</code> a custom user-supplied database? If
this is set to True, searches for a data0.xyz file in the current
working directory, where 'xyz' corresponds to the three letter code
assigned to <code>db</code>. This data0 file is automatically converted into a
machine-readable file called data1 by software called EQPT. This
data1 file is then used in speciation calculations.</dd>
<dt><strong><code>extra_eqpt_output</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Keep additional output files created by EQPT (see <code>custom_db</code>)?
Ignored if <code>custom_db</code> is False.</dd>
<dt><strong><code>batch_3o_filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of rds (R object) file exported after the speciation
calculation? No file will be generated if this argument is not
defined.</dd>
<dt><strong><code>delete_generated_folders</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Delete the 'rxn_3i', 'rxn_3o', and 'rxn_3p' folders containing raw
EQ3NR input, output, and pickup files once the speciation
calculation is complete?</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>speciation</code></strong> :&ensp;<code>object</code> of <code>class <a title="AqEquil.AqSpeciation.Speciation" href="#AqEquil.AqSpeciation.Speciation">Speciation</a></code></dt>
<dd>Contains the results of the speciation calculation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def speciate(self,
                 input_filename,
                 db=&#34;wrm&#34;,
                 redox_flag=&#34;logfO2&#34;,
                 redox_aux=&#34;Fe+3&#34;,
                 default_logfO2=-6,
                 exclude=[],
                 suppress=[],
                 charge_balance_on=&#34;none&#34;,
                 suppress_missing=True,
                 verbose=1,
                 report_filename=None,
                 get_aq_dist=True,
                 aq_dist_type=&#34;log_activity&#34;,
                 get_mass_contribution=True,
                 mass_contribution_other=True,
                 get_mineral_sat=True,
                 mineral_sat_type=&#34;affinity&#34;,
                 get_redox=True,
                 redox_type=&#34;Eh&#34;,
                 get_ion_activity_ratios=True,
                 get_fugacity=True,
                 get_affinity_energy=False,
                 rxn_filename=None,
                 not_limiting=[&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;],
                 get_charge_balance=True,
                 custom_db=False,
                 extra_eqpt_output=False,
                 batch_3o_filename=None,
                 delete_generated_folders=False):
        
        &#34;&#34;&#34;
        Calculate the equilibrium distribution of chemical species in solution.
        Additionally, calculate chemical affinities and energy supplies for
        user-specified reactions.
        
        Parameters
        ----------
        input_filename : str
            User-supplied utf8-encoded comma separated value (csv) file
            containing sample data intended for speciation. The file must
            follow this format:
            
            - the first row is a header row that must contain the names of the
              species to be included in the speciation calculation. There
              cannot be duplicate headers.
            - the second row must contain subheaders for each species in the
              header row. These subheaders must be taken from the following:
              
                    degC
                    ppm
                    ppb
                    Suppressed
                    Molality
                    Molarity
                    mg/L
                    mg/kg.sol
                    Alk., eq/kg.H2O
                    Alk., eq/L
                    Alk., eq/kg.sol
                    Alk., mg/L CaCO3
                    Alk., mg/L HCO3-
                    Log activity
                    Log act combo
                    Log mean act
                    pX
                    pH
                    pHCl
                    pmH
                    pmX
                    Hetero. equil.
                    Homo. equil.
                    Make non-basis
                    
            - &#39;Temperature&#39; must be included as a header, with &#39;degC&#39; as its
              subheader.
            - The first column must contain sample names. There cannot be
              duplicate sample names.
        
        db : three letter str, default &#34;wrm&#34;
            Three letter file extension for the desired thermodynamic database.
            If `custom_db` is False, this database must be named data1.xyz
            (where xyz is your desired three letter extension) and located
            in the EQ3/6 &#39;EQ36DA&#39; path. Otherwise, the database must be named
            data0.xyz and located in your current working directory. Note that
            data1 files are already compiled by EQPT, while data0 files will be
            automatically compiled for you if `custom_db` is True.
        
        redox_flag : str, default &#34;O2(g)&#34;
            Determines which column in the sample input file sets the overall
            redox state of the samples. Options for redox_flag include &#39;O2(g)&#39;,
            &#39;pe&#39;, &#39;Eh&#39;, &#39;logfO2&#39;, and &#39;redox aux&#39;. The code will search your
            sample spreadsheet file (see `filename`) for a column corresponding
            to the option you chose:
            
            * &#39;O2(g)&#39; with a valid subheader for a gas
            * &#39;pe&#39; with subheader pe
            * &#39;Eh&#39; with subheader volts
            * &#39;logfO2&#39; with subheader logfO2
            * &#39;redox aux&#39; will search for a column corresponding to the
              auxilliary basis species selected to form a redox couple with its
              linked strict basis species (see `redox_aux`). For example, the
              redox couple Fe+2/Fe+3 would require a column named Fe+3
            
            If an appropriate header or redox data cannot be found to define
            redox state, `default_logfO2` is used to set sample logfO2.
            
            There is a special case where dissolved oxygen can be used to impose
            sample redox state if `redox_flag` is set to logfO2 and a column named
            logfO2 does not appear in your sample spreadsheet. If there is a
            column corresponding to dissolved oxygen measurements, logfO2 is
            calculated from the equilibrium reaction O2(aq) = O2(g) at the
            temperature and pressure of the sample using the revised Helgeson-
            Kirkham-Flowers (HKF) equation of state (JC Tanger IV and HC
            Helgeson, Am. J. Sci., 1988, 288, 19).
        
        redox_aux : default &#34;Fe+3&#34;, optional
            Ignored unless `redox_flag` equals 1. Name of the auxilliary species
            whose reaction links it to a basis species (or another auxilliary
            species) such that they form a redox couple that controls sample
            fO2. For instance, Fe+3 is linked to Fe+2 in many supporting data
            files, so selecting `redox_flag` = 1 and `redox_aux` = &#34;Fe+3&#34; will
            set sample fO2 based on the Fe+2/Fe+3 redox couple.
        
        default_logfO2 : float, default -6
            Default value for sample logfO2 in case redox data cannot be found
            in the user-supplied sample spreadsheet.
        
        exclude : list of str, default []
            Names of columns in the user-supplied sample spreadsheet that should
            not be considered aqueous species. Useful for excluding columns
            containing sample metatadata, such as &#34;Year&#34; and &#34;Location&#34;.
            
        suppress : list of str, default []
            Names of chemical species that will be prevented from forming in the
            speciation calculation.
            
        charge_balance_on : str, default &#34;none&#34;
            If &#34;none&#34;, will not balance electrical charge between cations and
            anions in the speciation calculation. If a name of a species is
            supplied instead, the activity of that species will be allowed to
            change until charge balance is obtained. For example,
            charge_balance_on = &#34;H+&#34; will calculate what pH a sample must have
            to have zero net charge.
        
        suppress_missing : bool, default True
            Suppress the formation of an aqueous species if it is missing a
            value in the user-supplied sample spreadsheet?
        
        verbose : int, 0, 1, or 2, default 1
            Level determining how many messages are returned during a
            calculation. 2 for all messages, 1 for errors or warnings only,
            0 for silent.
            
        report_filename : str, optional
            Name of the comma separated values (csv) report file generated when
            the calculation is complete. If this argument is not defined, a
            report file is not generated.
            
        get_aq_dist : bool, default True
            Calculate distributions of aqueous species?
        
        aq_dist_type : str, default &#34;log_activity&#34;
            Desired units of measurement for reported distributions of aqueous
            species. Can be &#34;molality&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, or
            &#34;log_activity&#34;. Ignored if `get_aq_dist` is False.
        
        get_mass_contribution : bool, default True
            Calculate basis species contributions to mass balance of aqueous
            species?
        
        mass_contribution_other : bool, default True
            Include an &#34;other&#34; species for the sake of summing percents of basis
            species contributions to 100%? Ignored if `get_mass_contribution` is
            False.
        
        get_mineral_sat : bool, default True
            Calculate saturation states of pure solids?
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Desired units of measurement for reported saturation states of pure
            solids. Can be &#34;logQoverK&#34; or &#34;affinity&#34;. Ignored if
            `get_mineral_sat` is False.
        
        get_redox : bool, default True
            Calculate potentials of redox couples?
            
        redox_type : str, default &#34;Eh&#34;
            Desired units of measurement for reported redox potentials. Can be
            &#34;Eh&#34;, &#34;pe&#34;, &#34;logfO2&#34;, or &#34;Ah&#34;. Ignored if `get_redox` is False.
        
        get_ion_activity_ratios : bool, default True
            Calculate ion/H+ activity ratios and neutral species activities?
        
        get_fugacity : bool, default True
            Calculate gas fugacities?
        
        get_affinity_energy : bool, default False
            Calculate affinities and energy supplies of reactions listed in a
            separate user-supplied file?
        
        rxn_filename : str, optional
            Name of .txt file containing reactions used to calculate affinities
            and energy supplies. Ignored if `get_affinity_energy` is False.
        
        not_limiting : list, default [&#34;H+&#34;, &#34;OH-&#34;, &#34;H2O&#34;]
            List containing names of species that are not considered limiting
            when calculating energy supplies. Ignored if `get_affinity_energy`
            is False.
        
        get_charge_balance : bool, default True
            Calculate charge balance and ionic strength?
            
        custom_db : bool, default False
            Is the database defined by `db` a custom user-supplied database? If
            this is set to True, searches for a data0.xyz file in the current
            working directory, where &#39;xyz&#39; corresponds to the three letter code
            assigned to `db`. This data0 file is automatically converted into a
            machine-readable file called data1 by software called EQPT. This
            data1 file is then used in speciation calculations.
        
        extra_eqpt_output : bool, default False
            Keep additional output files created by EQPT (see `custom_db`)?
            Ignored if `custom_db` is False.
        
        batch_3o_filename : str, optional
            Name of rds (R object) file exported after the speciation
            calculation? No file will be generated if this argument is not
            defined.
            
        delete_generated_folders : bool, default False
            Delete the &#39;rxn_3i&#39;, &#39;rxn_3o&#39;, and &#39;rxn_3p&#39; folders containing raw
            EQ3NR input, output, and pickup files once the speciation
            calculation is complete?
        
        Returns
        -------
        speciation : object of class Speciation
            Contains the results of the speciation calculation.
        
        &#34;&#34;&#34;
        
        self.verbose = verbose
        
        # check input sample file for errors
        self._check_sample_input_file(input_filename, exclude, db, custom_db,
                                      charge_balance_on, suppress_missing)
        
        if redox_flag == &#34;O2(g)&#34; or redox_flag == -3:
            redox_flag = -3
        elif redox_flag == &#34;pe&#34; or redox_flag == -2:
            redox_flag = -2
        elif redox_flag == &#34;Eh&#34; or redox_flag == -1:
            redox_flag = -1
        elif redox_flag == &#34;logfO2&#34; or redox_flag == 0:
            redox_flag = 0
        elif redox_flag == &#34;redox aux&#34; or redox_flag == 1:
            redox_flag = 1
        else:
            raise Exception(&#34;Unrecognized redox flag. Valid options are &#39;O2(g)&#39;&#34;
                            &#34;, &#39;pe&#39;, &#39;Eh&#39;, &#39;logfO2&#39;, &#39;redox aux&#39;&#34;)
            
        # handle batch_3o naming
        if batch_3o_filename != None:
            if &#34;.rds&#34; in batch_3o_filename[-4:]:
                batch_3o_filename = batch_3o_filename
            else:
                batch_3o_filename = &#34;batch_3o_{}.rds&#34;.format(db)
        else:
            batch_3o_filename = ro.r(&#34;NULL&#34;)

        if custom_db:
            # EQ3/6 cannot handle spaces in the &#39;EQ36DA&#39; path name.
            if &#34; &#34; in os.getcwd():
                msg = (&#34;Error: the path to the custom database &#34;
                    &#34;cannot contain spaces. The current path &#34;
                    &#34;is: [ &#34; + os.getcwd() + &#34; ]. Remove or &#34;
                    &#34;replace spaces in folder names for this &#34;
                    &#34;feature. Example: [ &#34; + os.getcwd().replace(&#34; &#34;, &#34;-&#34;) + &#34; ].&#34;)
                raise Exception(msg)

            self.runeqpt(db, extra_eqpt_output)
            os.environ[&#39;EQ36DA&#39;] = os.getcwd()
            
            data0_path = &#34;data0.&#34; + db
            
        else:
            data0_path = self.eq36da + &#34;/data0.&#34; + db
            
        if os.path.exists(data0_path) and os.path.isfile(data0_path):
            with open(data0_path) as data0:
                data0_lines = data0.readlines()
                start_index = [i+1 for i, s in enumerate(data0_lines) if s == &#39;temperatures\n&#39;]
                end_index = [i for i, s in enumerate(data0_lines) if s == &#39;debye huckel a (adh)\n&#39;]
                db_grids_unformatted = [i.split(&#34;pressures&#34;)[0] for i in data0_lines[start_index[0]:end_index[0]]]
                db_grids = [&#34; &#34;.join(i.split()) for i in db_grids_unformatted if i != &#39;&#39;]
                grid_temp = db_grids[0] + &#34; &#34; + db_grids[1]
                grid_press = db_grids[2] + &#34; &#34; + db_grids[3]
                grid_temp = grid_temp.split(&#34; &#34;)
                grid_press = grid_press.split(&#34; &#34;)
                try:
                    water_model = data0_lines[1].split(&#34;model: &#34;)[1] # extract water model from the second line of data0 file
                    water_model = water_model.replace(&#34;\n&#34;, &#34;&#34;)
                except:
                    water_model = &#34;SUPCRT92&#34;
#                     print(&#34;Water model could not be referenced from {}&#34;.format(data0_path)+&#34;&#34;
#                           &#34;. Defaulting to SUPCRT92 water model...&#34;)
                
                if(water_model not in [&#34;SUPCRT92&#34;, &#34;IAPWS95&#34;, &#34;DEW&#34;]):
                    water_model = &#34;SUPCRT92&#34; # the default for EQ3/6
                    print(&#34;Water model given in {}&#34;.format(data0_path)+&#34; was not &#34;
                          &#34;recognized. Defaulting to SUPCRT92 water model...&#34;)
            
        else: # if a data0 file can&#39;t be found, assume default water model, 0-350 C and PSAT
            water_model = &#34;SUPCRT92&#34;
            grid_temp = [&#34;0.0100&#34;, &#34;50.0000&#34;, &#34;100.0000&#34;, &#34;150.0000&#34;,
                         &#34;200.0000&#34;, &#34;250.0000&#34;, &#34;300.0000&#34;, &#34;350.0000&#34;]
            grid_press = [&#34;1.0000&#34;, &#34;1.0000&#34;, &#34;1.0132&#34;, &#34;4.7572&#34;,
                          &#34;15.5365&#34;, &#34;39.7365&#34;, &#34;85.8378&#34;, &#34;165.2113&#34;]

        if get_affinity_energy:
            if rxn_filename == None:
                err = (&#34;A get_affinity_energy was set to True but a reaction &#34;
                       &#34;file was not specified.&#34;)
                raise Exception(err)
            elif self.__file_exists(rxn_filename, &#39;.txt&#39;):
                pass
        else:
            rxn_filename = &#34;&#34;
            
        # preprocess for EQ3 using R scripts
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_prescript = pkg_resources.resource_string(
                __name__, &#39;preprocess_for_EQ3.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_prescript)
            df_input_processed = ro.r.preprocess(input_filename=input_filename,
                                                 exclude=convert_to_RVector(
                                                     exclude),
                                                 redox_flag=redox_flag,
                                                 redox_aux=redox_aux,
                                                 default_logfO2=default_logfO2,
                                                 charge_balance_on=charge_balance_on,
                                                 suppress_missing=suppress_missing,
                                                 suppress=convert_to_RVector(
                                                     suppress),
                                                 water_model=water_model,
                                                 grid_temp=convert_to_RVector(grid_temp),
                                                 grid_press=convert_to_RVector(grid_press),
                                                 verbose=self.verbose)

        for warning in w:
            print(warning.message)

        self.df_input_processed = pandas2ri.ri2py_dataframe(df_input_processed)

        # run EQ3 on each input file
        cwd = os.getcwd()

        self.__mk_check_del_directory(&#39;rxn_3o&#39;)
        self.__mk_check_del_directory(&#39;rxn_3p&#39;)
        files_3i, files_3i_paths = self.__read_inputs(&#39;3i&#39;, &#39;rxn_3i&#39;)

        input_dir = cwd + &#34;/rxn_3i/&#34;
        output_dir = cwd + &#34;/rxn_3o/&#34;
        pickup_dir = cwd + &#34;/rxn_3p/&#34;
        
        for file in files_3i:
            samplename = self.df_input_processed.loc[file[:-3], &#34;Sample&#34;]
            self.runeq3(filename_3i=file, db=db, samplename=samplename,
                        path_3i=input_dir, path_3o=output_dir,
                        path_3p=pickup_dir)

        if custom_db:
            os.environ[&#39;EQ36DA&#39;] = self.eq36da

        files_3o = [file+&#34;.3o&#34; for file in self.df_input_processed.index]
        
        df_input_processed_names = convert_to_RVector(list(self.df_input_processed.columns))
        
        # mine output
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(&#34;always&#34;)
            r_3o_mine = pkg_resources.resource_string(
                __name__, &#39;3o_mine.r&#39;).decode(&#34;utf-8&#34;)
            ro.r(r_3o_mine)
            batch_3o = ro.r.main_3o_mine(
                files_3o=convert_to_RVector(files_3o),
                input_filename=input_filename,
                rxn_filename=rxn_filename,
                get_aq_dist=get_aq_dist,
                aq_dist_type=aq_dist_type,
                get_mass_contribution=get_mass_contribution,
                mass_contribution_other=mass_contribution_other,
                get_mineral_sat=get_mineral_sat,
                mineral_sat_type=mineral_sat_type,
                get_redox=get_redox,
                redox_type=redox_type,
                get_charge_balance=get_charge_balance,
                get_ion_activity_ratios=get_ion_activity_ratios,
                get_fugacity=get_fugacity,
                get_affinity_energy=get_affinity_energy,
                not_limiting=convert_to_RVector(not_limiting),
                batch_3o_filename=batch_3o_filename,
                df_input_processed=pandas2ri.py2ri(self.df_input_processed),
                # Needed for keeping symbols in column names after porting
                #   df_input_processed in the line above. Some kind of check.names
                #   option for pandas2ri.py2ri would be nice. Workaround:
                df_input_processed_names=df_input_processed_names,
                verbose=self.verbose,
            )
        for warning in w:
            print(warning.message)
        
        if get_mass_contribution:
            mass_contribution = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;mass_contribution&#39;))
        df_report = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;report&#39;))
        df_input = pandas2ri.ri2py_dataframe(batch_3o.rx2(&#39;input&#39;))
        report_divs = batch_3o.rx2(&#39;report_divs&#39;)

        input_cols = list(report_divs.rx2(&#39;input&#39;))
        df_input = df_report[input_cols]

        # handle headers and subheaders of input section
        headers = [col.split(&#34;_&#34;)[0] for col in list(df_input.columns)]
        headers = [&#34;pH&#34; if header == &#34;H+&#34; else header for header in headers]
        headers = [header+&#34;_(input)&#34; if header not in [&#34;Temperature&#34;, &#34;logfO2&#34;]+exclude else header for header in headers]
        report_divs[0] = convert_to_RVector(headers) # modify headers in the &#39;input&#39; section, report_divs[0]
        subheaders = [subheader[1] if len(subheader) &gt; 1 else &#34;&#34; for subheader in [
            col.split(&#34;_&#34;) for col in list(df_input.columns)]]
        multicolumns = pd.MultiIndex.from_arrays(
            [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
        df_input.columns = multicolumns

        df_join = df_input

        if get_aq_dist:
            aq_distribution_cols = list(report_divs.rx2(&#39;aq_distribution&#39;))
            df_aq_distribution = df_report[aq_distribution_cols]
            df_aq_distribution = df_aq_distribution.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # create a pH column from H+
            df_aq_distribution[&#34;pH&#34;] = -df_aq_distribution[&#34;H+&#34;]
            
            # handle headers of aq_distribution section
            headers = df_aq_distribution.columns
            subheaders = [aq_dist_type]*(len(headers)-1) # -1 because the last column will have subheader pH (see next line)
            subheaders = subheaders + [&#34;pH&#34;]
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_aq_distribution.columns = multicolumns
            
            # ensure final pH column is included in report_divs aq_distribution section
            aq_dist_indx = report_divs.names.index(&#34;aq_distribution&#34;)
            report_divs[aq_dist_indx] = convert_to_RVector(list(headers))
            
            df_join = df_join.join(df_aq_distribution)

        if get_mineral_sat:
            mineral_sat_cols = list(report_divs.rx2(&#39;mineral_sat&#39;))
            df_mineral_sat = df_report[mineral_sat_cols]
            df_mineral_sat = df_mineral_sat.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_mineral_sat section
            if mineral_sat_type == &#34;affinity&#34;:
                mineral_sat_unit = &#34;affinity_kcal&#34;
            elif mineral_sat_type == &#34;logQoverK&#34;:
                mineral_sat_unit = &#34;logQ/K&#34;
            else:
                raise Exception(
                    &#34;mineral_sat_type must be either &#39;affinity&#39; or &#39;logQoverK&#39;&#34;)

            headers = df_mineral_sat.columns
            subheaders = [mineral_sat_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_mineral_sat.columns = multicolumns
            df_join = df_join.join(df_mineral_sat)

        if get_redox:
            redox_cols = list(report_divs.rx2(&#39;redox&#39;))
            df_redox = df_report[redox_cols]
            df_redox = df_redox.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_redox section
            if redox_type == &#34;Eh&#34;:
                redox_unit = &#34;Eh_volts&#34;
            elif redox_type == &#34;pe&#34;:
                redox_unit = &#34;pe&#34;
            elif redox_type == &#34;logfO2&#34;:
                redox_unit = &#34;logfO2&#34;
            elif redox_type == &#34;Ah&#34;:
                redox_unit = &#34;Ah_kcal&#34;
            else:
                raise Exception(
                    &#34;redox_type must be either &#39;Eh&#39;, &#39;pe&#39;, &#39;logfO2&#39;, or &#39;Ah&#39;&#34;)

            headers = df_redox.columns
            subheaders = [redox_unit]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_redox.columns = multicolumns
            df_join = df_join.join(df_redox)

        if get_charge_balance:
            charge_balance_cols = list(report_divs.rx2(&#39;charge_balance&#39;))
            df_charge_balance = df_report[charge_balance_cols]
            df_charge_balance = df_charge_balance.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_charge_balance section
            headers = df_charge_balance.columns
            subheaders = [&#34;%&#34;]*2 + [&#39;eq/kg.H2O&#39;, &#39;molality&#39;] + \
                [&#39;eq/kg.H2O&#39;]*4 + [&#39;molality&#39;]
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_charge_balance.columns = multicolumns
            df_join = df_join.join(df_charge_balance)
            
        if get_ion_activity_ratios:
            ion_activity_ratio_cols = list(report_divs.rx2(&#39;ion_activity_ratios&#39;))
            df_ion_activity_ratios = df_report[ion_activity_ratio_cols]
            df_ion_activity_ratios = df_ion_activity_ratios.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            
            # handle headers of df_ion_activity_ratios section
            headers = df_ion_activity_ratios.columns
            subheaders = [&#34;Log ion-H+ activity ratio&#34;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_ion_activity_ratios.columns = multicolumns
            df_join = df_join.join(df_ion_activity_ratios)
            
        if get_fugacity:
            fugacity_cols = list(report_divs.rx2(&#39;fugacity&#39;))
            df_fugacity = df_report[fugacity_cols]
            df_fugacity = df_fugacity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            
            # handle headers of fugacity section
            headers = df_fugacity.columns
            subheaders = [&#34;log_fugacity&#34;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_fugacity.columns = multicolumns
            df_join = df_join.join(df_fugacity)
            
        if get_affinity_energy:
            affinity_cols = list(report_divs.rx2(&#39;affinity&#39;))
            energy_cols = list(report_divs.rx2(&#39;energy&#39;))
            df_affinity = df_report[affinity_cols]
            df_energy = df_report[energy_cols]
            df_affinity = df_affinity.apply(pd.to_numeric, errors=&#39;coerce&#39;)
            df_energy = df_energy.apply(pd.to_numeric, errors=&#39;coerce&#39;)

            # handle headers of df_affinity section
            headers = df_affinity.columns
            subheaders = [&#39;cal/mol e-&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_affinity.columns = multicolumns

            # handle headers of df_energy section
            headers = df_energy.columns
            subheaders = [&#39;cal/kg.H2O&#39;]*len(headers)
            multicolumns = pd.MultiIndex.from_arrays(
                [headers, subheaders], names=[&#39;Sample&#39;, &#39;&#39;])
            df_energy.columns = multicolumns
            df_join = df_join.join(df_affinity)
            df_join = df_join.join(df_energy)

        out_dict = {&#39;sample_data&#39;: {},
                    &#39;report&#39;: df_join,
                    &#39;input&#39;: df_input, &#39;report_divs&#39;: report_divs}
        
        if get_mass_contribution:
            out_dict[&#39;mass_contribution&#39;] = mass_contribution

        sample_data = batch_3o.rx2(&#39;sample_data&#39;)

        # assemble sample data
        for i, sample in enumerate(sample_data):
            dict_sample_data = {
                &#34;filename&#34;: str(sample.rx2(&#39;filename&#39;)[0]),
                &#34;name&#34;: str(sample.rx2(&#39;name&#39;)[0]),
                &#34;temperature&#34;: float(sample.rx2(&#39;temperature&#39;)[0]),
                &#34;pressure&#34;: float(sample.rx2(&#39;pressure&#39;)[0]),
                &#34;logact_H2O&#34;: float(sample.rx2(&#39;logact_H2O&#39;)[0]),
                &#34;H2O_density&#34;: float(sample.rx2(&#39;H2O_density&#39;)[0]),
                &#34;H2O_molality&#34;: float(sample.rx2(&#39;H2O_molality&#39;)[0]),
                &#34;H2O_log_molality&#34;: float(sample.rx2(&#39;H2O_log_molality&#39;)[0]),
                }

            if get_aq_dist:
                sample_aq_dist = pandas2ri.ri2py_dataframe(sample.rx2(&#39;aq_distribution&#39;))
                sample_aq_dist = sample_aq_dist.apply(pd.to_numeric, errors=&#39;coerce&#39;)
                dict_sample_data.update({&#34;aq_distribution&#34;: sample_aq_dist})

            if get_mass_contribution:
                sample_mass_contribution = mass_contribution[mass_contribution[&#34;sample&#34;] == sample.rx2(&#39;name&#39;)[0]]
                dict_sample_data.update(
                    {&#34;mass_contribution&#34;: sample_mass_contribution})

            if get_mineral_sat:
                dict_sample_data.update(
                    {&#34;mineral_sat&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;mineral_sat&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                # replace sample mineral_sat entry with None if there is no mineral saturation data.
                if(len(dict_sample_data[&#39;mineral_sat&#39;].index) == 1 and dict_sample_data[&#39;mineral_sat&#39;].index[0] == &#39;None&#39;):
                    dict_sample_data[&#39;mineral_sat&#39;] = None

            if get_redox:
                dict_sample_data.update(
                    {&#34;redox&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;redox&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            if get_charge_balance:
                dict_sample_data.update({&#34;charge_balance&#34;: df_charge_balance.loc[sample.rx2(&#39;name&#39;)[0], :]})
            
            if get_ion_activity_ratios:
                try:
                    dict_sample_data.update(
                        {&#34;ion_activity_ratios&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;ion_activity_ratios&#39;))})
                except:
                    dict_sample_data[&#39;ion_activity_ratios&#39;] = None
            
            if get_fugacity:
                dict_sample_data.update(
                    {&#34;fugacity&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;fugacity&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                # replace sample fugacity entry with None if there is no fugacity data.
                if(len(dict_sample_data[&#39;fugacity&#39;].index) == 1 and dict_sample_data[&#39;fugacity&#39;].index[0] == &#39;None&#39;):
                    dict_sample_data[&#39;fugacity&#39;] = None
                else:
                    dict_sample_data[&#34;fugacity&#34;][&#34;fugacity&#34;] = 10**dict_sample_data[&#34;fugacity&#34;][&#34;log_fugacity&#34;]
            
            if get_affinity_energy:
                dict_sample_data.update({&#34;affinity_energy_raw&#34;: pandas2ri.ri2py_dataframe(
                    sample.rx2(&#39;affinity_energy_raw&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})
                dict_sample_data.update(
                    {&#34;affinity_energy&#34;: pandas2ri.ri2py_dataframe(sample.rx2(&#39;affinity_energy&#39;)).apply(pd.to_numeric, errors=&#39;coerce&#39;)})

            out_dict[&#34;sample_data&#34;].update(
                {sample_data.names[i]: dict_sample_data})

        out_dict.update({&#34;batch_3o&#34;: batch_3o})
        
        out_dict.update({&#34;water_model&#34;:water_model, &#34;grid_temp&#34;:grid_temp, &#34;grid_press&#34;:grid_press})
        
        speciation = Speciation(out_dict)

        if report_filename != None:
            if &#34;.csv&#34; in report_filename[-4:]:
                out_dict[&#34;report&#34;].to_csv(report_filename)
            else:
                out_dict[&#34;report&#34;].to_csv(report_filename+&#34;.csv&#34;)

        if delete_generated_folders:
            self._delete_rxn_folders()
        
        if self.verbose &gt; 0:
            print(&#34;Finished!&#34;)
        
        return speciation</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation"><code class="flex name class">
<span>class <span class="ident">Speciation</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the output of a speciation calculation.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>input</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe containing user-supplied sample chemistry data.</dd>
<dt><strong><code>mass_contribution</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe containing basis species contributions to mass balance
of aqueous species.</dd>
<dt><strong><code>batch_3o</code></strong> :&ensp;<code>rpy2 ListVector</code></dt>
<dd>An rpy2 ListVector (R object) containing speciation results, in case
analysis in R is preferred.</dd>
<dt><strong><code>report</code></strong> :&ensp;<code>pd.Dataframe</code></dt>
<dd>Pandas dataframe reporting major results of speciation calculation in
across all samples.</dd>
<dt><strong><code>report_divs</code></strong> :&ensp;<code>rpy2 ListVector</code></dt>
<dd>An rpy2 ListVector of column names within the different sections of the
speciation report.</dd>
<dt><strong><code>sample_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with sample names as keys and speciation results as values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Speciation(object):
    
    &#34;&#34;&#34;
    Stores the output of a speciation calculation.
    
    Attributes
    ----------
    input : pd.Dataframe
        Pandas dataframe containing user-supplied sample chemistry data.
    
    mass_contribution : pd.Dataframe
        Pandas dataframe containing basis species contributions to mass balance
        of aqueous species.
    
    batch_3o : rpy2 ListVector
        An rpy2 ListVector (R object) containing speciation results, in case
        analysis in R is preferred.
    
    report : pd.Dataframe
        Pandas dataframe reporting major results of speciation calculation in
        across all samples.
    
    report_divs : rpy2 ListVector
        An rpy2 ListVector of column names within the different sections of the
        speciation report.
    
    sample_data : dict
        Dictionary with sample names as keys and speciation results as values.
    
    &#34;&#34;&#34;
    
    def __init__(self, args):
        for k in args:
            setattr(self, k, args[k])

    def __getitem__(self, item):
         return getattr(self, item)
    
    @staticmethod
    def __unique(seq):
        &#34;&#34;&#34;
        Provide a sequence, get a list of non-repeating elements in the same order.
        &#34;&#34;&#34;
        seen = set()
        seen_add = seen.add
        return [x for x in seq if not (x in seen or seen_add(x))]

    
    def save(self, filename, messages=True):
        &#34;&#34;&#34;
        Save the speciation as a &#39;.speciation&#39; file to your current working
        directory. This file can be loaded with `AqEquil.load(filename)`.
        
        Parameters
        ----------
        filename : str
            The desired name of the file.
            
        messages : str
            Print a message confirming the save?
        &#34;&#34;&#34;
        
        if filename[-11:] != &#39;.speciation&#39;:
            filename = filename + &#39;.speciation&#39;
        
        with open(filename, &#39;wb&#39;) as handle:
            pickle.dump(self, handle, protocol=pickle.HIGHEST_PROTOCOL)
            if messages:
                print(&#34;Saved as &#39;{}&#39;&#34;.format(filename))
    
    
    @staticmethod
    def __get_unit_info(subheader):
        
        unit_name_dict = {
            &#34;pH&#34; : (&#34;&#34;, &#34;pH&#34;),
            &#34;ppm&#34; : (&#34;&#34;, &#34;ppm&#34;),
            &#34;ppb&#34; : (&#34;&#34;, &#34;ppb&#34;),
            &#34;mg/L&#34; : (&#34;&#34;, &#34;mg/L&#34;),
            &#34;degC&#34; : (&#34;temperature&#34;, &#34;°C&#34;),
            &#34;log_molality&#34; : (&#34;log molality&#34;, &#34;log(mol/kg)&#34;),
            &#34;Molality&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;molality&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;molal&#34; : (&#34;molality&#34;, &#34;mol/kg&#34;),
            &#34;log_activity&#34; : (&#34;log activity&#34;, &#34;&#34;),
            &#34;Log activity&#34; : (&#34;log activity&#34;, &#34;&#34;),
            &#34;mg/kg.sol&#34; : (&#34;&#34;, &#34;mg solute per kg solution&#34;),
            &#34;Alk., eq/kg.H2O&#34; : (&#34;alkalinity&#34;, &#34;eq/kg&#34;),
            &#34;Alk., eq/L&#34; : (&#34;alkalinity&#34;, &#34;eq/L&#34;),
            &#34;Alk., eq/kg.sol&#34; : (&#34;alkalinity&#34;, &#34;eq/kg solution&#34;),
            &#34;Alk., mg/L CaCO3&#34; : (&#34;alkalinity&#34;, &#34;mg/L CaCO3&#34;),
            &#34;Alk., mg/L HCO3-&#34; : (&#34;alkalinity&#34;, &#34;mg/L HCO3-&#34;),
            &#34;pX&#34; : (&#34;-(log activity)&#34;, &#34;-log(mol/kg)&#34;),
            &#34;activity&#34; : (&#34;activity&#34;, &#34;&#34;),
            &#34;log_gamma&#34; : (&#34;log gamma&#34;, &#34;log(kg/mol)&#34;),
            &#34;gamma&#34; : (&#34;gamma&#34;, &#34;kg/mol&#34;),
            &#34;affinity_kcal&#34; : (&#34;affinity&#34;, &#34;kcal/mol&#34;),
            &#34;%&#34; : (&#34;&#34;, &#34;%&#34;),
            &#34;Eh_volts&#34; : (&#34;Eh&#34;, &#34;volts&#34;),
            &#34;eq/kg.H2O&#34; : (&#34;charge&#34;, &#34;eq/kg&#34;),
            &#34;logfO2&#34; : (&#34;&#34;, &#34;&#34;),
            &#34;cal/kg.H2O&#34; : (&#34;energy supply&#34;, &#34;cal/kg H2O&#34;),
            &#34;Log ion-H+ activity ratio&#34; : (&#34;Log ion-H+ activity ratio&#34;, &#34;&#34;),
            &#34;log_fugacity&#34; : (&#34;log fugacity&#34;, &#34;log(bar)&#34;),
            &#34;fugacity&#34; : (&#34;fugacity&#34;, &#34;bar&#34;),
        }
        
        out = unit_name_dict.get(subheader)
        
        return out[0], out[1]
    
    
    def lookup(self, col=None):
        
        &#34;&#34;&#34;
        Look up desired columns in the speciation report.
        
        Parameters
        ----------
        col : str or list of str
            Leave blank to get a list of section names in the report:
            ```speciation.lookup()```
            Provide the name of a section to look up the names of columns in
            that section of the report:
            ```speciation.lookup(&#34;aq_distribution&#34;)```
            Provide a column name (or a list of column names) to retrieve the
            column from the report:
            ```speciation.lookup([&#34;Temperature&#34;, &#34;O2&#34;])```
            
        Returns
        ----------
        Pandas dataframe or list of str
            If a column name (or list of column names) is provided, returns the
            speciation report with only the desired column(s). Otherwise returns
            a list of section names (if no arguments are provided), or a list of
            columns in a section (if a section name is provided).
        &#34;&#34;&#34;
        
        if col==None and self.report_divs.named:
            return list(self.report_divs.names)
        
        if self.report_divs.named:
            if col in list(self.report_divs.names):
                return list(self.report_divs.rx2(col))
        
        if isinstance(col, str):
            col = [col]
        
        return self.report.iloc[:, self.report.columns.get_level_values(0).isin(set(col))]
    
    def __convert_aq_units_to_log_friendly(self, species, rows):

        col_data = self.lookup(species)
        
        col_data = col_data.loc[rows]
        
        if col_data.columns.get_level_values(1) == &#39;log_activity&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;activity&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_molality&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;molality&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_gamma&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;gamma&#39;
        elif col_data.columns.get_level_values(1) == &#39;log_fugacity&#39;:
            y = [10**float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = &#39;fugacity&#39;
        else:
            y = [float(s[0]) if s[0] != &#39;NA&#39; else float(&#34;nan&#34;) for s in col_data.values.tolist()]
            out_unit = col_data.columns.get_level_values(1)[0]
        return y, out_unit
    
    
    def plot_mineral_saturation(self, sample_name, mineral_sat_type=&#34;affinity&#34;,
                                yrange=None,
                                colors=[&#34;blue&#34;, &#34;orange&#34;], bg_color=&#34;white&#34;,
                                save_as=None):
        &#34;&#34;&#34;
        Vizualize mineral saturation states in a sample as a bar plot.
        
        Parameters
        ----------
        sample_name : str
            Name of the sample to plot.
        
        mineral_sat_type : str, default &#34;affinity&#34;
            Metric for mineral saturation state to plot. Can be &#34;affinity&#34; or
            &#34;logQoverK&#34;.
            
        yrange : list of numeric, optional
            Sets the lower and upper limits of the y axis.
        
        colors : list of two str, default [&#34;blue&#34;, &#34;orange&#34;]
            Sets the color of the bars representing supersaturated
            and undersaturated states, respectively.
        
        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        if sample_name not in self.report.index:
            msg = (&#34;Could not find &#39;{}&#39;&#34;.format(sample_name)+&#34; among sample &#34;
                   &#34;names in the speciation report. Sample names include &#34;
                   &#34;{}&#34;.format(list(self.report.index)))
            raise Exception(msg)
        

        
        if isinstance(self.sample_data[sample_name].get(&#39;mineral_sat&#39;, None), pd.DataFrame):
            mineral_data = self.sample_data[sample_name][&#39;mineral_sat&#39;][mineral_sat_type].astype(float).sort_values(ascending=False)
            x = mineral_data.index
        else:
            msg = (&#34;This sample does not have mineral saturation state data.&#34;
                   &#34;To generate this data, ensure get_mineral_sat=True when &#34;
                   &#34;running speciate(), or ensure this sample has &#34;
                   &#34;mineral-forming basis species.&#34;)
            raise Exception(msg)
            
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        plt.xticks(rotation = 45, ha=&#39;right&#39;)
        
        pos_sat = [m if m &gt;= 0 else float(&#34;nan&#34;) for m in mineral_data] # possibly: special list for m==0
        neg_sat = [m if m &lt; 0 else float(&#34;nan&#34;) for m in mineral_data]
        
        barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
        for i, y_plot in enumerate([pos_sat, neg_sat]):
            
            if i == 0:
                color = colors[0]
            else:
                color = colors[1]
                
            bars = ax.bar(x, y_plot, tick_label=x, color=color)
            
            barlist.append(bars)
            
            if mineral_sat_type == &#34;affinity&#34;:
                ylabel = &#39;affinity, kcal/mol&#39;
            if mineral_sat_type == &#34;logQoverK&#34;:
                ylabel = &#39;logQ/K&#39;
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])
        
        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    

    def barplot(self, y, yrange=None, convert_log=True, show_trace=True,
                show_legend=True, show_missing=True, legend_loc=&#34;best&#34;,
                colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
        
        &#34;&#34;&#34;
        Show a bar plot to vizualize one or more variables across all samples.
        
        Parameters
        ----------
        y : str or list of str
            Name (or list of names) of the variables to plot. Valid variables
            are columns in the speciation report.
       
        yrange : list of numeric, optional
            Sets the lower and upper limits of the y axis.
            
        convert_log : bool, default True
            Convert units &#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, and
            &#34;log_fugacity&#34; to &#34;activity&#34;, &#34;molality&#34;, &#34;gamma&#34;, and &#34;fugacity&#34;,
            respectively?
        
        show_trace : bool, default True
            Show asterisks for columns with numerical values but are too short
            to see clearly?
            
        show_legend : bool, default True
            Show a legend if there is more than one variable?
        
        show_missing : bool, default True
            Show samples that do not have bars?
        
        legend_loc : str or pair of float, default &#34;best&#34;
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        colormap : str, default &#34;viridis&#34;
            Name of the Matplotlib colormap to color the barplot. See
            https://matplotlib.org/stable/tutorials/colors/colormaps.html

        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        plt.xticks(rotation = 45, ha=&#39;right&#39;)

        if not isinstance(y, list):
            y = [y]
        
        y_cols = self.lookup(y)
        
        if not show_missing:
            y_cols = y_cols.dropna(how=&#39;all&#39;)
        
        x = y_cols.index # names of samples
        
        norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
        cmap = cm.__getattribute__(colormap)
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        X = np.arange(len(x))
        
        barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
        for i, yi in enumerate(y):
            y_col = y_cols.iloc[:, y_cols.columns.get_level_values(0)==yi]
            
            try:
                subheader = y_col.columns.get_level_values(1)[0]
            except:
                msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                       &#34;report. Available variables include &#34;
                      &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
                raise Exception(msg)
            try:
                unit_type, unit = self.__get_unit_info(subheader)
            except:
                unit_type = &#34;&#34;
                unit = &#34;&#34;
            
            try:
                y_vals = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
            except:
                msg = (&#34;One or more the values belonging to &#34;
                       &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0]))
                raise Exception(msg)
            
            if convert_log and [abs(y0) for y0 in y_vals] != y_vals: # convert to bar-friendly units if possible
                if subheader in [&#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, &#34;log_fugacity&#34;]:
                    y_plot, out_unit = self.__convert_aq_units_to_log_friendly(yi, rows=x)
                    unit_type, unit = self.__get_unit_info(out_unit)
                else:
                    y_plot = y_vals
            else:
                y_plot = y_vals
            
            if i == 0:
                subheader_previous = subheader
                unit_previous = unit
            if unit != unit_previous and i != 0:
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
                
            yi_previous = copy.deepcopy(yi)
            unit_previous = copy.deepcopy(unit)
            subheader_previous = copy.deepcopy(subheader)
            
            if len(y) != 1:
                color = m.to_rgba(i)
            else:
                color = &#34;black&#34;
            
            bars = ax.bar(X+i*(1/(len(y)+1)), y_plot, tick_label=x, color=color, width=1/(len(y)+1))
            
            barlist.append(bars)

        max_bar_height = 0
        for bars in barlist:
            for p in bars.patches:
                max_bar_height = np.nanmax([max_bar_height, abs(p.get_height())])
                
        for i,bars in enumerate(barlist):
            for p in bars.patches:
                if show_trace and abs(p.get_height())/max_bar_height &lt;= 0.009:
                    if len(y) != 1:
                        color = m.to_rgba(i)
                    else:
                        color = &#34;black&#34;
                
                    plt.annotate(&#34;*&#34;,
                                  (p.get_x() + p.get_width() / 2., p.get_height()),
                                  ha = &#39;center&#39;, va = &#39;center&#39;, xytext = (0, 10),
                                  color=color,
                                  weight=&#39;bold&#39;,
                                  fontsize=18,
                                  textcoords = &#39;offset points&#39;)
        
        if len(y) &gt; 1:
            if unit != &#34;&#34;:
                ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
            else:
                ylabel = unit_type
            if show_legend:
                ax.legend(labels=y, loc=legend_loc)
        else:
            if &#39;pH&#39; in y:
                ylabel = &#39;pH&#39;
            elif &#39;Temperature&#39; in y:
                ylabel = &#39;Temperature [°C]&#39;
            else:
                if unit != &#34;&#34;:
                    ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
                else:
                    ylabel = &#34;{} {}&#34;.format(y[0], unit_type)
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])
        
        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    
    
    def scatterplot(self, x=&#34;pH&#34;, y=&#34;Temperature&#34;, xrange=None, yrange=None,
                show_legend=True, legend_loc=&#34;best&#34;,
                colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
        
        &#34;&#34;&#34;
        Vizualize two or more sample variables with a scatterplot.
        
        Parameters
        ----------
        x, y : str, default for x is &#34;pH&#34;, default for y is &#34;Temperature&#34;
            Names of the variables to plot against each other. Valid variables
            are columns in the speciation report. `y` can be a list of
            of variable names for a multi-series scatterplot.
       
        xrange, yrange : list of numeric, optional
            Sets the lower and upper limits of the x and y axis.
            
        show_legend : bool, default True
            Show a legend if there is more than one variable?
        
        legend_loc : str or pair of float, default &#34;best&#34;
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        colormap : str, default &#34;viridis&#34;
            Name of the Matplotlib colormap to color the scatterpoints. See
            https://matplotlib.org/stable/tutorials/colors/colormaps.html

        bg_color : str, default &#34;white&#34;
            Name of the Matplotlib color you wish to set as the panel
            background. A list of named colors can be found here:
            https://matplotlib.org/stable/gallery/color/named_colors.html
            
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;

        if not isinstance(y, list):
            y = [y]
        
        if not isinstance(x, str):
            raise Exception(&#34;x must be a string.&#34;)
        
        x_col = self.lookup(x)
        
        try:
            xsubheader = x_col.columns.get_level_values(1)[0]
        except:
            msg = (&#34;Could not find &#39;{}&#39; &#34;.format(x)+&#34;in the speciation &#34;
                   &#34;report. Available variables include &#34;
                   &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
            raise Exception(msg)
            
        try:
            x_plot = [float(x0[0]) if x0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for x0 in x_col.values.tolist()]
        except:
            msg = (&#34;One or more the values belonging to &#34;
                   &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(x_col.columns.get_level_values(0)[0]))
            raise Exception(msg)
        
        try:
            xunit_type, xunit = self.__get_unit_info(xsubheader)
        except:
            xunit_type = &#34;&#34;
            xunit = &#34;&#34;
        
        norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
        cmap = cm.__getattribute__(colormap)
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        
        fig = plt.figure()
        ax = fig.add_axes([0,0,1,1])
        
        for i, yi in enumerate(y):
            y_col = self.lookup(yi)
            
            try:
                subheader = y_col.columns.get_level_values(1)[0]
            except:
                msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                       &#34;report. Available variables include &#34;
                      &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
                raise Exception(msg)
            try:
                unit_type, unit = self.__get_unit_info(subheader)
            except:
                unit_type = &#34;&#34;
                unit = &#34;&#34;
            
            try:
                y_plot = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
            except:
                msg = (&#34;One or more the values belonging to &#34;
                       &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0]))
                raise Exception(msg)
                
            if i == 0:
                subheader_previous = subheader
                unit_previous = unit
            if unit != unit_previous and i != 0:
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
            elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
                msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                       &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                       &#34;Plotted variables must share units.&#34;)
                raise Exception(msg)
                
            yi_previous = copy.deepcopy(yi)
            unit_previous = copy.deepcopy(unit)
            subheader_previous = copy.deepcopy(subheader)
            
            if len(y) != 1:
                color = m.to_rgba(i)
            else:
                color = &#34;black&#34;
            
            plt.scatter(x_plot, y_plot, marker=&#39;o&#39;, color=color)

        if len(y) &gt; 1:
            if unit != &#34;&#34;:
                ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
            else:
                ylabel = unit_type
            if show_legend:
                ax.legend(labels=y, loc=legend_loc)
        else:
            if &#39;pH&#39; in y:
                ylabel = &#39;pH&#39;
            elif &#39;Temperature&#39; in y:
                ylabel = &#39;Temperature [°C]&#39;
            else:
                if unit != &#34;&#34;:
                    ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
                else:
                    ylabel = &#34;{} {}&#34;.format(y[0], unit_type)
        
        if x == &#39;pH&#39;:
            xlabel = &#39;pH&#39;
        elif x == &#39;Temperature&#39;:
            xlabel = &#39;Temperature [°C]&#39;
        else:
            if xunit != &#34;&#34;:
                xlabel = &#34;{} {} [{}]&#34;.format(x, xunit_type, xunit)
            else:
                xlabel = &#34;{} {}&#34;.format(x, xunit_type)
        
        if xrange != None:
            plt.xlim(xrange[0], xrange[1])
        
        if yrange != None:
            plt.ylim(yrange[0], yrange[1])

        ax.set_facecolor(bg_color)
        plt.ylabel(ylabel)
        plt.xlabel(xlabel)

        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
        
        plt.show()
    
    
    def plot_mass_contribution(self, basis, sort_by=None, ascending=True,
                                     sort_y_by=None, width=0.9,
                                     legend_loc=(1.02, 0.5),
                                     save_as=None):
        
        &#34;&#34;&#34;
        Plot basis species contributions to mass balance of aqueous species
        across all samples.
        
        Parameters
        ----------
        basis : str
            Name of the basis species.
            
        sort_by : str, optional
            Name of the variable used to sort samples. Variable names must be
            taken from the speciation report column names. No sorting is done by
            default.
        
        ascending : bool, default True
            Should sample sorting be in ascending order? Descending if False.
            Ignored unless `sort_by` is defined.
        
        sort_y_by : list of str, optional
            List of species names in the order that they should be stacked, from
            the bottom of the plot to the top.
        
        width : float, default 0.9
            Width of bars. No space between bars if width=1.0.
        
        legend_loc : str or pair of float, default (1.02, 0.5)
            Location of the legend on the plot. See
            https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
        
        save_as : str, optional
            Provide a filename to save this figure as a PNG.
        &#34;&#34;&#34;
        
        try:
            self.mass_contribution
        except:
            msg = (&#34;Results for basis species contributions to aqueous mass &#34;
                   &#34;balance could not be found. Ensure that &#34;
                   &#34;get_mass_contribution = True when running speciate().&#34;)
            raise Exception(msg)
            
        if basis not in set(self.mass_contribution[&#39;basis&#39;]):
            msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
                   &#34;among available basis species: &#34;
                   &#34;{}&#34;.format(str(list(set(self.mass_contribution[&#39;basis&#39;])))))
            raise Exception(msg)
            
        df_sp = copy.deepcopy(self.mass_contribution.loc[self.mass_contribution[&#39;basis&#39;] == basis])
        
        if sort_by != None:
            if sort_by in self.report.columns.get_level_values(0):
                sort_col = self.lookup(sort_by)
                sort_by_unit = sort_col.columns.get_level_values(1)[0]
                sort_index = sort_col.sort_values([(sort_by, sort_by_unit)], ascending=ascending).index
                
                df_list = []
                for i in sort_index:
                    df_list.append(df_sp[df_sp[&#39;sample&#39;]==i])

                df_sp = pd.concat(df_list)
                
            else:
                msg = (&#34;Could not find {}&#34;.format(sort_by)+&#34; in the &#34;
                       &#34;speciation report. Available variables include &#34;
                       &#34;{}&#34;.format(list(self.report.columns.get_level_values(0))))
                raise Exception(msg)
        
        df_sp[&#39;percent&#39;] = df_sp[&#39;percent&#39;].astype(float)
        
        unique_species = self.__unique(df_sp[&#34;species&#34;])
        
        if &#34;Other&#34; in unique_species:

            unique_species.append(unique_species.pop(unique_species.index(&#34;Other&#34;)))
        
        labels = self.__unique(df_sp[&#34;sample&#34;])

        bottom = np.array([0]*len(labels))

        if sort_y_by != None:
            if isinstance(sort_y_by, list):
                if len(unique_species) == len(sort_y_by):
                    if len([s for s in unique_species if s in sort_y_by]) == len(unique_species) and len([s for s in sort_y_by if s in unique_species]) == len(unique_species):
                        unique_species = sort_y_by
                    else:
                        valid_needed = [s for s in unique_species if s not in sort_y_by]
                        invalid = [s for s in sort_y_by if s not in unique_species]
                        msg = (&#34;sort_y_by is missing the following species: &#34;
                               &#34;{}&#34;.format(valid_needed)+&#34; and was provided &#34;
                               &#34;these invalid species: {}&#34;.format(invalid))
                        raise Exception(msg)
                        
                elif len(sort_y_by) &lt; len(unique_species):
                    msg = (&#34;sort_y_by must have of all of the &#34;
                           &#34;following species: {}&#34;.format(unique_species)+&#34;. &#34;
                           &#34;You are missing {}&#34;.format([s for s in unique_species if s not in sort_y_by]))
                    raise Exception(msg)
                else:
                    msg = (&#34;sort_y_by can only have the &#34;
                           &#34;following species: {}&#34;.format(unique_species)+&#34;.&#34;)
                    raise Exception(msg)
            else:
                raise Exception(&#34;sort_y_by must be a list of species names.&#34;)
                
        fig, ax = plt.subplots()
        
        for i,sp in enumerate(unique_species):
            percents = []
            for sample in labels:
                df_sample = df_sp[df_sp[&#34;sample&#34;]==sample]
                try:
                    percent = df_sample[df_sample[&#34;species&#34;]==sp][&#34;percent&#34;].iloc[0]
                    percents.append(percent)
                except:
                    percents.append(0.0)
            ax.bar(labels, percents, width, bottom=bottom, label=sp)
            bottom = bottom + np.array(percents)

        ax.set_ylabel(&#39;mole %&#39;)
        ax.set_title(&#39;Species accounting for mass balance of &#39;+basis)
        plt.xticks(rotation = 45, ha=&#39;right&#39;)
        ax.legend(loc=legend_loc)
        
        if save_as != None:
            if &#34;.png&#34; not in save_as[:-4]:
                save_as = save_as+&#34;.png&#34;
            
            plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
            print(&#34;Saved figure as {}&#34;.format(save_as))
            
        plt.show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AqEquil.AqSpeciation.Speciation.barplot"><code class="name flex">
<span>def <span class="ident">barplot</span></span>(<span>self, y, yrange=None, convert_log=True, show_trace=True, show_legend=True, show_missing=True, legend_loc='best', colormap='viridis', bg_color='white', save_as=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a bar plot to vizualize one or more variables across all samples.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Name (or list of names) of the variables to plot. Valid variables
are columns in the speciation report.</dd>
<dt><strong><code>yrange</code></strong> :&ensp;<code>list</code> of <code>numeric</code>, optional</dt>
<dd>Sets the lower and upper limits of the y axis.</dd>
<dt><strong><code>convert_log</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Convert units "log_activity", "log_molality", "log_gamma", and
"log_fugacity" to "activity", "molality", "gamma", and "fugacity",
respectively?</dd>
<dt><strong><code>show_trace</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show asterisks for columns with numerical values but are too short
to see clearly?</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show a legend if there is more than one variable?</dd>
<dt><strong><code>show_missing</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show samples that do not have bars?</dd>
<dt><strong><code>legend_loc</code></strong> :&ensp;<code>str</code> or <code>pair</code> of <code>float</code>, default <code>"best"</code></dt>
<dd>Location of the legend on the plot. See
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend">https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend</a></dd>
<dt><strong><code>colormap</code></strong> :&ensp;<code>str</code>, default <code>"viridis"</code></dt>
<dd>Name of the Matplotlib colormap to color the barplot. See
<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">https://matplotlib.org/stable/tutorials/colors/colormaps.html</a></dd>
<dt><strong><code>bg_color</code></strong> :&ensp;<code>str</code>, default <code>"white"</code></dt>
<dd>Name of the Matplotlib color you wish to set as the panel
background. A list of named colors can be found here:
<a href="https://matplotlib.org/stable/gallery/color/named_colors.html">https://matplotlib.org/stable/gallery/color/named_colors.html</a></dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure as a PNG.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def barplot(self, y, yrange=None, convert_log=True, show_trace=True,
            show_legend=True, show_missing=True, legend_loc=&#34;best&#34;,
            colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
    
    &#34;&#34;&#34;
    Show a bar plot to vizualize one or more variables across all samples.
    
    Parameters
    ----------
    y : str or list of str
        Name (or list of names) of the variables to plot. Valid variables
        are columns in the speciation report.
   
    yrange : list of numeric, optional
        Sets the lower and upper limits of the y axis.
        
    convert_log : bool, default True
        Convert units &#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, and
        &#34;log_fugacity&#34; to &#34;activity&#34;, &#34;molality&#34;, &#34;gamma&#34;, and &#34;fugacity&#34;,
        respectively?
    
    show_trace : bool, default True
        Show asterisks for columns with numerical values but are too short
        to see clearly?
        
    show_legend : bool, default True
        Show a legend if there is more than one variable?
    
    show_missing : bool, default True
        Show samples that do not have bars?
    
    legend_loc : str or pair of float, default &#34;best&#34;
        Location of the legend on the plot. See
        https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
    
    colormap : str, default &#34;viridis&#34;
        Name of the Matplotlib colormap to color the barplot. See
        https://matplotlib.org/stable/tutorials/colors/colormaps.html

    bg_color : str, default &#34;white&#34;
        Name of the Matplotlib color you wish to set as the panel
        background. A list of named colors can be found here:
        https://matplotlib.org/stable/gallery/color/named_colors.html
        
    save_as : str, optional
        Provide a filename to save this figure as a PNG.
    &#34;&#34;&#34;
    
    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])
    plt.xticks(rotation = 45, ha=&#39;right&#39;)

    if not isinstance(y, list):
        y = [y]
    
    y_cols = self.lookup(y)
    
    if not show_missing:
        y_cols = y_cols.dropna(how=&#39;all&#39;)
    
    x = y_cols.index # names of samples
    
    norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
    cmap = cm.__getattribute__(colormap)
    m = cm.ScalarMappable(norm=norm, cmap=cmap)
    X = np.arange(len(x))
    
    barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
    for i, yi in enumerate(y):
        y_col = y_cols.iloc[:, y_cols.columns.get_level_values(0)==yi]
        
        try:
            subheader = y_col.columns.get_level_values(1)[0]
        except:
            msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                   &#34;report. Available variables include &#34;
                  &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
            raise Exception(msg)
        try:
            unit_type, unit = self.__get_unit_info(subheader)
        except:
            unit_type = &#34;&#34;
            unit = &#34;&#34;
        
        try:
            y_vals = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
        except:
            msg = (&#34;One or more the values belonging to &#34;
                   &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0]))
            raise Exception(msg)
        
        if convert_log and [abs(y0) for y0 in y_vals] != y_vals: # convert to bar-friendly units if possible
            if subheader in [&#34;log_activity&#34;, &#34;log_molality&#34;, &#34;log_gamma&#34;, &#34;log_fugacity&#34;]:
                y_plot, out_unit = self.__convert_aq_units_to_log_friendly(yi, rows=x)
                unit_type, unit = self.__get_unit_info(out_unit)
            else:
                y_plot = y_vals
        else:
            y_plot = y_vals
        
        if i == 0:
            subheader_previous = subheader
            unit_previous = unit
        if unit != unit_previous and i != 0:
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
        elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
        elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
            
        yi_previous = copy.deepcopy(yi)
        unit_previous = copy.deepcopy(unit)
        subheader_previous = copy.deepcopy(subheader)
        
        if len(y) != 1:
            color = m.to_rgba(i)
        else:
            color = &#34;black&#34;
        
        bars = ax.bar(X+i*(1/(len(y)+1)), y_plot, tick_label=x, color=color, width=1/(len(y)+1))
        
        barlist.append(bars)

    max_bar_height = 0
    for bars in barlist:
        for p in bars.patches:
            max_bar_height = np.nanmax([max_bar_height, abs(p.get_height())])
            
    for i,bars in enumerate(barlist):
        for p in bars.patches:
            if show_trace and abs(p.get_height())/max_bar_height &lt;= 0.009:
                if len(y) != 1:
                    color = m.to_rgba(i)
                else:
                    color = &#34;black&#34;
            
                plt.annotate(&#34;*&#34;,
                              (p.get_x() + p.get_width() / 2., p.get_height()),
                              ha = &#39;center&#39;, va = &#39;center&#39;, xytext = (0, 10),
                              color=color,
                              weight=&#39;bold&#39;,
                              fontsize=18,
                              textcoords = &#39;offset points&#39;)
    
    if len(y) &gt; 1:
        if unit != &#34;&#34;:
            ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
        else:
            ylabel = unit_type
        if show_legend:
            ax.legend(labels=y, loc=legend_loc)
    else:
        if &#39;pH&#39; in y:
            ylabel = &#39;pH&#39;
        elif &#39;Temperature&#39; in y:
            ylabel = &#39;Temperature [°C]&#39;
        else:
            if unit != &#34;&#34;:
                ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
            else:
                ylabel = &#34;{} {}&#34;.format(y[0], unit_type)
    
    if yrange != None:
        plt.ylim(yrange[0], yrange[1])
    
    ax.set_facecolor(bg_color)
    plt.ylabel(ylabel)

    if save_as != None:
        if &#34;.png&#34; not in save_as[:-4]:
            save_as = save_as+&#34;.png&#34;
        
        plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
        print(&#34;Saved figure as {}&#34;.format(save_as))
    
    plt.show()</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.lookup"><code class="name flex">
<span>def <span class="ident">lookup</span></span>(<span>self, col=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Look up desired columns in the speciation report.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>col</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Leave blank to get a list of section names in the report:
<code>speciation.lookup()</code>
Provide the name of a section to look up the names of columns in
that section of the report:
<code>speciation.lookup("aq_distribution")</code>
Provide a column name (or a list of column names) to retrieve the
column from the report:
<code>speciation.lookup(["Temperature", "O2"])</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Pandas dataframe</code> or <code>list</code> of <code>str</code></dt>
<dd>If a column name (or list of column names) is provided, returns the
speciation report with only the desired column(s). Otherwise returns
a list of section names (if no arguments are provided), or a list of
columns in a section (if a section name is provided).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup(self, col=None):
    
    &#34;&#34;&#34;
    Look up desired columns in the speciation report.
    
    Parameters
    ----------
    col : str or list of str
        Leave blank to get a list of section names in the report:
        ```speciation.lookup()```
        Provide the name of a section to look up the names of columns in
        that section of the report:
        ```speciation.lookup(&#34;aq_distribution&#34;)```
        Provide a column name (or a list of column names) to retrieve the
        column from the report:
        ```speciation.lookup([&#34;Temperature&#34;, &#34;O2&#34;])```
        
    Returns
    ----------
    Pandas dataframe or list of str
        If a column name (or list of column names) is provided, returns the
        speciation report with only the desired column(s). Otherwise returns
        a list of section names (if no arguments are provided), or a list of
        columns in a section (if a section name is provided).
    &#34;&#34;&#34;
    
    if col==None and self.report_divs.named:
        return list(self.report_divs.names)
    
    if self.report_divs.named:
        if col in list(self.report_divs.names):
            return list(self.report_divs.rx2(col))
    
    if isinstance(col, str):
        col = [col]
    
    return self.report.iloc[:, self.report.columns.get_level_values(0).isin(set(col))]</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.plot_mass_contribution"><code class="name flex">
<span>def <span class="ident">plot_mass_contribution</span></span>(<span>self, basis, sort_by=None, ascending=True, sort_y_by=None, width=0.9, legend_loc=(1.02, 0.5), save_as=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot basis species contributions to mass balance of aqueous species
across all samples.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>basis</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the basis species.</dd>
<dt><strong><code>sort_by</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the variable used to sort samples. Variable names must be
taken from the speciation report column names. No sorting is done by
default.</dd>
<dt><strong><code>ascending</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Should sample sorting be in ascending order? Descending if False.
Ignored unless <code>sort_by</code> is defined.</dd>
<dt><strong><code>sort_y_by</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of species names in the order that they should be stacked, from
the bottom of the plot to the top.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code>, default <code>0.9</code></dt>
<dd>Width of bars. No space between bars if width=1.0.</dd>
<dt><strong><code>legend_loc</code></strong> :&ensp;<code>str</code> or <code>pair</code> of <code>float</code>, default <code>(1.02, 0.5)</code></dt>
<dd>Location of the legend on the plot. See
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend">https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend</a></dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure as a PNG.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mass_contribution(self, basis, sort_by=None, ascending=True,
                                 sort_y_by=None, width=0.9,
                                 legend_loc=(1.02, 0.5),
                                 save_as=None):
    
    &#34;&#34;&#34;
    Plot basis species contributions to mass balance of aqueous species
    across all samples.
    
    Parameters
    ----------
    basis : str
        Name of the basis species.
        
    sort_by : str, optional
        Name of the variable used to sort samples. Variable names must be
        taken from the speciation report column names. No sorting is done by
        default.
    
    ascending : bool, default True
        Should sample sorting be in ascending order? Descending if False.
        Ignored unless `sort_by` is defined.
    
    sort_y_by : list of str, optional
        List of species names in the order that they should be stacked, from
        the bottom of the plot to the top.
    
    width : float, default 0.9
        Width of bars. No space between bars if width=1.0.
    
    legend_loc : str or pair of float, default (1.02, 0.5)
        Location of the legend on the plot. See
        https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
    
    save_as : str, optional
        Provide a filename to save this figure as a PNG.
    &#34;&#34;&#34;
    
    try:
        self.mass_contribution
    except:
        msg = (&#34;Results for basis species contributions to aqueous mass &#34;
               &#34;balance could not be found. Ensure that &#34;
               &#34;get_mass_contribution = True when running speciate().&#34;)
        raise Exception(msg)
        
    if basis not in set(self.mass_contribution[&#39;basis&#39;]):
        msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
               &#34;among available basis species: &#34;
               &#34;{}&#34;.format(str(list(set(self.mass_contribution[&#39;basis&#39;])))))
        raise Exception(msg)
        
    df_sp = copy.deepcopy(self.mass_contribution.loc[self.mass_contribution[&#39;basis&#39;] == basis])
    
    if sort_by != None:
        if sort_by in self.report.columns.get_level_values(0):
            sort_col = self.lookup(sort_by)
            sort_by_unit = sort_col.columns.get_level_values(1)[0]
            sort_index = sort_col.sort_values([(sort_by, sort_by_unit)], ascending=ascending).index
            
            df_list = []
            for i in sort_index:
                df_list.append(df_sp[df_sp[&#39;sample&#39;]==i])

            df_sp = pd.concat(df_list)
            
        else:
            msg = (&#34;Could not find {}&#34;.format(sort_by)+&#34; in the &#34;
                   &#34;speciation report. Available variables include &#34;
                   &#34;{}&#34;.format(list(self.report.columns.get_level_values(0))))
            raise Exception(msg)
    
    df_sp[&#39;percent&#39;] = df_sp[&#39;percent&#39;].astype(float)
    
    unique_species = self.__unique(df_sp[&#34;species&#34;])
    
    if &#34;Other&#34; in unique_species:

        unique_species.append(unique_species.pop(unique_species.index(&#34;Other&#34;)))
    
    labels = self.__unique(df_sp[&#34;sample&#34;])

    bottom = np.array([0]*len(labels))

    if sort_y_by != None:
        if isinstance(sort_y_by, list):
            if len(unique_species) == len(sort_y_by):
                if len([s for s in unique_species if s in sort_y_by]) == len(unique_species) and len([s for s in sort_y_by if s in unique_species]) == len(unique_species):
                    unique_species = sort_y_by
                else:
                    valid_needed = [s for s in unique_species if s not in sort_y_by]
                    invalid = [s for s in sort_y_by if s not in unique_species]
                    msg = (&#34;sort_y_by is missing the following species: &#34;
                           &#34;{}&#34;.format(valid_needed)+&#34; and was provided &#34;
                           &#34;these invalid species: {}&#34;.format(invalid))
                    raise Exception(msg)
                    
            elif len(sort_y_by) &lt; len(unique_species):
                msg = (&#34;sort_y_by must have of all of the &#34;
                       &#34;following species: {}&#34;.format(unique_species)+&#34;. &#34;
                       &#34;You are missing {}&#34;.format([s for s in unique_species if s not in sort_y_by]))
                raise Exception(msg)
            else:
                msg = (&#34;sort_y_by can only have the &#34;
                       &#34;following species: {}&#34;.format(unique_species)+&#34;.&#34;)
                raise Exception(msg)
        else:
            raise Exception(&#34;sort_y_by must be a list of species names.&#34;)
            
    fig, ax = plt.subplots()
    
    for i,sp in enumerate(unique_species):
        percents = []
        for sample in labels:
            df_sample = df_sp[df_sp[&#34;sample&#34;]==sample]
            try:
                percent = df_sample[df_sample[&#34;species&#34;]==sp][&#34;percent&#34;].iloc[0]
                percents.append(percent)
            except:
                percents.append(0.0)
        ax.bar(labels, percents, width, bottom=bottom, label=sp)
        bottom = bottom + np.array(percents)

    ax.set_ylabel(&#39;mole %&#39;)
    ax.set_title(&#39;Species accounting for mass balance of &#39;+basis)
    plt.xticks(rotation = 45, ha=&#39;right&#39;)
    ax.legend(loc=legend_loc)
    
    if save_as != None:
        if &#34;.png&#34; not in save_as[:-4]:
            save_as = save_as+&#34;.png&#34;
        
        plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
        print(&#34;Saved figure as {}&#34;.format(save_as))
        
    plt.show()</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.plot_mineral_saturation"><code class="name flex">
<span>def <span class="ident">plot_mineral_saturation</span></span>(<span>self, sample_name, mineral_sat_type='affinity', yrange=None, colors=['blue', 'orange'], bg_color='white', save_as=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Vizualize mineral saturation states in a sample as a bar plot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sample_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the sample to plot.</dd>
<dt><strong><code>mineral_sat_type</code></strong> :&ensp;<code>str</code>, default <code>"affinity"</code></dt>
<dd>Metric for mineral saturation state to plot. Can be "affinity" or
"logQoverK".</dd>
<dt><strong><code>yrange</code></strong> :&ensp;<code>list</code> of <code>numeric</code>, optional</dt>
<dd>Sets the lower and upper limits of the y axis.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>list</code> of <code>two str</code>, default <code>["blue", "orange"]</code></dt>
<dd>Sets the color of the bars representing supersaturated
and undersaturated states, respectively.</dd>
<dt><strong><code>bg_color</code></strong> :&ensp;<code>str</code>, default <code>"white"</code></dt>
<dd>Name of the Matplotlib color you wish to set as the panel
background. A list of named colors can be found here:
<a href="https://matplotlib.org/stable/gallery/color/named_colors.html">https://matplotlib.org/stable/gallery/color/named_colors.html</a></dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure as a PNG.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mineral_saturation(self, sample_name, mineral_sat_type=&#34;affinity&#34;,
                            yrange=None,
                            colors=[&#34;blue&#34;, &#34;orange&#34;], bg_color=&#34;white&#34;,
                            save_as=None):
    &#34;&#34;&#34;
    Vizualize mineral saturation states in a sample as a bar plot.
    
    Parameters
    ----------
    sample_name : str
        Name of the sample to plot.
    
    mineral_sat_type : str, default &#34;affinity&#34;
        Metric for mineral saturation state to plot. Can be &#34;affinity&#34; or
        &#34;logQoverK&#34;.
        
    yrange : list of numeric, optional
        Sets the lower and upper limits of the y axis.
    
    colors : list of two str, default [&#34;blue&#34;, &#34;orange&#34;]
        Sets the color of the bars representing supersaturated
        and undersaturated states, respectively.
    
    bg_color : str, default &#34;white&#34;
        Name of the Matplotlib color you wish to set as the panel
        background. A list of named colors can be found here:
        https://matplotlib.org/stable/gallery/color/named_colors.html
        
    save_as : str, optional
        Provide a filename to save this figure as a PNG.
    &#34;&#34;&#34;
    
    if sample_name not in self.report.index:
        msg = (&#34;Could not find &#39;{}&#39;&#34;.format(sample_name)+&#34; among sample &#34;
               &#34;names in the speciation report. Sample names include &#34;
               &#34;{}&#34;.format(list(self.report.index)))
        raise Exception(msg)
    

    
    if isinstance(self.sample_data[sample_name].get(&#39;mineral_sat&#39;, None), pd.DataFrame):
        mineral_data = self.sample_data[sample_name][&#39;mineral_sat&#39;][mineral_sat_type].astype(float).sort_values(ascending=False)
        x = mineral_data.index
    else:
        msg = (&#34;This sample does not have mineral saturation state data.&#34;
               &#34;To generate this data, ensure get_mineral_sat=True when &#34;
               &#34;running speciate(), or ensure this sample has &#34;
               &#34;mineral-forming basis species.&#34;)
        raise Exception(msg)
        
    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])
    plt.xticks(rotation = 45, ha=&#39;right&#39;)
    
    pos_sat = [m if m &gt;= 0 else float(&#34;nan&#34;) for m in mineral_data] # possibly: special list for m==0
    neg_sat = [m if m &lt; 0 else float(&#34;nan&#34;) for m in mineral_data]
    
    barlist = [] # stores sets of bars in the bar chart so they can referenced for annotation
    for i, y_plot in enumerate([pos_sat, neg_sat]):
        
        if i == 0:
            color = colors[0]
        else:
            color = colors[1]
            
        bars = ax.bar(x, y_plot, tick_label=x, color=color)
        
        barlist.append(bars)
        
        if mineral_sat_type == &#34;affinity&#34;:
            ylabel = &#39;affinity, kcal/mol&#39;
        if mineral_sat_type == &#34;logQoverK&#34;:
            ylabel = &#39;logQ/K&#39;
    
    if yrange != None:
        plt.ylim(yrange[0], yrange[1])
    
    ax.set_facecolor(bg_color)
    plt.ylabel(ylabel)

    if save_as != None:
        if &#34;.png&#34; not in save_as[:-4]:
            save_as = save_as+&#34;.png&#34;
        
        plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
        print(&#34;Saved figure as {}&#34;.format(save_as))
    
    plt.show()</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename, messages=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the speciation as a '.speciation' file to your current working
directory. This file can be loaded with <code>AqEquil.load(filename)</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The desired name of the file.</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>str</code></dt>
<dd>Print a message confirming the save?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename, messages=True):
    &#34;&#34;&#34;
    Save the speciation as a &#39;.speciation&#39; file to your current working
    directory. This file can be loaded with `AqEquil.load(filename)`.
    
    Parameters
    ----------
    filename : str
        The desired name of the file.
        
    messages : str
        Print a message confirming the save?
    &#34;&#34;&#34;
    
    if filename[-11:] != &#39;.speciation&#39;:
        filename = filename + &#39;.speciation&#39;
    
    with open(filename, &#39;wb&#39;) as handle:
        pickle.dump(self, handle, protocol=pickle.HIGHEST_PROTOCOL)
        if messages:
            print(&#34;Saved as &#39;{}&#39;&#34;.format(filename))</code></pre>
</details>
</dd>
<dt id="AqEquil.AqSpeciation.Speciation.scatterplot"><code class="name flex">
<span>def <span class="ident">scatterplot</span></span>(<span>self, x='pH', y='Temperature', xrange=None, yrange=None, show_legend=True, legend_loc='best', colormap='viridis', bg_color='white', save_as=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Vizualize two or more sample variables with a scatterplot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>str</code>, default <code>for x is "pH"</code>, default <code>for y is "Temperature"</code></dt>
<dd>Names of the variables to plot against each other. Valid variables
are columns in the speciation report. <code>y</code> can be a list of
of variable names for a multi-series scatterplot.</dd>
<dt><strong><code>xrange</code></strong>, <strong><code>yrange</code></strong> :&ensp;<code>list</code> of <code>numeric</code>, optional</dt>
<dd>Sets the lower and upper limits of the x and y axis.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show a legend if there is more than one variable?</dd>
<dt><strong><code>legend_loc</code></strong> :&ensp;<code>str</code> or <code>pair</code> of <code>float</code>, default <code>"best"</code></dt>
<dd>Location of the legend on the plot. See
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend">https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend</a></dd>
<dt><strong><code>colormap</code></strong> :&ensp;<code>str</code>, default <code>"viridis"</code></dt>
<dd>Name of the Matplotlib colormap to color the scatterpoints. See
<a href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">https://matplotlib.org/stable/tutorials/colors/colormaps.html</a></dd>
<dt><strong><code>bg_color</code></strong> :&ensp;<code>str</code>, default <code>"white"</code></dt>
<dd>Name of the Matplotlib color you wish to set as the panel
background. A list of named colors can be found here:
<a href="https://matplotlib.org/stable/gallery/color/named_colors.html">https://matplotlib.org/stable/gallery/color/named_colors.html</a></dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure as a PNG.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatterplot(self, x=&#34;pH&#34;, y=&#34;Temperature&#34;, xrange=None, yrange=None,
            show_legend=True, legend_loc=&#34;best&#34;,
            colormap=&#34;viridis&#34;, bg_color=&#34;white&#34;, save_as=None):
    
    &#34;&#34;&#34;
    Vizualize two or more sample variables with a scatterplot.
    
    Parameters
    ----------
    x, y : str, default for x is &#34;pH&#34;, default for y is &#34;Temperature&#34;
        Names of the variables to plot against each other. Valid variables
        are columns in the speciation report. `y` can be a list of
        of variable names for a multi-series scatterplot.
   
    xrange, yrange : list of numeric, optional
        Sets the lower and upper limits of the x and y axis.
        
    show_legend : bool, default True
        Show a legend if there is more than one variable?
    
    legend_loc : str or pair of float, default &#34;best&#34;
        Location of the legend on the plot. See
        https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html#matplotlib.axes.Axes.legend
    
    colormap : str, default &#34;viridis&#34;
        Name of the Matplotlib colormap to color the scatterpoints. See
        https://matplotlib.org/stable/tutorials/colors/colormaps.html

    bg_color : str, default &#34;white&#34;
        Name of the Matplotlib color you wish to set as the panel
        background. A list of named colors can be found here:
        https://matplotlib.org/stable/gallery/color/named_colors.html
        
    save_as : str, optional
        Provide a filename to save this figure as a PNG.
    &#34;&#34;&#34;

    if not isinstance(y, list):
        y = [y]
    
    if not isinstance(x, str):
        raise Exception(&#34;x must be a string.&#34;)
    
    x_col = self.lookup(x)
    
    try:
        xsubheader = x_col.columns.get_level_values(1)[0]
    except:
        msg = (&#34;Could not find &#39;{}&#39; &#34;.format(x)+&#34;in the speciation &#34;
               &#34;report. Available variables include &#34;
               &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
        raise Exception(msg)
        
    try:
        x_plot = [float(x0[0]) if x0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for x0 in x_col.values.tolist()]
    except:
        msg = (&#34;One or more the values belonging to &#34;
               &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(x_col.columns.get_level_values(0)[0]))
        raise Exception(msg)
    
    try:
        xunit_type, xunit = self.__get_unit_info(xsubheader)
    except:
        xunit_type = &#34;&#34;
        xunit = &#34;&#34;
    
    norm = matplotlib.colors.Normalize(vmin=0, vmax=len(y)-1)
    cmap = cm.__getattribute__(colormap)
    m = cm.ScalarMappable(norm=norm, cmap=cmap)
    
    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])
    
    for i, yi in enumerate(y):
        y_col = self.lookup(yi)
        
        try:
            subheader = y_col.columns.get_level_values(1)[0]
        except:
            msg = (&#34;Could not find &#39;{}&#39; &#34;.format(yi)+&#34;in the speciation &#34;
                   &#34;report. Available variables include &#34;
                  &#34;{}&#34;.format(list(set(self.report.columns.get_level_values(0)))))
            raise Exception(msg)
        try:
            unit_type, unit = self.__get_unit_info(subheader)
        except:
            unit_type = &#34;&#34;
            unit = &#34;&#34;
        
        try:
            y_plot = [float(y0[0]) if y0[0] != &#39;NA&#39; else float(&#34;nan&#34;) for y0 in y_col.values.tolist()]
        except:
            msg = (&#34;One or more the values belonging to &#34;
                   &#34;&#39;{}&#39; are non-numeric and cannot be plotted.&#34;.format(y_col.columns.get_level_values(0)[0]))
            raise Exception(msg)
            
        if i == 0:
            subheader_previous = subheader
            unit_previous = unit
        if unit != unit_previous and i != 0:
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(unit, yi_previous, unit_previous)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
        elif &#34;activity&#34; in subheader.lower() and &#34;molality&#34; in subheader_previous.lower():
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(&#34;activity&#34;, yi_previous, &#34;molality&#34;)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
        elif &#34;molality&#34; in subheader.lower() and &#34;activity&#34; in subheader_previous.lower():
            msg = (&#34;{} has a different unit of measurement &#34;.format(yi)+&#34;&#34;
                   &#34;({}) than {} ({}). &#34;.format(&#34;molality&#34;, yi_previous, &#34;activity&#34;)+&#34;&#34;
                   &#34;Plotted variables must share units.&#34;)
            raise Exception(msg)
            
        yi_previous = copy.deepcopy(yi)
        unit_previous = copy.deepcopy(unit)
        subheader_previous = copy.deepcopy(subheader)
        
        if len(y) != 1:
            color = m.to_rgba(i)
        else:
            color = &#34;black&#34;
        
        plt.scatter(x_plot, y_plot, marker=&#39;o&#39;, color=color)

    if len(y) &gt; 1:
        if unit != &#34;&#34;:
            ylabel = &#34;{} [{}]&#34;.format(unit_type, unit)
        else:
            ylabel = unit_type
        if show_legend:
            ax.legend(labels=y, loc=legend_loc)
    else:
        if &#39;pH&#39; in y:
            ylabel = &#39;pH&#39;
        elif &#39;Temperature&#39; in y:
            ylabel = &#39;Temperature [°C]&#39;
        else:
            if unit != &#34;&#34;:
                ylabel = &#34;{} {} [{}]&#34;.format(y[0], unit_type, unit)
            else:
                ylabel = &#34;{} {}&#34;.format(y[0], unit_type)
    
    if x == &#39;pH&#39;:
        xlabel = &#39;pH&#39;
    elif x == &#39;Temperature&#39;:
        xlabel = &#39;Temperature [°C]&#39;
    else:
        if xunit != &#34;&#34;:
            xlabel = &#34;{} {} [{}]&#34;.format(x, xunit_type, xunit)
        else:
            xlabel = &#34;{} {}&#34;.format(x, xunit_type)
    
    if xrange != None:
        plt.xlim(xrange[0], xrange[1])
    
    if yrange != None:
        plt.ylim(yrange[0], yrange[1])

    ax.set_facecolor(bg_color)
    plt.ylabel(ylabel)
    plt.xlabel(xlabel)

    if save_as != None:
        if &#34;.png&#34; not in save_as[:-4]:
            save_as = save_as+&#34;.png&#34;
        
        plt.savefig(save_as, dpi=300, bbox_inches=&#34;tight&#34;)
        print(&#34;Saved figure as {}&#34;.format(save_as))
    
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AqEquil" href="index.html">AqEquil</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="AqEquil.AqSpeciation.convert_to_RVector" href="#AqEquil.AqSpeciation.convert_to_RVector">convert_to_RVector</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.load" href="#AqEquil.AqSpeciation.load">load</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AqEquil.AqSpeciation.AqEquil" href="#AqEquil.AqSpeciation.AqEquil">AqEquil</a></code></h4>
<ul class="">
<li><code><a title="AqEquil.AqSpeciation.AqEquil.create_data0" href="#AqEquil.AqSpeciation.AqEquil.create_data0">create_data0</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.AqEquil.runeq3" href="#AqEquil.AqSpeciation.AqEquil.runeq3">runeq3</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.AqEquil.runeq6" href="#AqEquil.AqSpeciation.AqEquil.runeq6">runeq6</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.AqEquil.runeqpt" href="#AqEquil.AqSpeciation.AqEquil.runeqpt">runeqpt</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.AqEquil.speciate" href="#AqEquil.AqSpeciation.AqEquil.speciate">speciate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AqEquil.AqSpeciation.Speciation" href="#AqEquil.AqSpeciation.Speciation">Speciation</a></code></h4>
<ul class="">
<li><code><a title="AqEquil.AqSpeciation.Speciation.barplot" href="#AqEquil.AqSpeciation.Speciation.barplot">barplot</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.lookup" href="#AqEquil.AqSpeciation.Speciation.lookup">lookup</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.plot_mass_contribution" href="#AqEquil.AqSpeciation.Speciation.plot_mass_contribution">plot_mass_contribution</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.plot_mineral_saturation" href="#AqEquil.AqSpeciation.Speciation.plot_mineral_saturation">plot_mineral_saturation</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.save" href="#AqEquil.AqSpeciation.Speciation.save">save</a></code></li>
<li><code><a title="AqEquil.AqSpeciation.Speciation.scatterplot" href="#AqEquil.AqSpeciation.Speciation.scatterplot">scatterplot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>