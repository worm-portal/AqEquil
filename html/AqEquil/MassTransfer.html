<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>AqEquil.MassTransfer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AqEquil.MassTransfer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
from pyCHNOSZ import *
from chemparse import parse_formula
import copy
import os
import shutil
from math import log10
import itertools
from operator import itemgetter
import re
import collections
from datetime import datetime
import numbers
from .AqSpeciation import Error_Handler, Speciation, AqEquil, chemlabel

FIXED_SPECIES = [&#34;H2O&#34;, &#34;H+&#34;, &#34;O2(g)&#34;, &#34;water&#34;, &#34;Cl-&#34;, &#34;e-&#34;, &#34;OH-&#34;, &#34;O2&#34;, &#34;H2O(g)&#34;]


def _get_ion_ratio_exponent(num, denom):

    num_formula = parse_formula(num)
    num_plus = num_formula.get(&#34;+&#34;, 0)
    num_minus = num_formula.get(&#34;-&#34;, 0)
    num_total_charge = num_plus - num_minus

    denom_formula = parse_formula(denom)
    denom_plus = denom_formula.get(&#34;+&#34;, 0)
    denom_minus = denom_formula.get(&#34;-&#34;, 0)
    denom_total_charge = denom_plus - denom_minus

    if num_total_charge == 0 or denom_total_charge == 0:
        return 0

    return abs(num_total_charge)/abs(denom_total_charge)


def __delete_file(file):
    if os.path.exists(file) and os.path.isfile(file):
        os.remove(file)

def __delete_dir(d):
    if os.path.exists(d) and os.path.isdir(d):
        shutil.rmtree(d)

def __move_file(file, destination_dir, silent=False):
    try:
        shutil.move(file, destination_dir+&#39;/&#39;+file)
    except:
        if not silent:
            print(&#34;Could not move&#34;, file, &#34;to&#34;, destination_dir)

        
def react(speciation, first_half_of_6i, delete_generated_folders=False, hide_traceback=True):
    
    &#34;&#34;&#34;
    React speciated water with minerals and/or gases.

    Parameters
    ----------
    speciation : `AqSpeciation.Speciation` object
        The output of a speciation calculation produced by the
        function.

    Returns
    ----------
    &#34;&#34;&#34;
    
    prev_wd = os.getcwd()
    ae = AqEquil()
    
    speciation.join_6i_3p(first_half_of_6i)
    __delete_file(&#34;data1.dyn&#34;)
    
    paths=[&#39;rxn_6o&#39;, &#39;rxn_6p&#39;, &#39;eq6_extra_out&#39;]
    for path in paths:
        if not os.path.exists(path):
            os.makedirs(path)
        else:
            shutil.rmtree(path)
            os.makedirs(path)
            
    os.environ[&#39;EQ36DA&#39;] = &#34;eq6_extra_out&#34; # ensuring data1 is read from a folder without spaces overcomes the problem where environment variables with spaces do not work properly when assigned to EQ36DA
            
    for sample_name in list(speciation.sample_data.keys()):
        filename_6i = speciation.sample_data[sample_name][&#34;filename&#34;][:-3]+&#34;.6i&#34;
        filename_6o = filename_6i[:-3]+&#34;.6o&#34;
        filename_6p = filename_6i[:-3]+&#34;.6p&#34;

        if isinstance(speciation.data1, dict):
            # each sample has a unique data1. e.g., with dynamic_db
            __delete_file(&#34;eq6_extra_out/data1.dyn&#34;)
            with open(&#34;eq6_extra_out/data1.dyn&#34;, &#39;wb&#39;) as f:
                f.write(speciation.data1[speciation.sample_data[sample_name][&#34;filename&#34;][:-3]])
        else:
            # all samples use the same data1.
            with open(&#34;eq6_extra_out/data1.dyn&#34;, &#39;wb&#39;) as f:
                f.write(speciation.data1)

        ae.runeq6(filename_6i, db=&#34;dyn&#34;, path_6i=&#34;rxn_6i&#34;,
                  dynamic_db_name=speciation.thermo_db_callname)
        
        os.rename(&#39;tab&#39;, &#39;tab.csv&#39;)
        
        __move_file(filename_6o, &#34;rxn_6o&#34;)
        __move_file(filename_6p, &#34;rxn_6p&#34;)

        __delete_file(&#34;data1.dyn&#34;)
        __delete_file(&#34;data1&#34;)
        
        if speciation.thermo_db_type == &#34;CSV file&#34;:
            m = Mass_Transfer(thermodata_csv=speciation.thermo_db,
                              six_o_file=&#39;rxn_6o/&#39;+filename_6o,
                              tab_name=&#39;tab.csv&#39;,
                              hide_traceback=hide_traceback)

            speciation.sample_data[sample_name][&#34;mass_transfer&#34;] = m
    
    __move_file(&#34;bakupa&#34;, &#34;eq6_extra_out&#34;, silent=True)
    __move_file(&#34;bakupb&#34;, &#34;eq6_extra_out&#34;, silent=True)
    __move_file(&#34;tabx&#34;, &#34;eq6_extra_out&#34;, silent=True)
    __move_file(&#39;tab.csv&#39;, &#34;eq6_extra_out&#34;, silent=True)
    __delete_file(&#34;eq6_extra_out/data1.dyn&#34;)
    __delete_file(&#34;data1&#34;)
        
    if delete_generated_folders:
        __delete_dir(&#34;eq6_extra_out&#34;)
        __delete_dir(&#34;rxn_6i&#34;)
        __delete_dir(&#34;rxn_6p&#34;)
        __delete_dir(&#34;rxn_6o&#34;)
    
    return speciation


class Mass_Transfer:
    &#34;&#34;&#34;
    Class containing functions to facilitate mass transfer and reaction path
    calculations and visualize results.
    
    Parameters
    ----------
    thermodata_csv : str
        Path name of the WORM-styled thermodynamic database CSV used in the EQ6
        calculation.
        
    six_o_file : str
        Path name of the &#39;6o&#39; output file generated by EQ6.
    
    tab_name : str
        Path name of the TAB file generated by EQ6.
    
    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this class?
        When True, error messages handled by this class will be short and to
        the point.
    
    &#34;&#34;&#34;
    def __init__(self, six_o_file, thermodata_csv=None, tab_name=None, hide_traceback=True):
        
        self.err_handler = Error_Handler(clean=hide_traceback)
        
        self.six_o_file = six_o_file
        self.thermodata_csv = thermodata_csv
        self.tab_name = tab_name
        
        if isinstance(thermodata_csv, pd.DataFrame) or isinstance(thermodata_csv, str):
            # these operations require a WORM-style thermodynamic database CSV
            
            obigt = thermo().OBIGT
            thermo(OBIGT = obigt.loc[ obigt.name.isin(FIXED_SPECIES), : ])
            _ = add_OBIGT(thermodata_csv, force=True, messages=False)
            
            self.tab = self.process_tab(tab_name, thermodata_csv)

            if isinstance(thermodata_csv, str):
                self.df = pd.read_csv(thermodata_csv)
            elif isinstance(thermodata_csv, pd.DataFrame):
                self.df = thermodata_csv
            else:
                self.err_handler.raise_exception(&#34;Cannot process reaction output &#34;
                    &#34;because the thermodynamic database specified by thermodata_csv &#34;
                    &#34;is not the a WORM-style dataframe or CSV file.&#34;)

            basis_df = self.df[self.df[&#34;tag&#34;] == &#34;basis&#34;]
            aux_df = self.df[self.df[&#34;tag&#34;] == &#34;aux&#34;]
            refstate_df = self.df[self.df[&#34;tag&#34;] == &#34;refstate&#34;]
            self.basis_df = pd.concat([basis_df])
            self.basis_aux_df = pd.concat([basis_df, aux_df, refstate_df])
            self.df_cr = self.df[self.df[&#34;state&#34;] == &#39;cr&#39;]
        
        # these operations only require a 6o file
        self.aq_distribution = self.__get_aq_distribution()
        self.moles_minerals = self.__get_moles_minerals()
        self.moles_product_minerals = self.__get_moles_product_minerals()

        
    def mine_6o_table(self,
                      table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                      table_stop=&#34;Species with molalities less than&#34;,
                      ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                      col_index=-1):
        
        &#34;&#34;&#34;
        Mine a table in a &#39;6o&#39; EQ6 output file and consolidate results into a
        dataframe.
        
        Parameters
        ----------
        table_start : str
            A unique string that indicates the start of the table.

        table_stop : str, optional
            A unique string that indicates the end of the table.
        
        ignore : list of str
            A list of strings representing lines to ignore when mining a table.
            For example, it is prudent to ignore blank lines, or lines
            containing the table column headers.
            A line will be skipped if line.strip().split(&#39; &#39;)[0] matches any
            of the strings in the given list.
        
        col_index : int, default -1
            Integer representing the index of the table column to be mined.
            The default is -1, which is the last column in the table.
            
        Returns
        -------
        df : Pandas dataframe
            A dataframe with rows of the extent of reaction (Xi), and columns
            containing the values of chemical species mined from the file.
        &#34;&#34;&#34;
        
        f=open(self.six_o_file, mode=&#39;r&#39;)
        lines=f.readlines()
        f.close()

        species = []
        xi_vals=[]
        collect_values = False
        for i in lines:
            if len(i.strip().split(&#39; &#39;)) &gt; 1 and i.strip().split(&#39; &#39;)[0] == &#34;Xi=&#34;:
                xi_vals.append(float(i.split(&#39; &#39;)[-1]))
            if table_stop in i:
                collect_values = False
            if table_start in i:
                collect_values = True
            if collect_values:
                if i.strip().split(&#39; &#39;)[0] not in ignore:
                    species.append(i.strip().split(&#39; &#39;)[0])

        species = list(set(species))
        
        species_dict = {&#34;Xi&#34;:xi_vals}
        for s in species:

            vals=[]
            collect_values = False
            for i in lines:
                if collect_values and table_stop in i:
                    # stop collecting
                    collect_values = False
                    if not got_value:
                        vals.append(np.nan)
                if table_start in i:
                    # start collecting
                    collect_values = True
                    got_value = False
                if collect_values:
                    if len(i.strip().split(&#39; &#39;)) &gt; 2 and i.strip().split(&#39; &#39;)[0] == s:
                        split_i = i.strip().split(&#39; &#39;)
                        split_i_clean = [v for v in split_i if v != &#39;&#39;]
                        vals.append(float(split_i_clean[col_index]))
                        got_value = True
            species_dict[s] = vals

        df = pd.DataFrame(species_dict)
        
        return df
        
        
    def __get_aq_distribution(self):
        
        return self.mine_6o_table(
                      table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                      table_stop=&#34;Species with molalities less than&#34;,
                      ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                      col_index=-1)
 
        
 
    def __get_moles_minerals(self):
        
        return self.mine_6o_table(
                      table_start=&#34;Grand Summary of Solid Phases&#34;,
                      table_stop=&#34;Mass, grams       Volume, cm3&#34;,
                      ignore = [&#34;&#34;, &#34;Phase/End-member&#34;, &#39;---&#39;],
                      col_index=2)

    
    def __get_moles_product_minerals(self):
        
        return self.mine_6o_table(
                      table_start=&#34;--- Summary of Solid Phases (ES) ---&#34;,
                      table_stop=&#34;Grand Summary of Solid Phases&#34;,
                      ignore = [&#34;&#34;, &#34;Phase/End-member&#34;, &#39;---&#39;],
                      col_index=2)
        
        
    def print_tabs(self):
        &#34;&#34;&#34;
        Print the names of tables contained in a tab file processed by the
        the Mass_Transfer class.
        &#34;&#34;&#34;
        [print(key) for key in self.tab.keys()]

        
    @staticmethod
    def __is_all_same_value(s):
        a = s.to_numpy()
        return (a[0] == a).all()
        
        
    def plot_reaction_paths(self,
                            xyb=None, path_margin=0.25, flip_xy=False,
                            h_line_color=&#34;red&#34;,
                            v_line_color=&#34;blue&#34;,
                            d_line_color=&#34;orange&#34;,
                            res=300,
                            plot_width=4, plot_height=3, ppi=122,
                            borders=0,
                            colormap=&#34;viridis&#34;):
        
        &#34;&#34;&#34;
        Create interactive plots of reaction paths in geochemical variable
        space.
        
        Parameters
        ----------
        xyb : list of three str, default None
            By default, this function will plot reaction paths in all possible
            dimensions.
            
            Optionally, if you want to produce only a specific plot,
            you can provide a list containing the basis species to be used for
            the x-axis and y-axis, followed by the basis species used for
            balance. For example, [&#34;Fe+2&#34;, &#34;Fe+3&#34;, &#34;Mg+2&#34;] will have the log
            activity of Fe+2 on the x-axis, the log activity of Fe+3 on the
            y-axis, and will be balanced on Mg+2.

        path_margin : float, default 0.25
            Controls the spacing between the reaction path and the plot axes.
            Increasing this value increases the spacing.
        
        flip_xy : bool, default False
            Transpose the plot so the x and y variables switch axes?
        
        h_line_color : str, default &#34;red&#34;
            Color of horizontal lines.
        
        v_line_color : str, default &#34;blue&#34;
            Color of vertical lines.
        
        d_line_color : str, default &#34;orange&#34;
            Color of diagonal lines.
            
        Returns
        -------
        fig_list : a list of Plotly figure objects
            A list of interactive Plotly figures. If xyb equals None
            (the default), then the list will contain figures representing all
            combinations of geochemical variables. Optionally, if xyb is
            specified, fig_list will only contain the single figure of interest.
        &#34;&#34;&#34;
        
        error_messages = []
        
        # check that there is only one temperature and pressure
        if not self.__is_all_same_value(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Temp(C)&#34;]):
            error_messages.append(&#34;Reaction paths cannot be plotted when temperature changes with reaction progress.&#34;)
        if not self.__is_all_same_value(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Press(bars)&#34;]):
            error_messages.append(&#34;Reaction paths cannot be plotted when pressure changes with reaction progress.&#34;)
        
        if len(error_messages)&gt;0:
            self.err_handler.raise_exception(error_messages)
        
        self.T = float(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Temp(C)&#34;][0])
        self.P = float(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Press(bars)&#34;][0])
        self.path_margin = path_margin
        
        minerals_formed = list(self.tab[&#34;Table P Moles of product minerals&#34;].columns[2:])

        all_elements_of_interest = []
        for mineral in minerals_formed:
            all_elements_of_interest += self.__get_elem_ox_of_interest_in_minerals(mineral)
        all_elements_of_interest = list(set(all_elements_of_interest))
        
        self.all_elements_of_interest = all_elements_of_interest
        
        # get a list of elem pairs for plotting
        alist = self.all_elements_of_interest
        element_plot_pairs = []
        for result in itertools.combinations(alist, 2):
            element_plot_pairs.append(list(result))

        if xyb == None:
            element_plot_triad = []
            for pair in element_plot_pairs:
                elem_not_in_pair = [e for e in self.all_elements_of_interest if e not in pair]
                for e in elem_not_in_pair:
                    triad_to_append = pair + [e]
                    element_plot_triad.append(triad_to_append)
        else:
            element_plot_triad = [[self.__get_elem_ox_of_interest_in_minerals(v)[0] for v in xyb]]
        
        if colormap == &#34;bw&#34;:
            if borders == 0:
                borders = 1
            colormap = &#34;none&#34;
            h_line_color = &#34;black&#34;
            v_line_color = &#34;black&#34;
            d_line_color = &#34;black&#34;
        
        fig_list = []
        for triad in element_plot_triad:
            fig = self.__plot_reaction_path_main(
                            triad, T=self.T, P=self.P,
                            path_margin=self.path_margin,
                            flip_xy=flip_xy,
                            h_line_color=h_line_color,
                            v_line_color=v_line_color,
                            d_line_color=d_line_color,
                            res=res,
                            plot_width=plot_width,
                            plot_height=plot_height,
                            ppi=ppi,
                            colormap=colormap,
                            borders=borders)
            
            fig_list.append(fig)
        
        return fig_list
        
    
    @staticmethod
    def process_tab(tab_name, thermodata_csv):
        
        &#34;&#34;&#34;
        Process a TAB file (from EQ6) into a dictionary of Pandas dataframes.
        
        Parameters
        ----------
        tab_name : str
            Path name of the TAB file generated by EQ6.
        
        thermodata_csv : str or Pandas dataframe
            Path name of the WORM-styled thermodynamic database CSV used in the
            EQ6 calculation. Alternately, the thermodynamic database itself as a
            Pandas dataframe itself.

        Returns
        -------
        tab : a dict of Pandas dataframes
            A dictionary of dataframes representing tables mined from the TAB
            file.
        &#34;&#34;&#34;
        
        if isinstance(thermodata_csv, str):
            thermo_db = pd.read_csv(thermodata_csv)
        else:
            thermo_db = thermodata_csv
        
        
        thermo_db_names = list(thermo_db[&#34;name&#34;])

        with open(tab_name, &#34;r&#34;) as tabfile:
            tab_lines = tabfile.readlines()

        tab = {}

        tables = [&#34;B1&#34;, &#34;B2&#34;, &#34;C1&#34;, &#34;C2&#34;, &#34;C3&#34;, &#34;C4&#34;,
                  &#34;D1&#34;, &#34;D2&#34;, &#34;D3&#34;, &#34;D4&#34;, &#34;E1&#34;, &#34;E2&#34;,
                  &#34;E3&#34;, &#34;J&#34;, &#34;K&#34;, &#34;P&#34;, &#34;Q&#34;, &#34;T&#34;, &#34;W&#34;]

        record_lines = False
        get_header = False
        recorded_lines = []
        for line in tab_lines:
            split_line = line.split(&#34;,&#34;)

            if True in [s in [&#34;Table &#34; + t for t in tables] for s in split_line]:
                get_header = True
                table_name = &#34; &#34;.join(split_line[1:-1])
                continue

            if get_header:
                header = split_line[1:-1]

                # handle instances where the tab file creates extra columns for things like &#34;albite,low&#34;
                if table_name == &#34;Table P Moles of product minerals&#34; or table_name == &#34;Table Q Saturation indices of potential product phases&#34;:
                    if table_name == &#34;Table P Moles of product minerals&#34;:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;] # table P
                    else:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;H2O&#34;, &#34;Gas&#34;] # table Q

                    for i,h in enumerate(header):

                        if h != &#34;Xi&#34; and h != &#34;t(days)&#34; and h != &#34;H2O&#34; and h != &#34;Gas&#34;:
                            if h not in thermo_db_names:
                                if header[i-1]+&#34;,&#34;+h in thermo_db_names:
                                    new_header = new_header[:-1]
                                    new_header.append(header[i-1]+&#34;,&#34;+h)
                                else:
                                    new_header.append(h)
                            else:
                                new_header.append(h)

                    header = new_header


                record_lines = True
                get_header = False
                continue

            if &#34;EndTable:&#34; in split_line:
                record_lines = False
                if len(recorded_lines) &gt; 0:
                    df = pd.DataFrame(recorded_lines)
                    recorded_lines = []
                    df.columns = header
                    tab[table_name] = df

            if record_lines:
                recorded_lines.append(split_line[1:-1])

        return tab

    
    def __get_mineral_elem_ox(self, mineral):
        split_list = list(self.df[self.df[&#34;name&#34;]==mineral][&#34;formula_ox&#34;])[0].split()
        split_list_clean = [s.replace(&#34; &#34;, &#34;&#34;) for s in split_list]
        elem_ox_list = [re.findall(r&#34;^(?:\d+|)([A-Z].*$)&#34;, s)[0] for s in split_list]
        return elem_ox_list

    
    def __get_elem_ox_of_interest_in_minerals(self, mineral_name):
        mineral_elements = self.__get_mineral_elem_ox(mineral_name)
        mineral_elements_of_interest = [e for e in mineral_elements if e not in [&#34;H+&#34;, &#34;O-2&#34;]]
        return mineral_elements_of_interest


    def __get_mineral_elem_ox_dict(self, mineral):
        split_list = list(self.df[self.df[&#34;name&#34;]==mineral][&#34;formula_ox&#34;])[0].split()
        split_list_clean = [s.replace(&#34; &#34;, &#34;&#34;) for s in split_list]
        elem_ox_names = self.__get_mineral_elem_ox(mineral)

        elem_ox_list = []
        for s in split_list:
            coeff = re.findall(r&#34;(\d+)[A-Z]&#34;, s)
            if len(coeff) == 0:
                coeff = 1
            else:
                coeff = float(coeff[0])
            elem_ox_list.append(coeff)

        return {key:val for key,val in zip(elem_ox_names, elem_ox_list)}

    
    def __get_mineral_elem_ox_dict_interest(self, mineral):
        mineral_dict = self.__get_mineral_elem_ox_dict(mineral)
        return {key:value for key,value in zip(mineral_dict.keys(), mineral_dict.values()) if key not in [&#34;H+&#34;, &#34;O-2&#34;]}


    def __get_basis_from_elem(self, elem):

        basis_species_x = None

        for s in list(self.basis_df[&#34;name&#34;]):
            if elem in self.__get_elem_ox_of_interest_in_minerals(s):
                basis_species_x = s

        if basis_species_x == None:
            for s in list(self.basis_aux_df[&#34;name&#34;]):
                if elem in self.__get_elem_ox_of_interest_in_minerals(s):
                    basis_species_x = s

        return basis_species_x

    
    def __get_reaction_path(self, plot_basis_x, plot_basis_y, div_var_name):

        xi_vals=self.aq_distribution[&#34;Xi&#34;]
        proton_vals=self.aq_distribution[&#34;H+&#34;]
        x_vals=self.aq_distribution[plot_basis_x]
        y_vals=self.aq_distribution[plot_basis_y]

        assert len(proton_vals) == len(x_vals), f&#34;number of proton values ({proton_vals}) should equal number of x values ({x_vals})&#34;
        assert len(proton_vals) == len(y_vals), f&#34;number of proton values ({proton_vals}) should equal number of y values ({y_vals})&#34;

        x_vals = [log10((10**float(x))/(10**float(d))**_get_ion_ratio_exponent(plot_basis_x, &#34;H+&#34;)) for x,d in zip(x_vals,proton_vals)]
        y_vals = [log10((10**float(y))/(10**float(d))**_get_ion_ratio_exponent(plot_basis_y, &#34;H+&#34;)) for y,d in zip(y_vals,proton_vals)]

        return xi_vals, x_vals, y_vals

    
    def __get_plot_range(self, x_vals, y_vals):
        min_x_val = min(x_vals)
        min_y_val = min(y_vals)
        max_x_val = max(x_vals)
        max_y_val = max(y_vals)

        path_x_range = max_x_val - min_x_val
        path_y_range = max_y_val - min_y_val

        plot_x_range = [min_x_val-self.path_margin*path_x_range, max_x_val+self.path_margin*path_x_range]
        plot_y_range = [min_y_val-self.path_margin*path_y_range, max_y_val+self.path_margin*path_y_range]

        return plot_x_range, plot_y_range

    
    @staticmethod
    def __get_xy_labs(plot_basis_x, plot_basis_y):
        try:
            xlab = ratlab(plot_basis_x)
        except:
            xlab = &#34;log a&#34;+chemlabel(plot_basis_x)
        try:
            ylab = ratlab(plot_basis_y)
        except:
            ylab = &#34;log a&#34;+chemlabel(plot_basis_y)

        return xlab, ylab


    def __plot_reaction_path_background(self, plot_basis_x, plot_basis_y,
                                        div_var_name, x_vals, y_vals,
                                        colormap=&#34;viridis&#34;, borders=0,
                                        field_minerals_exist=True, path_margin=0.25,
                                        plot_width=4, plot_height=3, ppi=122, res=300,
                                        annotation=None, annotation_coords=[0, 0],
                                        messages=False):

        plot_x_range, plot_y_range = self.__get_plot_range(x_vals, y_vals)

        xlab,ylab = self.__get_xy_labs(plot_basis_x, plot_basis_y)
        
        args = {plot_basis_x:plot_x_range+[res],
                plot_basis_y:plot_y_range+[res],
                &#34;T&#34;:self.T, &#34;P&#34;:self.P, &#34;messages&#34;:messages}

        if field_minerals_exist:
            a = affinity(**args)
            e = equilibrate(a, balance=self.__get_basis_from_elem(div_var_name), messages=messages)

            return diagram_interactive(e, colormap=colormap, borders=borders,
                           balance=self.__get_basis_from_elem(div_var_name),
                           width=plot_width*ppi, height=plot_height*ppi,
                           xlab=xlab, ylab=ylab, annotation=annotation,
                           plot_it=False, messages=messages)
        else:
            # empty plot upon
            fig = go.Figure(go.Scatter(x=pd.Series(dtype=object),
                                       y=pd.Series(dtype=object),
                                       mode=&#34;markers&#34;,
                                       ),
                           layout_xaxis_range=plot_x_range,
                           layout_yaxis_range=plot_y_range,
                           )

            fig.add_annotation(x=annotation_coords[0],
                               y=annotation_coords[1],
                               xref=&#34;paper&#34;,
                               yref=&#34;paper&#34;,
                               align=&#39;left&#39;,
                               text=annotation,
                               bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;,
                               showarrow=False)

            fig.update_layout(
                width=plot_width*ppi, height=plot_height*ppi,
                xaxis={&#34;title&#34;: xlab},
                yaxis={&#34;title&#34;: ylab},
                template=&#34;simple_white&#34;,
            )

            fig.update_yaxes(autorange=True)

            return None,fig # a table and diagram without regions


    @staticmethod
    def __calc_dissrxn_logK(mineral, T, P):

        logK = subcrt([mineral], coeff=[1], property=&#39;logK&#39;, T=T, P=P, show=False, messages=False)[&#34;out&#34;][&#34;logK&#34;].item()
        return logK

    
    def __add_reaction_path_to_plot(self, x_vals, y_vals, xi_vals, fig, basis_species_x, basis_species_y, path_margin=0.25):

        min_x_val = min(x_vals)
        min_y_val = min(y_vals)
        max_x_val = max(x_vals)
        max_y_val = max(y_vals)

        path_x_range = max_x_val - min_x_val
        path_y_range = max_y_val - min_y_val

        xlab,ylab = self.__get_xy_labs(basis_species_x, basis_species_y)

        fig.add_trace(
            go.Scatter(
                x=x_vals,
                y=y_vals,
                line=go.scatter.Line(color=&#34;black&#34;),
                mode=&#39;lines+markers&#39;,
                showlegend=True,
                name=&#39;reaction path&#39;,
                text = xi_vals,
                hovertemplate = &#39;Xi = %{text}&lt;br&gt;&#39;+xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab+&#39;: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;)
        )

        fig.update_xaxes(range=self.__get_plot_range(x_vals, y_vals)[0], autorange=False)
        fig.update_yaxes(range=self.__get_plot_range(x_vals, y_vals)[1], autorange=False)

        return fig

    
    def __plot_reaction_path_main(self,
                                  triad, T=25, P=1, path_margin=0.25,
                                  flip_xy=False,
                                  h_line_color=&#34;red&#34;,
                                  v_line_color=&#34;blue&#34;,
                                  d_line_color=&#34;orange&#34;,
                                  res=300,
                                  plot_width=4,
                                  plot_height=3,
                                  ppi=122,
                                  colormap=&#34;viridis&#34;,
                                  borders=0):

        e_pair = triad[0:2]
        div_var_name = triad[2]

        if flip_xy:
            e_pair.reverse()

        basis_species_x = self.__get_basis_from_elem(e_pair[0])
        basis_species_y = self.__get_basis_from_elem(e_pair[1])

        basis_sp_list = list(self.tab[&#34;Table E2 Basis species(log activity; log fugacity for O2(g))&#34;].columns)[2:-1]
        basis_sp_list += [self.__get_basis_from_elem(e) for e in self.all_elements_of_interest]
        basis_sp_list = list(set(basis_sp_list))

        if basis_species_x not in basis_sp_list:
            basis_sp_list += [basis_species_x]
        if basis_species_y not in basis_sp_list:
            basis_sp_list += [basis_species_y]

        try:
            basis(basis_sp_list)
        except:
            basis(basis_sp_list + [&#34;H2&#34;])


        mineral_names = list(self.df_cr[&#34;name&#34;])
        mineral_formula_ox = [self.__get_elem_ox_of_interest_in_minerals(m) for m in mineral_names]
        mineral_formula_ox_singles = [e if len(e)==1 else [] for e in mineral_formula_ox]
        mineral_formula_ox_doubles = [e if len(e)==2 else [] for e in mineral_formula_ox]
        mineral_formula_ox_triples = [e if len(e)==3 else [] for e in mineral_formula_ox]

        retrieved_minerals = []
        for i,s in enumerate(mineral_formula_ox_singles):
            if [e_pair[0]] == s:
                retrieved_minerals.append(mineral_names[i])
        x_minerals_to_plot = retrieved_minerals

        retrieved_minerals = []
        for i,s in enumerate(mineral_formula_ox_singles):
            if [e_pair[1]] == s:
                retrieved_minerals.append(mineral_names[i])
        y_minerals_to_plot = retrieved_minerals

        xy_minerals_to_plot = []
        for i,s in enumerate(mineral_formula_ox_doubles):
            if e_pair[0] in s and e_pair[1] in s:
                xy_minerals_to_plot.append(mineral_names[i])

        if len(x_minerals_to_plot) &gt; 1:
            species(x_minerals_to_plot, add=True)
        if len(y_minerals_to_plot) &gt; 1:
            species(y_minerals_to_plot, add=True)
        if len(xy_minerals_to_plot) &gt; 1:
            species(xy_minerals_to_plot, add=True)

        field_minerals_to_plot = []
        for i,s in enumerate(mineral_formula_ox_triples):
            if e_pair[0] in s and e_pair[1] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
        for i,s in enumerate(mineral_formula_ox_doubles):
            if e_pair[0] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
            elif e_pair[1] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
        for i,s in enumerate(mineral_formula_ox_singles):
            if div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
                
        field_minerals_exist = True
        try:
            # get minerals relevant to plotted element pair
            species(field_minerals_to_plot)#, add=True)
        except:
            field_minerals_exist = False

        xi_vals, x_vals, y_vals = self.__get_reaction_path(basis_species_x, basis_species_y, div_var_name)

        table,fig = self.__plot_reaction_path_background(basis_species_x, basis_species_y, div_var_name, x_vals, y_vals,
                                                         plot_width=plot_width, plot_height=plot_height, ppi=ppi, res=res,
                                                         colormap=colormap, borders=borders,
                                                         field_minerals_exist=field_minerals_exist, path_margin=self.path_margin,
                                                         annotation=&#34;Balanced on: &#34;+chemlabel(self.__get_basis_from_elem(div_var_name)),
                                                         messages=False)

        # plot minerals with a single element of interest as a line
        plot_x_range, plot_y_range = self.__get_plot_range(x_vals, y_vals)
        for mineral in x_minerals_to_plot + y_minerals_to_plot + xy_minerals_to_plot:

            eoi = self.__get_elem_ox_of_interest_in_minerals(mineral)

            logK = self.__calc_dissrxn_logK(mineral, T, P)
            mineral_formula_dict = self.__get_mineral_elem_ox_dict_interest(mineral)

            if len(eoi) == 1:

                # if the element of interest is not in the current element pair, move on
                if eoi[0] not in e_pair:
                    continue

                if self.__get_elem_ox_of_interest_in_minerals(mineral)[0] == e_pair[0]:
                    # vertical line
                    x0, x1 = (-1/mineral_formula_dict[e_pair[0]])*logK, (-1/mineral_formula_dict[e_pair[0]])*logK
                    y0 = min(plot_y_range)
                    y1 = max(plot_y_range)
                    color = v_line_color
                elif self.__get_elem_ox_of_interest_in_minerals(mineral)[0] == e_pair[1]:
                    # horizontal line
                    y0, y1 = (-1/mineral_formula_dict[e_pair[1]])*logK, (-1/mineral_formula_dict[e_pair[1]])*logK
                    x0 = min(plot_x_range)
                    x1 = max(plot_x_range)
                    color=h_line_color

            if len(eoi) == 2:

                line_slope = mineral_formula_dict[e_pair[0]]/mineral_formula_dict[e_pair[1]]

                x0 = min(plot_x_range)
                x1 = max(plot_x_range)
                y0 = (-1/mineral_formula_dict[e_pair[1]])*logK - line_slope*x0
                y1 = (-1/mineral_formula_dict[e_pair[1]])*logK - line_slope*x1
                color = d_line_color

            fig.add_trace(
                go.Scatter(x=[x0, x1], y=[y0, y1], mode=&#34;lines&#34;, name=mineral, line=dict(color=color, width=1, dash=&#39;dot&#39;)),
            )


        fig = self.__add_reaction_path_to_plot(x_vals, y_vals, xi_vals, fig, basis_species_x, basis_species_y, path_margin=self.path_margin)
        return fig

    
    def plot_product_minerals(self, show_reactant_minerals=False,
                              plot_width=4, plot_height=3, ppi=122):
        
        &#34;&#34;&#34;
        Generate a line plot of the log moles of product minerals as a
        function of the log of the extent of reaction (log Xi).
        
        Parameters
        ----------
        show_reactant_minerals : bool, default False
            Include log moles of reactant minerals?
            
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        if show_reactant_minerals:
            df = self.moles_minerals
            title = &#34;Moles of reactant and product minerals&#34;
        else:
            df = self.moles_product_minerals
            title = &#34;Moles of product minerals&#34;

        df = pd.melt(df, id_vars=&#34;Xi&#34;, value_vars=df.columns[1:])
        df.columns = [&#34;log Xi&#34;, &#34;variable&#34;, &#34;value&#34;]
        df = df[df[&#34;variable&#34;] != &#34;None&#34;]


        df[&#34;log Xi&#34;] = pd.to_numeric(df[&#34;log Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;log Xi&#39;])
            df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
            
        
        xlab = &#34;log Xi&#34;
        ylab = &#34;log moles&#34;
        xvar = &#34;log Xi&#34;


        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None)

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        return fig

    
    def plot_aqueous_species(self, plot_basis=False,
                             plot_width=4, plot_height=3, ppi=122):
        
        &#34;&#34;&#34;
        Generate a line plot of the log activities of aqueous species as a
        function of the log of the extent of reaction (log Xi).
        
        Parameters
        ----------
        plot_basis : bool, default False
            Plot basis species only?
            
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        if plot_basis:
            if hasattr(self, &#39;tab&#39;):
                df = self.tab[&#34;Table E2 Basis species(log activity; log fugacity for O2(g))&#34;]
                title = &#34;Solute basis species&#34;
                startcol = 2 # specific to table D1
            else:
                self.err_handler.raise_exception(&#34;Cannot plot basis species because the TAB file &#34;
                    &#34;cannot be processed. This is likely because a thermodynamic database CSV &#34;
                    &#34;was not provided when Mass_Transfer() was called.&#34;)
        else:
            df = self.aq_distribution
            title = &#34;Solute species&#34;
            startcol = 1

        df = pd.melt(df, id_vars=&#34;Xi&#34;, value_vars=df.columns[startcol:])
        df.columns = [&#34;log Xi&#34;, &#34;variable&#34;, &#34;value&#34;]
        df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel)

        df[&#34;log Xi&#34;] = pd.to_numeric(df[&#34;log Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;log Xi&#39;])
#             df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
            
        
        xlab = &#34;log Xi&#34;
        ylab = &#34;log activity&#34;
        xvar = &#34;log Xi&#34;


        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None)

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        return fig

    
    def plot_mass_contribution(self, *args, xi_decimals=3, **kwargs):
        
        &#34;&#34;&#34;
        Generate a bar plot of mass contributions (in mole percent) of aqueous
        species formed by a specified basis species at different extents of
        reaction (Xi).
        
        Parameters
        ----------
        *args : iterable
            Arguments to be passed to `Speciation.plot_mass_contribution`.

        xi_decimals : int
            Number of decimals to display in the scientific notation of the
            extent of reaction, Xi.

        **kargs : dict
            Keyword arguments to be passed to `Speciation.plot_mass_contribution`.
            
        Returns
        -------
        fig : Plotly figure object
            A mass contribution bar plot.
        &#34;&#34;&#34;
        
        basis = args[0]
        
        if &#34;sample_label&#34; not in kwargs.keys():
            kwargs[&#34;sample_label&#34;] = &#34;Xi&#34;

        
        df_sp = self.mine_6o_table(
                        table_start=&#34;Species Accounting for 99% or More of Aqueous &#34;+basis,
                        table_stop=&#34;Subtotal&#34;,
                        ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;, &#39;-&#39;],
                        col_index=-1)
        
        
        df_sp[&#39;Xi&#39;] = df_sp[&#39;Xi&#39;].astype(str)
        df_sp[&#39;Other&#39;] = 100 - df_sp.sum(axis=1, numeric_only=True)
        df_sp[&#39;Xi&#39;] = df_sp[&#39;Xi&#39;].astype(float)
        
        df_sp[df_sp[&#34;Other&#34;] &lt; 0] = 0
        
        df_sp[&#34;basis&#34;] = basis
        df_sp[&#34;factor&#34;] = None
        df_sp[&#34;molality&#34;] = None
        
        df_sp_melt = df_sp.melt(id_vars=[&#34;Xi&#34;, &#34;basis&#34;, &#34;factor&#34;, &#39;molality&#39;])
        df_sp_melt.columns = [&#34;sample&#34;, &#34;basis&#34;, &#39;factor&#39;, &#39;molality&#39;, &#34;species&#34;, &#34;percent&#34;]
        
        df_sp_melt = df_sp_melt[df_sp_melt[&#39;percent&#39;].notna()]
        
        df_sp_melt.sort_values([&#34;sample&#34;, &#34;species&#34;, &#34;percent&#34;],
                               axis = 0, ascending = True,
                               inplace = True)
        
        # handle display of Xi on the x axis
        # if number of decimals to display is too low, columns will stack
        # check to see if this happens, then increment xi_decimals until the stacking problem is solved
        if xi_decimals &lt; 0:
            self.err_handler.raise_exception(&#34;The parameter xi_decimals must be greater than or equal to 0.&#34;)
        original_xi_decimals = copy.copy(xi_decimals)
        if len(set(df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x))) &lt; len(set(df_sp_melt[&#39;sample&#39;])):
            xi_decimals += 1
            solved_decimals = False
            for i in range(xi_decimals, xi_decimals+10):
                if len(set(df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x))) == len(set(df_sp_melt[&#39;sample&#39;])):
                    print(&#34;Number of decimals to display for Xi increased to&#34;, xi_decimals, &#34;to prevent column stacking.&#34;)
                    solved_decimals = True
                    break
                else:
                    xi_decimals += 1
            if not solved_decimals:
                self.err_handler.raise_exception(&#34;Xi decimal formatting is resulting in column stacking even after attempting 10 increments of xi_decimals.&#34;)
        
        df_sp_melt[&#39;sample&#39;] = df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x) # converts Xi to string
        
        sp = Speciation(args={})
        sp.mass_contribution = df_sp_melt
        
        
        if not kwargs.get(&#34;plot_out&#34;, False):
            plot_out = False
        else:
            plot_out = True
        kwargs[&#34;plot_out&#34;] = True
        
        fig = sp.plot_mass_contribution(*args, **kwargs)
        
        fig.update_layout(
            xaxis_title=&#34;Xi&#34;, # add an x axis title
        )
        
        if plot_out:
            return fig
        else:
            fig.show()


template = &#34;&#34;&#34;|------------------------------------------------------------------------------|
| Main Title             | (utitl1(n))                                         |
|------------------------------------------------------------------------------|
|Sample: {{sample_name}}                                                         |
|Date created:  {date_created}                                       |
|EQ6 input file generated by AqEquil                                           |
|                                                                              |
|------------------------------------------------------------------------------|
|Temperature option (jtemp):                                                   |
|  [{t_checkbox_1}] ( 0) Constant temperature:                                              |
|             Value (C)         |{tval1}| (tempcb)                        |
|  [{t_checkbox_2}] ( 1) Linear tracking in Xi:                                             |
|             Base Value (C)    |{tval2}| (tempcb)                        |
|             Derivative        |{tval3}| (ttk(1))                        |
|  [{t_checkbox_3}] ( 2) Linear tracking in time:                                           |
|             Base Value (C)    |{tval4}| (tempcb)                        |
|             Derivative        |{tval5}| (ttk(1))                        |
|  [{t_checkbox_4}] ( 3) Fluid mixing tracking (fluid 2 = special reactant):                |
|             T of fluid 1 (C)  |{tval6}| (tempcb)                        |
|             T of fluid 2 (C)  |{tval7}| (ttk(2))                        |
|             Mass ratio factor |{tval8}| (ttk(1))                        |
|------------------------------------------------------------------------------|
|Pressure option (jpress):                                                     |
|  [{p_checkbox_1}] ( 0) Follow the data file reference pressure curve                      |
|  [{p_checkbox_2}] ( 1) Follow the 1.013-bar/steam-saturation curve                        |
|  [{p_checkbox_3}] ( 2) Constant pressure:                                                 |
|             Value (bars)      |{pval1}| (pressb)                        |
|  [{p_checkbox_4}] ( 3) Linear tracking in Xi:                                             |
|             Base Value (bars) |{pval2}| (pressb)                        |
|             Derivative        |{pval3}| (ptk(1))                        |
|  [{p_checkbox_5}] ( 4) Linear tracking in time:                                           |
|             Base Value (bars) |{pval4}| (pressb)                        |
|             Derivative        |{pval5}| (ptk(1))                        |
|------------------------------------------------------------------------------|
|Reactants (Irreversible Reactions) | (nrct)                                   |{reactant_blocks}
|------------------------------------------------------------------------------|
* Valid reactant type strings (urcjco(jcode(n))) are:                          *
*    Pure mineral                Solid solution                                *
*    Special reactant            Aqueous species                               *
*    Gas species                 Generic ion exchanger                         *
*------------------------------------------------------------------------------*
* Valid reactant status strings (urcjre(jreac(n))) are:                        *
*    Saturated, reacting         Reacting                                      *
*    Exhausted                   Saturated, not reacting                       *
*------------------------------------------------------------------------------*
* Valid forward rate law strings (urcnrk(nrk(1,n))) are:                       *
*    Use backward rate law       Relative rate equation                        *
*    TST rate equation           Linear rate equation                          *
*------------------------------------------------------------------------------*
* Valid backward rate law strings (urcnrk(nrk(2,n))) are:                      *
*    Use forward rate law        Partial equilibrium                           *
*    Relative rate equation      TST rate equation                             *
*    Linear rate equation                                                      *
*------------------------------------------------------------------------------*
|Starting, minimum, and maximum values of key run parameters.                  |
|------------------------------------------------------------------------------|
|Starting Xi value        |{start_xi}| (xistti)                              |
|------------------------------------------------------------------------------|
|Maximum Xi value         |{max_xi}| (ximaxi)                              |
|------------------------------------------------------------------------------|
|Starting time (seconds)  |{start_time}| (tistti)                              |
|------------------------------------------------------------------------------|
|Maximum time (seconds)   |{max_time}| (timmxi)                              |
|------------------------------------------------------------------------------|
|Minimum value of pH      |{min_pH}| (phmini)                              |
|------------------------------------------------------------------------------|
|Maximum value of pH      |{max_pH}| (phmaxi)                              |
|------------------------------------------------------------------------------|
|Minimum value of Eh (v)  |{min_Eh}| (ehmini)                              |
|------------------------------------------------------------------------------|
|Maximum value of Eh (v)  |{max_Eh}| (ehmaxi)                              |
|------------------------------------------------------------------------------|
|Minimum value of log fO2 |{min_fO2}| (o2mini)                              |
|------------------------------------------------------------------------------|
|Maximum value of log fO2 |{max_fO2}| (o2maxi)                              |
|------------------------------------------------------------------------------|
|Minimum value of aw      |{min_aw}| (awmini)                              |
|------------------------------------------------------------------------------|
|Maximum value of aw      |{max_aw}| (awmaxi)                              |
|------------------------------------------------------------------------------|
|Maximum number of steps  |{max_n_steps}| (kstpmx)                              |
|------------------------------------------------------------------------------|
|Print interval parameters.                                                    |
|------------------------------------------------------------------------------|
|Xi print interval        |{xi_print_int}| (dlxprn)                              |
|------------------------------------------------------------------------------|
|Log Xi print interval    |{log_xi_print_int}| (dlxprl)                              |
|------------------------------------------------------------------------------|
|Time print interval      |{time_print_int}| (dltprn)                              |
|------------------------------------------------------------------------------|
|Log time print interval  |{log_time_print_int}| (dltprl)                              |
|------------------------------------------------------------------------------|
|pH print interval        |{pH_print_interval}| (dlhprn)                              |
|------------------------------------------------------------------------------|
|Eh (v) print interval    |{Eh_print_interval}| (dleprn)                              |
|------------------------------------------------------------------------------|
|Log fO2 print interval   |{logfO2_print_interval}| (dloprn)                              |
|------------------------------------------------------------------------------|
|aw print interval        |{aw_print_interval}| (dlaprn)                              |
|------------------------------------------------------------------------------|
|Steps print interval     |{n_steps_print_interval}| (ksppmx)                              |
|------------------------------------------------------------------------------|
|Plot interval parameters.                                                     |
|------------------------------------------------------------------------------|
|Xi plot interval         | 1.00000E+38| (dlxplo)                              |
|------------------------------------------------------------------------------|
|Log Xi plot interval     | 1.00000E+38| (dlxpll)                              |
|------------------------------------------------------------------------------|
|Time plot interval       | 1.00000E+38| (dltplo)                              |
|------------------------------------------------------------------------------|
|Log time plot interval   | 1.00000E+38| (dltpll)                              |
|------------------------------------------------------------------------------|
|pH plot interval         | 1.00000E+38| (dlhplo)                              |
|------------------------------------------------------------------------------|
|Eh (v) plot interval     | 1.00000E+38| (dleplo)                              |
|------------------------------------------------------------------------------|
|Log fO2 plot interval    | 1.00000E+38| (dloplo)                              |
|------------------------------------------------------------------------------|
|aw plot interval         | 1.00000E+38| (dlaplo)                              |
|------------------------------------------------------------------------------|
|Steps plot interval      |       10000| (ksplmx)                              |
|------------------------------------------------------------------------------|
|Iopt Model Option Switches (&#34;( 0)&#34; marks default choices)                     |
|------------------------------------------------------------------------------|
|iopt(1) - Physical System Model Selection:                                    |
|  [{i1_checkbox_1}] ( 0) Closed system                                                      |
|  [{i1_checkbox_2}] ( 1) Titration system                                                   |
|  [{i1_checkbox_3}] ( 2) Fluid-centered flow-through open system                            |
|------------------------------------------------------------------------------|
|iopt(2) - Kinetic Mode Selection:                                             |
|  [{i2_checkbox_1}] ( 0) Reaction progress mode (arbitrary kinetics)                        |
|  [{i2_checkbox_2}] ( 1) Reaction progress/time mode (true kinetics)                        |
|------------------------------------------------------------------------------|
|iopt(3) - Phase Boundary Searches:                                            |
|  [{i3_checkbox_1}] ( 0) Search for phase boundaries and constrain the step size to match   |
|  [{i3_checkbox_2}] ( 1) Search for phase boundaries and print their locations              |
|  [{i3_checkbox_3}] ( 2) Don&#39;t search for phase boundaries                                  |
|------------------------------------------------------------------------------|
|iopt(4) - Solid Solutions:                                                    |
|  [{i4_checkbox_1}] ( 0) Ignore                                                             |
|  [{i4_checkbox_2}] ( 1) Permit                                                             |
|------------------------------------------------------------------------------|
|iopt(5) - Clear the ES Solids Read from the INPUT File:                       |
|  [{i5_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i5_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(6) - Clear the ES Solids at the Initial Value of Reaction Progress:      |
|  [{i6_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i6_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(7) - Clear the ES Solids at the End of the Run:                          |
|  [{i7_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i7_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(9) - Clear the PRS Solids Read from the INPUT file:                      |
|  [{i9_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i9_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(10) - Clear the PRS Solids at the End of the Run:                        |
|  [{i10_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i10_checkbox_2}] ( 1) Do it, unless numerical problems cause early termination           |
|------------------------------------------------------------------------------|
|iopt(11) - Auto Basis Switching in pre-N-R Optimization:                      |
|  [{i11_checkbox_1}] ( 0) Turn off                                                           |
|  [{i11_checkbox_2}] ( 1) Turn on                                                            |
|------------------------------------------------------------------------------|
|iopt(12) - Auto Basis Switching after Newton-Raphson Iteration:               |
|  [{i12_checkbox_1}] ( 0) Turn off                                                           |
|  [{i12_checkbox_2}] ( 1) Turn on                                                            |
|------------------------------------------------------------------------------|
|iopt(13) - Calculational Mode Selection:                                      |
|  [{i13_checkbox_1}] ( 0) Normal path tracing                                                |
|  [{i13_checkbox_2}] ( 1) Economy mode (if permissible)                                      |
|  [{i13_checkbox_3}] ( 2) Super economy mode (if permissible)                                |
|------------------------------------------------------------------------------|
|iopt(14) - ODE Integrator Corrector Mode Selection:                           |
|  [{i14_checkbox_1}] ( 0) Allow Stiff and Simple Correctors                                  |
|  [{i14_checkbox_2}] ( 1) Allow Only the Simple Corrector                                    |
|  [{i14_checkbox_3}] ( 2) Allow Only the Stiff Corrector                                     |
|  [{i14_checkbox_4}] ( 3) Allow No Correctors                                                |
|------------------------------------------------------------------------------|
|iopt(15) - Force the Suppression of All Redox Reactions:                      |
|  [x] ( 0) Don&#39;t do it                                                        |
|  [ ] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(16) - BACKUP File Options:                                               |
|  [ ] (-1) Don&#39;t write a BACKUP file                                          |
|  [x] ( 0) Write BACKUP files                                                 |
|  [ ] ( 1) Write a sequential BACKUP file                                     |
|------------------------------------------------------------------------------|
|iopt(17) - PICKUP File Options:                                               |
|  [ ] (-1) Don&#39;t write a PICKUP file                                          |
|  [x] ( 0) Write a PICKUP file                                                |
|------------------------------------------------------------------------------|
|iopt(18) - TAB File Options:                                                  |
|  [ ] (-1) Don&#39;t write a TAB file                                             |
|  [x] ( 0) Write a TAB file                                                   |
|  [ ] ( 1) Write a TAB file, prepending TABX file data from a previous run    |
|------------------------------------------------------------------------------|
|iopt(20) - Advanced EQ6 PICKUP File Options:                                  |
|  [{i20_checkbox_1}] ( 0) Write a normal EQ6 PICKUP file                                     |
|  [{i20_checkbox_2}] ( 1) Write an EQ6 INPUT file with Fluid 1 set up for fluid mixing       |
|------------------------------------------------------------------------------|
|Iopr Print Option Switches (&#34;( 0)&#34; marks default choices)                     |
|------------------------------------------------------------------------------|
|iopr(1) - Print All Species Read from the Data File:                          |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print                                                              |
|------------------------------------------------------------------------------|
|iopr(2) - Print All Reactions:                                                |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print the reactions                                                |
|  [ ] ( 2) Print the reactions and log K values                               |
|  [ ] ( 3) Print the reactions, log K values, and associated data             |
|------------------------------------------------------------------------------|
|iopr(3) - Print the Aqueous Species Hard Core Diameters:                      |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print                                                              |
|------------------------------------------------------------------------------|
|iopr(4) - Print a Table of Aqueous Species Concentrations, Activities, etc.:  |
|  [ ] (-3) Omit species with molalities &lt; 1.e-8                               |
|  [ ] (-2) Omit species with molalities &lt; 1.e-12                              |
|  [ ] (-1) Omit species with molalities &lt; 1.e-20                              |
|  [x] ( 0) Omit species with molalities &lt; 1.e-100                             |
|  [ ] ( 1) Include all species                                                |
|------------------------------------------------------------------------------|
|iopr(5) - Print a Table of Aqueous Species/H+ Activity Ratios:                |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print cation/H+ activity ratios only                               |
|  [ ] ( 2) Print cation/H+ and anion/H+ activity ratios                       |
|  [ ] ( 3) Print ion/H+ activity ratios and neutral species activities        |
|------------------------------------------------------------------------------|
|iopr(6) - Print a Table of Aqueous Mass Balance Percentages:                  |
|  [ ] (-1) Don&#39;t print                                                        |
|  [x] ( 0) Print those species comprising at least 99% of each mass balance   |
|  [ ] ( 1) Print all contributing species                                     |
|------------------------------------------------------------------------------|
|iopr(7) - Print Tables of Saturation Indices and Affinities:                  |
|  [ ] (-1) Don&#39;t print                                                        |
|  [x] ( 0) Print, omitting those phases undersaturated by more than 10 kcal   |
|  [ ] ( 1) Print for all phases                                               |
|------------------------------------------------------------------------------|
|iopr(8) - Print a Table of Fugacities:                                        |
|  [x] (-1) Don&#39;t print                                                        |
|  [ ] ( 0) Print                                                              |
|------------------------------------------------------------------------------|
|iopr(9) - Print a Table of Mean Molal Activity Coefficients:                  |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print                                                              |
|------------------------------------------------------------------------------|
|iopr(10) - Print a Tabulation of the Pitzer Interaction Coefficients:         |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print a summary tabulation                                         |
|  [ ] ( 2) Print a more detailed tabulation                                   |
|------------------------------------------------------------------------------|
|iopr(17) - PICKUP file format (&#34;W&#34; or &#34;D&#34;):                                   |
|  [x] ( 0) Use the format of the INPUT file                                   |
|  [ ] ( 1) Use &#34;W&#34; format                                                     |
|  [ ] ( 2) Use &#34;D&#34; format                                                     |
|------------------------------------------------------------------------------|
|Iodb Debugging Print Option Switches (&#34;( 0)&#34; marks default choices)           |
|------------------------------------------------------------------------------|
|iodb(1) - Print General Diagnostic Messages:                                  |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print Level 1 diagnostic messages                                  |
|  [ ] ( 2) Print Level 1 and Level 2 diagnostic messages                      |
|------------------------------------------------------------------------------|
|iodb(2) - Kinetics Related Diagnostic Messages:                               |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print Level 1 kinetics diagnostic messages                         |
|  [ ] ( 2) Print Level 1 and Level 2 kinetics diagnostic messages             |
|------------------------------------------------------------------------------|
|iodb(3) - Print Pre-Newton-Raphson Optimization Information:                  |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information (including the beta and del vectors)    |
|  [ ] ( 3) Print more detailed information (including matrix equations)       |
|  [ ] ( 4) Print most detailed information (including activity coefficients)  |
|------------------------------------------------------------------------------|
|iodb(4) - Print Newton-Raphson Iteration Information:                         |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information (including the beta and del vectors)    |
|  [ ] ( 3) Print more detailed information (including the Jacobian)           |
|  [ ] ( 4) Print most detailed information (including activity coefficients)  |
|------------------------------------------------------------------------------|
|iodb(5) - Print Step-Size and Order Selection:                                |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information                                         |
|------------------------------------------------------------------------------|
|iodb(6) - Print Details of Hypothetical Affinity Calculations:                |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information                                         |
|------------------------------------------------------------------------------|
|iodb(7) - Print General Search (e.g., for a phase boundary) Information:      |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|------------------------------------------------------------------------------|
|iodb(8) - Print ODE Corrector Iteration Information:                          |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information (including the betar and delvcr vectors)|
|------------------------------------------------------------------------------|
|Mineral Sub-Set Selection Suppression Options | (nxopt)                       |
|------------------------------------------------------------------------------|
|Option  |Sub-Set Defining Species| (this is a table header)                   |
|------------------------------------------------------------------------------|
|None    |None                    | (uxopt(n), uxcat(n))                       |
|------------------------------------------------------------------------------|
* Valid mineral sub-set selection suppression option strings (uxopt(n)) are:   *
*    None        All         Alwith      Allwith                               *
*------------------------------------------------------------------------------*
|Exceptions to the Mineral Sub-Set Selection Suppression Options | (nxopex)    |
|------------------------------------------------------------------------------|
|Mineral                 | (this is a table header)                            |
|------------------------------------------------------------------------------|
|None                    | (uxopex(n))                                         |
|------------------------------------------------------------------------------|
|Fixed Fugacity Options | (nffg)                                               |
|------------------------------------------------------------------------------|
|Gas                     |Moles to Add |Log Fugacity | --                      |
| (uffg(n))              | (moffg(n))  | (xlkffg(n)) | --                      |
|------------------------------------------------------------------------------|{gas_lines}
|------------------------------------------------------------------------------|
|Numerical Parameters                                                          |
|------------------------------------------------------------------------------|
|Max. finite-difference order               |{max_finite_difference_order}| (nordmx)            |
|Beta convergence tolerance                 |{beta_convergence_tolerance}| (tolbt)             |
|Del convergence tolerance                  |{del_convergence_tolerance}| (toldl)             |
|Max. No. of N-R iterations                 |{max_n_NR_iter}| (itermx)            |
|Search/find convergence tolerance          |{search_find_convergeance_tolerance}| (tolxsf)            |
|Saturation tolerance                       |{saturation_tolerance}| (tolsat)            |
|Max. No. of Phase Assemblage Tries         |{max_n_phase_assemblage_tries}| (ntrymx)            |
|Zero order step size (in Xi)               |{zero_order_step_size}| (dlxmx0)            |
|Max. interval in Xi between PRS transfers  |{max_interval_in_xi_between_PRS_transfers}| (dlxdmp)            |
|------------------------------------------------------------------------------|&#34;&#34;&#34;


rb_template = &#34;&#34;&#34;
|------------------------------------------------------------------------------|
|Reactant        |{reactant_name}| (ureac(n))                         |
|------------------------------------------------------------------------------|
|-&gt;|Type         |{reactant_type}| (urcjco(jcode(n)))                 |
|------------------------------------------------------------------------------|
|-&gt;|Status       |{reactant_status}| (urcjre(jreac(n)))                 |
|------------------------------------------------------------------------------|
|-&gt;|Amount remaining (moles) |{amount_remaining}| (morr(n))                          |
|------------------------------------------------------------------------------|
|-&gt;|Amount destroyed (moles) |{amount_destroyed}| (modr(n))                          |
|------------------------------------------------------------------------------|
|-&gt;|Surface area option (nsk(n)):                                              |
|-&gt;|  [{sa_checkbox_1}] ( 0) Constant surface area:                                          |
|-&gt;|             Value (cm2)       |{sa_val_1}| (sfcar(n))                   |
|-&gt;|  [{sa_checkbox_2}] ( 1) Constant specific surface area:                                 |
|-&gt;|             Value (cm2/g)     |{sa_val_2}| (ssfcar(n))                  |
|-&gt;|  [{sa_checkbox_3}] ( 2) n**2/3 growth law- current surface area:                        |
|-&gt;|             Value (cm2)       |{sa_val_3}| (sfcar(n))                   |
|------------------------------------------------------------------------------|
|-&gt;|Surface area factor      |{sa_factor}| (fkrc(n))                          |
|------------------------------------------------------------------------------|
|-&gt;|Forward rate law          |{f_rate_law}| (urcnrk(nrk(1,n)))    |
|------------------------------------------------------------------------------|
|---&gt;|dXi(n)/dXi (mol/mol)      |{rkb_1}| (rkb(1,1,n))                    |
|------------------------------------------------------------------------------|
|---&gt;|d2Xi(n)/dXi2 (mol/mol2)   |{rkb_2}| (rkb(2,1,n))                    |
|------------------------------------------------------------------------------|
|---&gt;|d3Xi(n)/dXi3 (mol/mol3)   |{rkb_3}| (rkb(3,1,n))                    |
|------------------------------------------------------------------------------|
|-&gt;|Backward rate law         |{b_rate_law}| (urcnrk(nrk(2,n)))    |&#34;&#34;&#34;


gl_template = &#34;&#34;&#34;
|{gas_name}|{gas_moles}|{gas_log_fugacity}| --                      |&#34;&#34;&#34;


class Reactant:
    def __init__(self,
                 reactant_name,
                 reactant_type=&#34;Pure mineral&#34;,
                 reactant_status=&#34;Reacting&#34;,
                 amount_remaining=1,
                 amount_destroyed=0,
                 surface_area_option=1,
                 surface_area_value=0,
                 surface_area_factor=0,
                 f_rate_law=&#34;Relative rate equation&#34;,
                 rkb_1=1,
                 rkb_2=0,
                 rkb_3=0,
                 b_rate_law=&#34;Partial equilibrium&#34;,
                 ):
        
        self.reactant_name=reactant_name
        self.reactant_type=reactant_type
        self.reactant_status=reactant_status
        self.amount_remaining=amount_remaining
        self.amount_destroyed=amount_destroyed
        self.sa_val_1=0
        self.sa_val_2=0
        self.sa_val_3=0
        self.sa_checkbox_1= &#34; &#34;
        self.sa_checkbox_2= &#34; &#34;
        self.sa_checkbox_3= &#34; &#34;
        
        if surface_area_option == 1:
            self.sa_checkbox_1 = &#34;x&#34;
            self.sa_val_1 = surface_area_value
        elif surface_area_option == 2:
            self.sa_checkbox_2 = &#34;x&#34;
            self.sa_val_2 = surface_area_value
        elif surface_area_option == 3:
            self.sa_checkbox_3 = &#34;x&#34;
            self.sa_val_3 = surface_area_value
        self.sa_factor=surface_area_factor
        
        self.f_rate_law=f_rate_law
        self.rkb_1=rkb_1
        self.rkb_2=rkb_2
        self.rkb_3=rkb_3
        self.b_rate_law=b_rate_law
        
        self.__format_block()


    def __format_block(self):
        
        rb_dict_formatted = dict(
            reactant_name = f&#34;{self.reactant_name:&lt;24}&#34;,
            reactant_type = f&#34;{self.reactant_type:&lt;24}&#34;,
            reactant_status = f&#34;{self.reactant_status:&lt;24}&#34;,
            amount_remaining = f&#34;{&#39;{:.5E}&#39;.format(self.amount_remaining):&gt;12}&#34;,
            amount_destroyed = f&#34;{&#39;{:.5E}&#39;.format(self.amount_destroyed):&gt;12}&#34;,
            sa_checkbox_1 = self.sa_checkbox_1,
            sa_checkbox_2 = self.sa_checkbox_2,
            sa_checkbox_3 = self.sa_checkbox_3,
            sa_val_1 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_1):&gt;12}&#34;,
            sa_val_2 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_2):&gt;12}&#34;,
            sa_val_3 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_3):&gt;12}&#34;,
            sa_factor = f&#34;{&#39;{:.5E}&#39;.format(self.sa_factor):&gt;12}&#34;,
            f_rate_law = f&#34;{self.f_rate_law:&lt;24}&#34;,
            rkb_1 = f&#34;{&#39;{:.5E}&#39;.format(self.rkb_1):&gt;12}&#34;,
            rkb_2 = f&#34;{&#39;{:.5E}&#39;.format(self.rkb_2):&gt;12}&#34;,
            rkb_3 = f&#34;{&#39;{:.5E}&#39;.format(self.rkb_3):&gt;12}&#34;,
            b_rate_law = f&#34;{self.b_rate_law:&lt;24}&#34;,
        )
    
        reactant_block_template = copy.copy(rb_template)
        self.formatted_block = reactant_block_template.format(**rb_dict_formatted)


class Gas:
    def __init__(self,
                 gas_name=&#34;None&#34;,
                 gas_moles=0,
                 gas_log_fugacity=0,
                ):

        self.gas_name=gas_name
        self.gas_moles=gas_moles
        self.gas_log_fugacity=gas_log_fugacity
        
        self.__format_line()
        
    def __format_line(self):
        
        gas_options_formatted = dict(
            gas_name = f&#34;{self.gas_name:&lt;24}&#34;,
            gas_moles = f&#34;{&#39;{:.5E}&#39;.format(self.gas_moles):&gt;13}&#34;,
            gas_log_fugacity = f&#34;{&#39;{:.5E}&#39;.format(self.gas_log_fugacity):&gt;13}&#34;,
        )
    
        gas_line_template = copy.copy(gl_template)
        self.formatted_line = gas_line_template.format(**gas_options_formatted)
        

class Prepare_Reaction:
    def __init__(self,
                 reactants,
                 gases=[],
                 t_option=0,
                 t_value_1=None, # temp
                 t_value_2=0,  # temp or deriv
                 t_value_3=0,  # mass ratio factor
                 p_option=0,
                 p_value_1=None,  # pressure
                 p_value_2=0,  # deriv
                 xi_range=[0, 1],
                 time_range=[0, 1e38],
                 pH_range=[-1e38, 1e38],
                 Eh_range=[-1e38, 1e38],
                 fO2_range=[-1e38, 1e38],
                 aw_range=[-1e38, 1e38],
                 max_n_steps=900,
                 xi_print_int=1,
                 log_xi_print_int=1,
                 time_print_int=1e38,
                 log_time_print_int=1e38,
                 pH_print_interval=1e38,
                 Eh_print_interval=1e38,
                 logfO2_print_interval=1e38,
                 aw_print_interval=1e38,
                 n_steps_print_interval=100,
                 max_finite_difference_order=6,
                 beta_convergence_tolerance=0,
                 del_convergence_tolerance=0,
                 max_n_NR_iter=500,
                 search_find_convergeance_tolerance=0,
                 saturation_tolerance=0,
                 max_n_phase_assemblage_tries=0,
                 zero_order_step_size=0,
                 max_interval_in_xi_between_PRS_transfers=0,
                 filename=None,
                ):
        
        if len(reactants) == 1 and not isinstance(reactants, list):
            reactants = list(reactants)
            
        if len(gases) == 0:
            gases = [Gas()]
        elif len(gases) == 1 and not isinstance(gases, list):
            gases = list(gases)
        
        self.reactants=reactants
        self.gases=gases
        self.t_option=t_option
        self.t_value_1=t_value_1
        self.t_value_2=t_value_2
        self.t_value_3=t_value_3
        self.p_option=p_option
        self.p_value_1=p_value_1
        self.p_value_2=p_value_2
        self.start_xi=xi_range[0]
        self.max_xi=xi_range[1]
        self.start_time=time_range[0]
        self.max_time=time_range[1]
        self.min_pH=pH_range[0]
        self.max_pH=pH_range[1]
        self.min_Eh=Eh_range[0]
        self.max_Eh=Eh_range[1]
        self.min_fO2=fO2_range[0]
        self.max_fO2=fO2_range[1]
        self.min_aw=aw_range[0]
        self.max_aw=aw_range[1]
        self.max_n_steps=max_n_steps
        self.xi_print_int=xi_print_int
        self.log_xi_print_int=log_xi_print_int
        self.time_print_int=time_print_int
        self.log_time_print_int=log_time_print_int
        self.pH_print_interval=pH_print_interval
        self.Eh_print_interval=Eh_print_interval
        self.logfO2_print_interval=logfO2_print_interval
        self.aw_print_interval=aw_print_interval
        self.n_steps_print_interval=n_steps_print_interval
        self.max_finite_difference_order=max_finite_difference_order
        self.beta_convergence_tolerance=beta_convergence_tolerance
        self.del_convergence_tolerance=del_convergence_tolerance
        self.max_n_NR_iter=max_n_NR_iter
        self.search_find_convergeance_tolerance=search_find_convergeance_tolerance
        self.saturation_tolerance=saturation_tolerance
        self.max_n_phase_assemblage_tries=max_n_phase_assemblage_tries
        self.zero_order_step_size=zero_order_step_size
        self.max_interval_in_xi_between_PRS_transfers=max_interval_in_xi_between_PRS_transfers
        
        self.t_checkbox_1=&#34; &#34;
        self.t_checkbox_2=&#34; &#34;
        self.t_checkbox_3=&#34; &#34;
        self.t_checkbox_4=&#34; &#34;
        self.tval1=0
        self.tval2=0
        self.tval3=0
        self.tval4=0
        self.tval5=0
        self.tval6=0
        self.tval7=0
        self.tval8=0
        self.p_checkbox_1=&#34; &#34;
        self.p_checkbox_2=&#34; &#34;
        self.p_checkbox_3=&#34; &#34;
        self.p_checkbox_4=&#34; &#34;
        self.p_checkbox_5=&#34; &#34;
        self.pval1=0
        self.pval2=0
        self.pval3=0
        self.pval4=0
        self.pval5=0
        self.i1_checkbox_1 = &#34; &#34;
        self.i1_checkbox_2 = &#34; &#34;
        self.i1_checkbox_3 = &#34; &#34;
        self.i2_checkbox_1 = &#34; &#34;
        self.i2_checkbox_2 = &#34; &#34;
        self.i3_checkbox_1 = &#34; &#34;
        self.i3_checkbox_2 = &#34; &#34;
        self.i3_checkbox_3 = &#34; &#34;
        self.i4_checkbox_1 = &#34; &#34;
        self.i4_checkbox_2 = &#34; &#34;
        self.i5_checkbox_1 = &#34; &#34;
        self.i5_checkbox_2 = &#34; &#34;
        self.i6_checkbox_1 = &#34; &#34;
        self.i6_checkbox_2 = &#34; &#34;
        self.i7_checkbox_1 = &#34; &#34;
        self.i7_checkbox_2 = &#34; &#34;
        self.i9_checkbox_1 = &#34; &#34;
        self.i9_checkbox_2 = &#34; &#34;
        self.i10_checkbox_1 = &#34; &#34;
        self.i10_checkbox_2 = &#34; &#34;
        self.i11_checkbox_1 = &#34; &#34;
        self.i11_checkbox_2 = &#34; &#34;
        self.i12_checkbox_1 = &#34; &#34;
        self.i12_checkbox_2 = &#34; &#34;
        self.i13_checkbox_1 = &#34; &#34;
        self.i13_checkbox_2 = &#34; &#34;
        self.i13_checkbox_3 = &#34; &#34;
        self.i14_checkbox_1 = &#34; &#34;
        self.i14_checkbox_2 = &#34; &#34;
        self.i14_checkbox_3 = &#34; &#34;
        self.i14_checkbox_4 = &#34; &#34;
        self.i20_checkbox_1 = &#34; &#34;
        self.i20_checkbox_2 = &#34; &#34;
        
        
        tval_var_to_format = None
        pval_var_to_format = None
        
        if t_option == 0:
            self.t_checkbox_1=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval1=t_value_1
            else:
                tval_var_to_format = 1

        elif t_option == 1:
            self.t_checkbox_2=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval2=t_value_1
                self.tval3=t_value_2
            else:
                tval_var_to_format = 2

        elif t_option == 2:
            self.t_checkbox_3=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval4=t_value_1
                self.tval5=t_value_2
            else:
                tval_var_to_format = 4
                
        elif t_option == 3:
            self.t_checkbox_4=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval6=t_value_1
                self.tval7=t_value_2
                self.tval8=t_value_3
            else:
                tval_var_to_format = 6
        else:
            raise Exception(&#34;t_option must be 0, 1, 2, or 3.&#34;)
            
        if p_option == 0:
            self.p_checkbox_1=&#34;x&#34;

        elif p_option == 1:
            self.p_checkbox_2=&#34;x&#34;

        elif p_option == 2:
            self.p_checkbox_3=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval1=p_value_1
            else:
                pval_var_to_format = 1
                
        elif p_option == 3:
            self.p_checkbox_4=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval2=p_value_1
                self.pval3=p_value_2
            else:
                pval_var_to_format = 2
                
        elif p_option == 4:
            self.p_checkbox_5=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval4=p_value_1
                self.pval5=p_value_2
            else:
                pval_var_to_format = 4

        else:
            raise Exception(&#34;p_option must be 0, 1, 2, 3, or 4.&#34;)
        
        now = datetime.now()
        self.date_created = now.strftime(&#39;%Y-%m-%d %I:%M %p&#39;)
        
        self.__format_reaction(tval_var_to_format, pval_var_to_format)
        
        if filename != None:
            with open(filename, &#39;w&#39;) as f:
                f.write(pr.formatted_reaction)
        
        
    def __format_reaction(self, tval_var_to_format=None, pval_var_to_format=None):
        reaction_options_formatted = dict(
            date_created=f&#34;{self.date_created:&lt;24}&#34;,
            start_xi=f&#34;{&#39;{:.5E}&#39;.format(self.start_xi):&gt;12}&#34;,
            max_xi=f&#34;{&#39;{:.5E}&#39;.format(self.max_xi):&gt;12}&#34;,
            start_time=f&#34;{&#39;{:.5E}&#39;.format(self.start_time):&gt;12}&#34;,
            max_time=f&#34;{&#39;{:.5E}&#39;.format(self.max_time):&gt;12}&#34;,
            min_pH=f&#34;{&#39;{:.5E}&#39;.format(self.min_pH):&gt;12}&#34;,
            max_pH=f&#34;{&#39;{:.5E}&#39;.format(self.max_pH):&gt;12}&#34;,
            min_Eh=f&#34;{&#39;{:.5E}&#39;.format(self.min_Eh):&gt;12}&#34;,
            max_Eh=f&#34;{&#39;{:.5E}&#39;.format(self.max_Eh):&gt;12}&#34;,
            min_fO2=f&#34;{&#39;{:.5E}&#39;.format(self.min_fO2):&gt;12}&#34;,
            max_fO2=f&#34;{&#39;{:.5E}&#39;.format(self.max_fO2):&gt;12}&#34;,
            min_aw=f&#34;{&#39;{:.5E}&#39;.format(self.min_aw):&gt;12}&#34;,
            max_aw=f&#34;{&#39;{:.5E}&#39;.format(self.max_aw):&gt;12}&#34;,
            max_n_steps=f&#34;{self.max_n_steps:&gt;12}&#34;,
            xi_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.xi_print_int):&gt;12}&#34;,
            log_xi_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.log_xi_print_int):&gt;12}&#34;,
            time_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.time_print_int):&gt;12}&#34;,
            log_time_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.log_time_print_int):&gt;12}&#34;,
            pH_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.pH_print_interval):&gt;12}&#34;,
            Eh_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.Eh_print_interval):&gt;12}&#34;,
            logfO2_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.logfO2_print_interval):&gt;12}&#34;,
            aw_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.aw_print_interval):&gt;12}&#34;,
            n_steps_print_interval=f&#34;{self.n_steps_print_interval:&gt;12}&#34;,
            max_finite_difference_order=f&#34;{self.max_finite_difference_order:&gt;12}&#34;,
            beta_convergence_tolerance=f&#34;{self.beta_convergence_tolerance:&gt;12}&#34;,
            del_convergence_tolerance=f&#34;{self.del_convergence_tolerance:&gt;12}&#34;,
            max_n_NR_iter=f&#34;{self.max_n_NR_iter:&gt;12}&#34;,
            search_find_convergeance_tolerance=f&#34;{self.search_find_convergeance_tolerance:&gt;12}&#34;,
            saturation_tolerance=f&#34;{self.saturation_tolerance:&gt;12}&#34;,
            max_n_phase_assemblage_tries=f&#34;{self.max_n_phase_assemblage_tries:&gt;12}&#34;,
            zero_order_step_size=f&#34;{self.zero_order_step_size:&gt;12}&#34;,
            max_interval_in_xi_between_PRS_transfers=f&#34;{self.max_interval_in_xi_between_PRS_transfers:&gt;12}&#34;,
            t_checkbox_1=self.t_checkbox_1,
            t_checkbox_2=self.t_checkbox_2,
            t_checkbox_3=self.t_checkbox_3,
            t_checkbox_4=self.t_checkbox_4,
            p_checkbox_1=self.p_checkbox_1,
            p_checkbox_2=self.p_checkbox_2,
            p_checkbox_3=self.p_checkbox_3,
            p_checkbox_4=self.p_checkbox_4,
            p_checkbox_5=self.p_checkbox_5,
            i1_checkbox_1=self.i1_checkbox_1,
            i1_checkbox_2=self.i1_checkbox_2,
            i1_checkbox_3=self.i1_checkbox_3,
            i2_checkbox_1=self.i2_checkbox_1,
            i2_checkbox_2=self.i2_checkbox_2,
            i3_checkbox_1=self.i3_checkbox_1,
            i3_checkbox_2=self.i3_checkbox_2,
            i3_checkbox_3=self.i3_checkbox_3,
            i4_checkbox_1=self.i4_checkbox_1,
            i4_checkbox_2=self.i4_checkbox_2,
            i5_checkbox_1=self.i5_checkbox_1,
            i5_checkbox_2=self.i5_checkbox_2,
            i6_checkbox_1=self.i6_checkbox_1,
            i6_checkbox_2=self.i6_checkbox_2,
            i7_checkbox_1=self.i7_checkbox_1,
            i7_checkbox_2=self.i7_checkbox_2,
            i9_checkbox_1=self.i9_checkbox_1,
            i9_checkbox_2=self.i9_checkbox_2,
            i10_checkbox_1=self.i10_checkbox_1,
            i10_checkbox_2=self.i10_checkbox_2,
            i11_checkbox_1=self.i11_checkbox_1,
            i11_checkbox_2=self.i11_checkbox_2,
            i12_checkbox_1=self.i12_checkbox_1,
            i12_checkbox_2=self.i12_checkbox_2,
            i13_checkbox_1=self.i13_checkbox_1,
            i13_checkbox_2=self.i13_checkbox_2,
            i13_checkbox_3=self.i13_checkbox_3,
            i14_checkbox_1=self.i14_checkbox_1,
            i14_checkbox_2=self.i14_checkbox_2,
            i14_checkbox_3=self.i14_checkbox_3,
            i14_checkbox_4=self.i14_checkbox_4,
            i20_checkbox_1=self.i20_checkbox_1,
            i20_checkbox_2=self.i20_checkbox_2,
        )
        
        # leave {tval1} (or {tval2}, {tval3}...) in pre_6i file so it can be updated after joining 3p
        if tval_var_to_format != None:
            reaction_options_formatted[&#34;tval&#34;+str(tval_var_to_format)] = &#34;{tval}&#34;
            for i in range(1, 9):
                if i == tval_var_to_format:
                    continue
                else:
                    reaction_options_formatted[&#34;tval&#34;+str(i)]=f&#34;{&#39;{:.5E}&#39;.format(getattr(self, &#39;tval&#39;+str(i))):&gt;12}&#34;
        else:
            reaction_options_formatted.update(dict(
                tval1=f&#34;{&#39;{:.5E}&#39;.format(self.tval1):&gt;12}&#34;,
                tval2=f&#34;{&#39;{:.5E}&#39;.format(self.tval2):&gt;12}&#34;,
                tval3=f&#34;{&#39;{:.5E}&#39;.format(self.tval3):&gt;12}&#34;,
                tval4=f&#34;{&#39;{:.5E}&#39;.format(self.tval4):&gt;12}&#34;,
                tval5=f&#34;{&#39;{:.5E}&#39;.format(self.tval5):&gt;12}&#34;,
                tval6=f&#34;{&#39;{:.5E}&#39;.format(self.tval6):&gt;12}&#34;,
                tval7=f&#34;{&#39;{:.5E}&#39;.format(self.tval7):&gt;12}&#34;,
                tval8=f&#34;{&#39;{:.5E}&#39;.format(self.tval8):&gt;12}&#34;,
            ))
            
        # leave {pval1} (or {pval2}, {pval3}...) in pre_6i file so it can be updated after joining 3p
        if pval_var_to_format != None:
            reaction_options_formatted[&#34;pval&#34;+str(pval_var_to_format)] = &#34;{pval}&#34;
            for i in range(1, 6):
                if i == pval_var_to_format:
                    continue
                else:
                    reaction_options_formatted[&#34;pval&#34;+str(i)]=f&#34;{&#39;{:.5E}&#39;.format(getattr(self, &#39;pval&#39;+str(i))):&gt;12}&#34;
        else:
            reaction_options_formatted.update(dict(
                pval1=f&#34;{&#39;{:.5E}&#39;.format(self.pval1):&gt;12}&#34;,
                pval2=f&#34;{&#39;{:.5E}&#39;.format(self.pval2):&gt;12}&#34;,
                pval3=f&#34;{&#39;{:.5E}&#39;.format(self.pval3):&gt;12}&#34;,
                pval4=f&#34;{&#39;{:.5E}&#39;.format(self.pval4):&gt;12}&#34;,
                pval5=f&#34;{&#39;{:.5E}&#39;.format(self.pval5):&gt;12}&#34;,
            ))

        
        reactant_blocks = &#34;&#34;.join([r.formatted_block for r in self.reactants])
        gas_lines = &#34;&#34;.join([r.formatted_line for r in self.gases])
        reaction_options_formatted.update(dict(reactant_blocks=reactant_blocks))
        reaction_options_formatted.update(dict(gas_lines=gas_lines))
        
        reaction_template = copy.copy(template)
        self.formatted_reaction = reaction_template.format(**reaction_options_formatted)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="AqEquil.MassTransfer.react"><code class="name flex">
<span>def <span class="ident">react</span></span>(<span>speciation, first_half_of_6i, delete_generated_folders=False, hide_traceback=True)</span>
</code></dt>
<dd>
<div class="desc"><p>React speciated water with minerals and/or gases.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>speciation</code></strong> :&ensp;<code><code>AqSpeciation.Speciation&lt;/code&gt; object</code></dt>
<dd>The output of a speciation calculation produced by the
function.</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def react(speciation, first_half_of_6i, delete_generated_folders=False, hide_traceback=True):
    
    &#34;&#34;&#34;
    React speciated water with minerals and/or gases.

    Parameters
    ----------
    speciation : `AqSpeciation.Speciation` object
        The output of a speciation calculation produced by the
        function.

    Returns
    ----------
    &#34;&#34;&#34;
    
    prev_wd = os.getcwd()
    ae = AqEquil()
    
    speciation.join_6i_3p(first_half_of_6i)
    __delete_file(&#34;data1.dyn&#34;)
    
    paths=[&#39;rxn_6o&#39;, &#39;rxn_6p&#39;, &#39;eq6_extra_out&#39;]
    for path in paths:
        if not os.path.exists(path):
            os.makedirs(path)
        else:
            shutil.rmtree(path)
            os.makedirs(path)
            
    os.environ[&#39;EQ36DA&#39;] = &#34;eq6_extra_out&#34; # ensuring data1 is read from a folder without spaces overcomes the problem where environment variables with spaces do not work properly when assigned to EQ36DA
            
    for sample_name in list(speciation.sample_data.keys()):
        filename_6i = speciation.sample_data[sample_name][&#34;filename&#34;][:-3]+&#34;.6i&#34;
        filename_6o = filename_6i[:-3]+&#34;.6o&#34;
        filename_6p = filename_6i[:-3]+&#34;.6p&#34;

        if isinstance(speciation.data1, dict):
            # each sample has a unique data1. e.g., with dynamic_db
            __delete_file(&#34;eq6_extra_out/data1.dyn&#34;)
            with open(&#34;eq6_extra_out/data1.dyn&#34;, &#39;wb&#39;) as f:
                f.write(speciation.data1[speciation.sample_data[sample_name][&#34;filename&#34;][:-3]])
        else:
            # all samples use the same data1.
            with open(&#34;eq6_extra_out/data1.dyn&#34;, &#39;wb&#39;) as f:
                f.write(speciation.data1)

        ae.runeq6(filename_6i, db=&#34;dyn&#34;, path_6i=&#34;rxn_6i&#34;,
                  dynamic_db_name=speciation.thermo_db_callname)
        
        os.rename(&#39;tab&#39;, &#39;tab.csv&#39;)
        
        __move_file(filename_6o, &#34;rxn_6o&#34;)
        __move_file(filename_6p, &#34;rxn_6p&#34;)

        __delete_file(&#34;data1.dyn&#34;)
        __delete_file(&#34;data1&#34;)
        
        if speciation.thermo_db_type == &#34;CSV file&#34;:
            m = Mass_Transfer(thermodata_csv=speciation.thermo_db,
                              six_o_file=&#39;rxn_6o/&#39;+filename_6o,
                              tab_name=&#39;tab.csv&#39;,
                              hide_traceback=hide_traceback)

            speciation.sample_data[sample_name][&#34;mass_transfer&#34;] = m
    
    __move_file(&#34;bakupa&#34;, &#34;eq6_extra_out&#34;, silent=True)
    __move_file(&#34;bakupb&#34;, &#34;eq6_extra_out&#34;, silent=True)
    __move_file(&#34;tabx&#34;, &#34;eq6_extra_out&#34;, silent=True)
    __move_file(&#39;tab.csv&#39;, &#34;eq6_extra_out&#34;, silent=True)
    __delete_file(&#34;eq6_extra_out/data1.dyn&#34;)
    __delete_file(&#34;data1&#34;)
        
    if delete_generated_folders:
        __delete_dir(&#34;eq6_extra_out&#34;)
        __delete_dir(&#34;rxn_6i&#34;)
        __delete_dir(&#34;rxn_6p&#34;)
        __delete_dir(&#34;rxn_6o&#34;)
    
    return speciation</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AqEquil.MassTransfer.Gas"><code class="flex name class">
<span>class <span class="ident">Gas</span></span>
<span>(</span><span>gas_name='None', gas_moles=0, gas_log_fugacity=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gas:
    def __init__(self,
                 gas_name=&#34;None&#34;,
                 gas_moles=0,
                 gas_log_fugacity=0,
                ):

        self.gas_name=gas_name
        self.gas_moles=gas_moles
        self.gas_log_fugacity=gas_log_fugacity
        
        self.__format_line()
        
    def __format_line(self):
        
        gas_options_formatted = dict(
            gas_name = f&#34;{self.gas_name:&lt;24}&#34;,
            gas_moles = f&#34;{&#39;{:.5E}&#39;.format(self.gas_moles):&gt;13}&#34;,
            gas_log_fugacity = f&#34;{&#39;{:.5E}&#39;.format(self.gas_log_fugacity):&gt;13}&#34;,
        )
    
        gas_line_template = copy.copy(gl_template)
        self.formatted_line = gas_line_template.format(**gas_options_formatted)</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer"><code class="flex name class">
<span>class <span class="ident">Mass_Transfer</span></span>
<span>(</span><span>six_o_file, thermodata_csv=None, tab_name=None, hide_traceback=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class containing functions to facilitate mass transfer and reaction path
calculations and visualize results.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>thermodata_csv</code></strong> :&ensp;<code>str</code></dt>
<dd>Path name of the WORM-styled thermodynamic database CSV used in the EQ6
calculation.</dd>
<dt><strong><code>six_o_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path name of the '6o' output file generated by EQ6.</dd>
<dt><strong><code>tab_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Path name of the TAB file generated by EQ6.</dd>
<dt><strong><code>hide_traceback</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Hide traceback message when encountering errors handled by this class?
When True, error messages handled by this class will be short and to
the point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mass_Transfer:
    &#34;&#34;&#34;
    Class containing functions to facilitate mass transfer and reaction path
    calculations and visualize results.
    
    Parameters
    ----------
    thermodata_csv : str
        Path name of the WORM-styled thermodynamic database CSV used in the EQ6
        calculation.
        
    six_o_file : str
        Path name of the &#39;6o&#39; output file generated by EQ6.
    
    tab_name : str
        Path name of the TAB file generated by EQ6.
    
    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this class?
        When True, error messages handled by this class will be short and to
        the point.
    
    &#34;&#34;&#34;
    def __init__(self, six_o_file, thermodata_csv=None, tab_name=None, hide_traceback=True):
        
        self.err_handler = Error_Handler(clean=hide_traceback)
        
        self.six_o_file = six_o_file
        self.thermodata_csv = thermodata_csv
        self.tab_name = tab_name
        
        if isinstance(thermodata_csv, pd.DataFrame) or isinstance(thermodata_csv, str):
            # these operations require a WORM-style thermodynamic database CSV
            
            obigt = thermo().OBIGT
            thermo(OBIGT = obigt.loc[ obigt.name.isin(FIXED_SPECIES), : ])
            _ = add_OBIGT(thermodata_csv, force=True, messages=False)
            
            self.tab = self.process_tab(tab_name, thermodata_csv)

            if isinstance(thermodata_csv, str):
                self.df = pd.read_csv(thermodata_csv)
            elif isinstance(thermodata_csv, pd.DataFrame):
                self.df = thermodata_csv
            else:
                self.err_handler.raise_exception(&#34;Cannot process reaction output &#34;
                    &#34;because the thermodynamic database specified by thermodata_csv &#34;
                    &#34;is not the a WORM-style dataframe or CSV file.&#34;)

            basis_df = self.df[self.df[&#34;tag&#34;] == &#34;basis&#34;]
            aux_df = self.df[self.df[&#34;tag&#34;] == &#34;aux&#34;]
            refstate_df = self.df[self.df[&#34;tag&#34;] == &#34;refstate&#34;]
            self.basis_df = pd.concat([basis_df])
            self.basis_aux_df = pd.concat([basis_df, aux_df, refstate_df])
            self.df_cr = self.df[self.df[&#34;state&#34;] == &#39;cr&#39;]
        
        # these operations only require a 6o file
        self.aq_distribution = self.__get_aq_distribution()
        self.moles_minerals = self.__get_moles_minerals()
        self.moles_product_minerals = self.__get_moles_product_minerals()

        
    def mine_6o_table(self,
                      table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                      table_stop=&#34;Species with molalities less than&#34;,
                      ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                      col_index=-1):
        
        &#34;&#34;&#34;
        Mine a table in a &#39;6o&#39; EQ6 output file and consolidate results into a
        dataframe.
        
        Parameters
        ----------
        table_start : str
            A unique string that indicates the start of the table.

        table_stop : str, optional
            A unique string that indicates the end of the table.
        
        ignore : list of str
            A list of strings representing lines to ignore when mining a table.
            For example, it is prudent to ignore blank lines, or lines
            containing the table column headers.
            A line will be skipped if line.strip().split(&#39; &#39;)[0] matches any
            of the strings in the given list.
        
        col_index : int, default -1
            Integer representing the index of the table column to be mined.
            The default is -1, which is the last column in the table.
            
        Returns
        -------
        df : Pandas dataframe
            A dataframe with rows of the extent of reaction (Xi), and columns
            containing the values of chemical species mined from the file.
        &#34;&#34;&#34;
        
        f=open(self.six_o_file, mode=&#39;r&#39;)
        lines=f.readlines()
        f.close()

        species = []
        xi_vals=[]
        collect_values = False
        for i in lines:
            if len(i.strip().split(&#39; &#39;)) &gt; 1 and i.strip().split(&#39; &#39;)[0] == &#34;Xi=&#34;:
                xi_vals.append(float(i.split(&#39; &#39;)[-1]))
            if table_stop in i:
                collect_values = False
            if table_start in i:
                collect_values = True
            if collect_values:
                if i.strip().split(&#39; &#39;)[0] not in ignore:
                    species.append(i.strip().split(&#39; &#39;)[0])

        species = list(set(species))
        
        species_dict = {&#34;Xi&#34;:xi_vals}
        for s in species:

            vals=[]
            collect_values = False
            for i in lines:
                if collect_values and table_stop in i:
                    # stop collecting
                    collect_values = False
                    if not got_value:
                        vals.append(np.nan)
                if table_start in i:
                    # start collecting
                    collect_values = True
                    got_value = False
                if collect_values:
                    if len(i.strip().split(&#39; &#39;)) &gt; 2 and i.strip().split(&#39; &#39;)[0] == s:
                        split_i = i.strip().split(&#39; &#39;)
                        split_i_clean = [v for v in split_i if v != &#39;&#39;]
                        vals.append(float(split_i_clean[col_index]))
                        got_value = True
            species_dict[s] = vals

        df = pd.DataFrame(species_dict)
        
        return df
        
        
    def __get_aq_distribution(self):
        
        return self.mine_6o_table(
                      table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                      table_stop=&#34;Species with molalities less than&#34;,
                      ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                      col_index=-1)
 
        
 
    def __get_moles_minerals(self):
        
        return self.mine_6o_table(
                      table_start=&#34;Grand Summary of Solid Phases&#34;,
                      table_stop=&#34;Mass, grams       Volume, cm3&#34;,
                      ignore = [&#34;&#34;, &#34;Phase/End-member&#34;, &#39;---&#39;],
                      col_index=2)

    
    def __get_moles_product_minerals(self):
        
        return self.mine_6o_table(
                      table_start=&#34;--- Summary of Solid Phases (ES) ---&#34;,
                      table_stop=&#34;Grand Summary of Solid Phases&#34;,
                      ignore = [&#34;&#34;, &#34;Phase/End-member&#34;, &#39;---&#39;],
                      col_index=2)
        
        
    def print_tabs(self):
        &#34;&#34;&#34;
        Print the names of tables contained in a tab file processed by the
        the Mass_Transfer class.
        &#34;&#34;&#34;
        [print(key) for key in self.tab.keys()]

        
    @staticmethod
    def __is_all_same_value(s):
        a = s.to_numpy()
        return (a[0] == a).all()
        
        
    def plot_reaction_paths(self,
                            xyb=None, path_margin=0.25, flip_xy=False,
                            h_line_color=&#34;red&#34;,
                            v_line_color=&#34;blue&#34;,
                            d_line_color=&#34;orange&#34;,
                            res=300,
                            plot_width=4, plot_height=3, ppi=122,
                            borders=0,
                            colormap=&#34;viridis&#34;):
        
        &#34;&#34;&#34;
        Create interactive plots of reaction paths in geochemical variable
        space.
        
        Parameters
        ----------
        xyb : list of three str, default None
            By default, this function will plot reaction paths in all possible
            dimensions.
            
            Optionally, if you want to produce only a specific plot,
            you can provide a list containing the basis species to be used for
            the x-axis and y-axis, followed by the basis species used for
            balance. For example, [&#34;Fe+2&#34;, &#34;Fe+3&#34;, &#34;Mg+2&#34;] will have the log
            activity of Fe+2 on the x-axis, the log activity of Fe+3 on the
            y-axis, and will be balanced on Mg+2.

        path_margin : float, default 0.25
            Controls the spacing between the reaction path and the plot axes.
            Increasing this value increases the spacing.
        
        flip_xy : bool, default False
            Transpose the plot so the x and y variables switch axes?
        
        h_line_color : str, default &#34;red&#34;
            Color of horizontal lines.
        
        v_line_color : str, default &#34;blue&#34;
            Color of vertical lines.
        
        d_line_color : str, default &#34;orange&#34;
            Color of diagonal lines.
            
        Returns
        -------
        fig_list : a list of Plotly figure objects
            A list of interactive Plotly figures. If xyb equals None
            (the default), then the list will contain figures representing all
            combinations of geochemical variables. Optionally, if xyb is
            specified, fig_list will only contain the single figure of interest.
        &#34;&#34;&#34;
        
        error_messages = []
        
        # check that there is only one temperature and pressure
        if not self.__is_all_same_value(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Temp(C)&#34;]):
            error_messages.append(&#34;Reaction paths cannot be plotted when temperature changes with reaction progress.&#34;)
        if not self.__is_all_same_value(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Press(bars)&#34;]):
            error_messages.append(&#34;Reaction paths cannot be plotted when pressure changes with reaction progress.&#34;)
        
        if len(error_messages)&gt;0:
            self.err_handler.raise_exception(error_messages)
        
        self.T = float(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Temp(C)&#34;][0])
        self.P = float(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Press(bars)&#34;][0])
        self.path_margin = path_margin
        
        minerals_formed = list(self.tab[&#34;Table P Moles of product minerals&#34;].columns[2:])

        all_elements_of_interest = []
        for mineral in minerals_formed:
            all_elements_of_interest += self.__get_elem_ox_of_interest_in_minerals(mineral)
        all_elements_of_interest = list(set(all_elements_of_interest))
        
        self.all_elements_of_interest = all_elements_of_interest
        
        # get a list of elem pairs for plotting
        alist = self.all_elements_of_interest
        element_plot_pairs = []
        for result in itertools.combinations(alist, 2):
            element_plot_pairs.append(list(result))

        if xyb == None:
            element_plot_triad = []
            for pair in element_plot_pairs:
                elem_not_in_pair = [e for e in self.all_elements_of_interest if e not in pair]
                for e in elem_not_in_pair:
                    triad_to_append = pair + [e]
                    element_plot_triad.append(triad_to_append)
        else:
            element_plot_triad = [[self.__get_elem_ox_of_interest_in_minerals(v)[0] for v in xyb]]
        
        if colormap == &#34;bw&#34;:
            if borders == 0:
                borders = 1
            colormap = &#34;none&#34;
            h_line_color = &#34;black&#34;
            v_line_color = &#34;black&#34;
            d_line_color = &#34;black&#34;
        
        fig_list = []
        for triad in element_plot_triad:
            fig = self.__plot_reaction_path_main(
                            triad, T=self.T, P=self.P,
                            path_margin=self.path_margin,
                            flip_xy=flip_xy,
                            h_line_color=h_line_color,
                            v_line_color=v_line_color,
                            d_line_color=d_line_color,
                            res=res,
                            plot_width=plot_width,
                            plot_height=plot_height,
                            ppi=ppi,
                            colormap=colormap,
                            borders=borders)
            
            fig_list.append(fig)
        
        return fig_list
        
    
    @staticmethod
    def process_tab(tab_name, thermodata_csv):
        
        &#34;&#34;&#34;
        Process a TAB file (from EQ6) into a dictionary of Pandas dataframes.
        
        Parameters
        ----------
        tab_name : str
            Path name of the TAB file generated by EQ6.
        
        thermodata_csv : str or Pandas dataframe
            Path name of the WORM-styled thermodynamic database CSV used in the
            EQ6 calculation. Alternately, the thermodynamic database itself as a
            Pandas dataframe itself.

        Returns
        -------
        tab : a dict of Pandas dataframes
            A dictionary of dataframes representing tables mined from the TAB
            file.
        &#34;&#34;&#34;
        
        if isinstance(thermodata_csv, str):
            thermo_db = pd.read_csv(thermodata_csv)
        else:
            thermo_db = thermodata_csv
        
        
        thermo_db_names = list(thermo_db[&#34;name&#34;])

        with open(tab_name, &#34;r&#34;) as tabfile:
            tab_lines = tabfile.readlines()

        tab = {}

        tables = [&#34;B1&#34;, &#34;B2&#34;, &#34;C1&#34;, &#34;C2&#34;, &#34;C3&#34;, &#34;C4&#34;,
                  &#34;D1&#34;, &#34;D2&#34;, &#34;D3&#34;, &#34;D4&#34;, &#34;E1&#34;, &#34;E2&#34;,
                  &#34;E3&#34;, &#34;J&#34;, &#34;K&#34;, &#34;P&#34;, &#34;Q&#34;, &#34;T&#34;, &#34;W&#34;]

        record_lines = False
        get_header = False
        recorded_lines = []
        for line in tab_lines:
            split_line = line.split(&#34;,&#34;)

            if True in [s in [&#34;Table &#34; + t for t in tables] for s in split_line]:
                get_header = True
                table_name = &#34; &#34;.join(split_line[1:-1])
                continue

            if get_header:
                header = split_line[1:-1]

                # handle instances where the tab file creates extra columns for things like &#34;albite,low&#34;
                if table_name == &#34;Table P Moles of product minerals&#34; or table_name == &#34;Table Q Saturation indices of potential product phases&#34;:
                    if table_name == &#34;Table P Moles of product minerals&#34;:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;] # table P
                    else:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;H2O&#34;, &#34;Gas&#34;] # table Q

                    for i,h in enumerate(header):

                        if h != &#34;Xi&#34; and h != &#34;t(days)&#34; and h != &#34;H2O&#34; and h != &#34;Gas&#34;:
                            if h not in thermo_db_names:
                                if header[i-1]+&#34;,&#34;+h in thermo_db_names:
                                    new_header = new_header[:-1]
                                    new_header.append(header[i-1]+&#34;,&#34;+h)
                                else:
                                    new_header.append(h)
                            else:
                                new_header.append(h)

                    header = new_header


                record_lines = True
                get_header = False
                continue

            if &#34;EndTable:&#34; in split_line:
                record_lines = False
                if len(recorded_lines) &gt; 0:
                    df = pd.DataFrame(recorded_lines)
                    recorded_lines = []
                    df.columns = header
                    tab[table_name] = df

            if record_lines:
                recorded_lines.append(split_line[1:-1])

        return tab

    
    def __get_mineral_elem_ox(self, mineral):
        split_list = list(self.df[self.df[&#34;name&#34;]==mineral][&#34;formula_ox&#34;])[0].split()
        split_list_clean = [s.replace(&#34; &#34;, &#34;&#34;) for s in split_list]
        elem_ox_list = [re.findall(r&#34;^(?:\d+|)([A-Z].*$)&#34;, s)[0] for s in split_list]
        return elem_ox_list

    
    def __get_elem_ox_of_interest_in_minerals(self, mineral_name):
        mineral_elements = self.__get_mineral_elem_ox(mineral_name)
        mineral_elements_of_interest = [e for e in mineral_elements if e not in [&#34;H+&#34;, &#34;O-2&#34;]]
        return mineral_elements_of_interest


    def __get_mineral_elem_ox_dict(self, mineral):
        split_list = list(self.df[self.df[&#34;name&#34;]==mineral][&#34;formula_ox&#34;])[0].split()
        split_list_clean = [s.replace(&#34; &#34;, &#34;&#34;) for s in split_list]
        elem_ox_names = self.__get_mineral_elem_ox(mineral)

        elem_ox_list = []
        for s in split_list:
            coeff = re.findall(r&#34;(\d+)[A-Z]&#34;, s)
            if len(coeff) == 0:
                coeff = 1
            else:
                coeff = float(coeff[0])
            elem_ox_list.append(coeff)

        return {key:val for key,val in zip(elem_ox_names, elem_ox_list)}

    
    def __get_mineral_elem_ox_dict_interest(self, mineral):
        mineral_dict = self.__get_mineral_elem_ox_dict(mineral)
        return {key:value for key,value in zip(mineral_dict.keys(), mineral_dict.values()) if key not in [&#34;H+&#34;, &#34;O-2&#34;]}


    def __get_basis_from_elem(self, elem):

        basis_species_x = None

        for s in list(self.basis_df[&#34;name&#34;]):
            if elem in self.__get_elem_ox_of_interest_in_minerals(s):
                basis_species_x = s

        if basis_species_x == None:
            for s in list(self.basis_aux_df[&#34;name&#34;]):
                if elem in self.__get_elem_ox_of_interest_in_minerals(s):
                    basis_species_x = s

        return basis_species_x

    
    def __get_reaction_path(self, plot_basis_x, plot_basis_y, div_var_name):

        xi_vals=self.aq_distribution[&#34;Xi&#34;]
        proton_vals=self.aq_distribution[&#34;H+&#34;]
        x_vals=self.aq_distribution[plot_basis_x]
        y_vals=self.aq_distribution[plot_basis_y]

        assert len(proton_vals) == len(x_vals), f&#34;number of proton values ({proton_vals}) should equal number of x values ({x_vals})&#34;
        assert len(proton_vals) == len(y_vals), f&#34;number of proton values ({proton_vals}) should equal number of y values ({y_vals})&#34;

        x_vals = [log10((10**float(x))/(10**float(d))**_get_ion_ratio_exponent(plot_basis_x, &#34;H+&#34;)) for x,d in zip(x_vals,proton_vals)]
        y_vals = [log10((10**float(y))/(10**float(d))**_get_ion_ratio_exponent(plot_basis_y, &#34;H+&#34;)) for y,d in zip(y_vals,proton_vals)]

        return xi_vals, x_vals, y_vals

    
    def __get_plot_range(self, x_vals, y_vals):
        min_x_val = min(x_vals)
        min_y_val = min(y_vals)
        max_x_val = max(x_vals)
        max_y_val = max(y_vals)

        path_x_range = max_x_val - min_x_val
        path_y_range = max_y_val - min_y_val

        plot_x_range = [min_x_val-self.path_margin*path_x_range, max_x_val+self.path_margin*path_x_range]
        plot_y_range = [min_y_val-self.path_margin*path_y_range, max_y_val+self.path_margin*path_y_range]

        return plot_x_range, plot_y_range

    
    @staticmethod
    def __get_xy_labs(plot_basis_x, plot_basis_y):
        try:
            xlab = ratlab(plot_basis_x)
        except:
            xlab = &#34;log a&#34;+chemlabel(plot_basis_x)
        try:
            ylab = ratlab(plot_basis_y)
        except:
            ylab = &#34;log a&#34;+chemlabel(plot_basis_y)

        return xlab, ylab


    def __plot_reaction_path_background(self, plot_basis_x, plot_basis_y,
                                        div_var_name, x_vals, y_vals,
                                        colormap=&#34;viridis&#34;, borders=0,
                                        field_minerals_exist=True, path_margin=0.25,
                                        plot_width=4, plot_height=3, ppi=122, res=300,
                                        annotation=None, annotation_coords=[0, 0],
                                        messages=False):

        plot_x_range, plot_y_range = self.__get_plot_range(x_vals, y_vals)

        xlab,ylab = self.__get_xy_labs(plot_basis_x, plot_basis_y)
        
        args = {plot_basis_x:plot_x_range+[res],
                plot_basis_y:plot_y_range+[res],
                &#34;T&#34;:self.T, &#34;P&#34;:self.P, &#34;messages&#34;:messages}

        if field_minerals_exist:
            a = affinity(**args)
            e = equilibrate(a, balance=self.__get_basis_from_elem(div_var_name), messages=messages)

            return diagram_interactive(e, colormap=colormap, borders=borders,
                           balance=self.__get_basis_from_elem(div_var_name),
                           width=plot_width*ppi, height=plot_height*ppi,
                           xlab=xlab, ylab=ylab, annotation=annotation,
                           plot_it=False, messages=messages)
        else:
            # empty plot upon
            fig = go.Figure(go.Scatter(x=pd.Series(dtype=object),
                                       y=pd.Series(dtype=object),
                                       mode=&#34;markers&#34;,
                                       ),
                           layout_xaxis_range=plot_x_range,
                           layout_yaxis_range=plot_y_range,
                           )

            fig.add_annotation(x=annotation_coords[0],
                               y=annotation_coords[1],
                               xref=&#34;paper&#34;,
                               yref=&#34;paper&#34;,
                               align=&#39;left&#39;,
                               text=annotation,
                               bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;,
                               showarrow=False)

            fig.update_layout(
                width=plot_width*ppi, height=plot_height*ppi,
                xaxis={&#34;title&#34;: xlab},
                yaxis={&#34;title&#34;: ylab},
                template=&#34;simple_white&#34;,
            )

            fig.update_yaxes(autorange=True)

            return None,fig # a table and diagram without regions


    @staticmethod
    def __calc_dissrxn_logK(mineral, T, P):

        logK = subcrt([mineral], coeff=[1], property=&#39;logK&#39;, T=T, P=P, show=False, messages=False)[&#34;out&#34;][&#34;logK&#34;].item()
        return logK

    
    def __add_reaction_path_to_plot(self, x_vals, y_vals, xi_vals, fig, basis_species_x, basis_species_y, path_margin=0.25):

        min_x_val = min(x_vals)
        min_y_val = min(y_vals)
        max_x_val = max(x_vals)
        max_y_val = max(y_vals)

        path_x_range = max_x_val - min_x_val
        path_y_range = max_y_val - min_y_val

        xlab,ylab = self.__get_xy_labs(basis_species_x, basis_species_y)

        fig.add_trace(
            go.Scatter(
                x=x_vals,
                y=y_vals,
                line=go.scatter.Line(color=&#34;black&#34;),
                mode=&#39;lines+markers&#39;,
                showlegend=True,
                name=&#39;reaction path&#39;,
                text = xi_vals,
                hovertemplate = &#39;Xi = %{text}&lt;br&gt;&#39;+xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab+&#39;: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;)
        )

        fig.update_xaxes(range=self.__get_plot_range(x_vals, y_vals)[0], autorange=False)
        fig.update_yaxes(range=self.__get_plot_range(x_vals, y_vals)[1], autorange=False)

        return fig

    
    def __plot_reaction_path_main(self,
                                  triad, T=25, P=1, path_margin=0.25,
                                  flip_xy=False,
                                  h_line_color=&#34;red&#34;,
                                  v_line_color=&#34;blue&#34;,
                                  d_line_color=&#34;orange&#34;,
                                  res=300,
                                  plot_width=4,
                                  plot_height=3,
                                  ppi=122,
                                  colormap=&#34;viridis&#34;,
                                  borders=0):

        e_pair = triad[0:2]
        div_var_name = triad[2]

        if flip_xy:
            e_pair.reverse()

        basis_species_x = self.__get_basis_from_elem(e_pair[0])
        basis_species_y = self.__get_basis_from_elem(e_pair[1])

        basis_sp_list = list(self.tab[&#34;Table E2 Basis species(log activity; log fugacity for O2(g))&#34;].columns)[2:-1]
        basis_sp_list += [self.__get_basis_from_elem(e) for e in self.all_elements_of_interest]
        basis_sp_list = list(set(basis_sp_list))

        if basis_species_x not in basis_sp_list:
            basis_sp_list += [basis_species_x]
        if basis_species_y not in basis_sp_list:
            basis_sp_list += [basis_species_y]

        try:
            basis(basis_sp_list)
        except:
            basis(basis_sp_list + [&#34;H2&#34;])


        mineral_names = list(self.df_cr[&#34;name&#34;])
        mineral_formula_ox = [self.__get_elem_ox_of_interest_in_minerals(m) for m in mineral_names]
        mineral_formula_ox_singles = [e if len(e)==1 else [] for e in mineral_formula_ox]
        mineral_formula_ox_doubles = [e if len(e)==2 else [] for e in mineral_formula_ox]
        mineral_formula_ox_triples = [e if len(e)==3 else [] for e in mineral_formula_ox]

        retrieved_minerals = []
        for i,s in enumerate(mineral_formula_ox_singles):
            if [e_pair[0]] == s:
                retrieved_minerals.append(mineral_names[i])
        x_minerals_to_plot = retrieved_minerals

        retrieved_minerals = []
        for i,s in enumerate(mineral_formula_ox_singles):
            if [e_pair[1]] == s:
                retrieved_minerals.append(mineral_names[i])
        y_minerals_to_plot = retrieved_minerals

        xy_minerals_to_plot = []
        for i,s in enumerate(mineral_formula_ox_doubles):
            if e_pair[0] in s and e_pair[1] in s:
                xy_minerals_to_plot.append(mineral_names[i])

        if len(x_minerals_to_plot) &gt; 1:
            species(x_minerals_to_plot, add=True)
        if len(y_minerals_to_plot) &gt; 1:
            species(y_minerals_to_plot, add=True)
        if len(xy_minerals_to_plot) &gt; 1:
            species(xy_minerals_to_plot, add=True)

        field_minerals_to_plot = []
        for i,s in enumerate(mineral_formula_ox_triples):
            if e_pair[0] in s and e_pair[1] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
        for i,s in enumerate(mineral_formula_ox_doubles):
            if e_pair[0] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
            elif e_pair[1] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
        for i,s in enumerate(mineral_formula_ox_singles):
            if div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
                
        field_minerals_exist = True
        try:
            # get minerals relevant to plotted element pair
            species(field_minerals_to_plot)#, add=True)
        except:
            field_minerals_exist = False

        xi_vals, x_vals, y_vals = self.__get_reaction_path(basis_species_x, basis_species_y, div_var_name)

        table,fig = self.__plot_reaction_path_background(basis_species_x, basis_species_y, div_var_name, x_vals, y_vals,
                                                         plot_width=plot_width, plot_height=plot_height, ppi=ppi, res=res,
                                                         colormap=colormap, borders=borders,
                                                         field_minerals_exist=field_minerals_exist, path_margin=self.path_margin,
                                                         annotation=&#34;Balanced on: &#34;+chemlabel(self.__get_basis_from_elem(div_var_name)),
                                                         messages=False)

        # plot minerals with a single element of interest as a line
        plot_x_range, plot_y_range = self.__get_plot_range(x_vals, y_vals)
        for mineral in x_minerals_to_plot + y_minerals_to_plot + xy_minerals_to_plot:

            eoi = self.__get_elem_ox_of_interest_in_minerals(mineral)

            logK = self.__calc_dissrxn_logK(mineral, T, P)
            mineral_formula_dict = self.__get_mineral_elem_ox_dict_interest(mineral)

            if len(eoi) == 1:

                # if the element of interest is not in the current element pair, move on
                if eoi[0] not in e_pair:
                    continue

                if self.__get_elem_ox_of_interest_in_minerals(mineral)[0] == e_pair[0]:
                    # vertical line
                    x0, x1 = (-1/mineral_formula_dict[e_pair[0]])*logK, (-1/mineral_formula_dict[e_pair[0]])*logK
                    y0 = min(plot_y_range)
                    y1 = max(plot_y_range)
                    color = v_line_color
                elif self.__get_elem_ox_of_interest_in_minerals(mineral)[0] == e_pair[1]:
                    # horizontal line
                    y0, y1 = (-1/mineral_formula_dict[e_pair[1]])*logK, (-1/mineral_formula_dict[e_pair[1]])*logK
                    x0 = min(plot_x_range)
                    x1 = max(plot_x_range)
                    color=h_line_color

            if len(eoi) == 2:

                line_slope = mineral_formula_dict[e_pair[0]]/mineral_formula_dict[e_pair[1]]

                x0 = min(plot_x_range)
                x1 = max(plot_x_range)
                y0 = (-1/mineral_formula_dict[e_pair[1]])*logK - line_slope*x0
                y1 = (-1/mineral_formula_dict[e_pair[1]])*logK - line_slope*x1
                color = d_line_color

            fig.add_trace(
                go.Scatter(x=[x0, x1], y=[y0, y1], mode=&#34;lines&#34;, name=mineral, line=dict(color=color, width=1, dash=&#39;dot&#39;)),
            )


        fig = self.__add_reaction_path_to_plot(x_vals, y_vals, xi_vals, fig, basis_species_x, basis_species_y, path_margin=self.path_margin)
        return fig

    
    def plot_product_minerals(self, show_reactant_minerals=False,
                              plot_width=4, plot_height=3, ppi=122):
        
        &#34;&#34;&#34;
        Generate a line plot of the log moles of product minerals as a
        function of the log of the extent of reaction (log Xi).
        
        Parameters
        ----------
        show_reactant_minerals : bool, default False
            Include log moles of reactant minerals?
            
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        if show_reactant_minerals:
            df = self.moles_minerals
            title = &#34;Moles of reactant and product minerals&#34;
        else:
            df = self.moles_product_minerals
            title = &#34;Moles of product minerals&#34;

        df = pd.melt(df, id_vars=&#34;Xi&#34;, value_vars=df.columns[1:])
        df.columns = [&#34;log Xi&#34;, &#34;variable&#34;, &#34;value&#34;]
        df = df[df[&#34;variable&#34;] != &#34;None&#34;]


        df[&#34;log Xi&#34;] = pd.to_numeric(df[&#34;log Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;log Xi&#39;])
            df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
            
        
        xlab = &#34;log Xi&#34;
        ylab = &#34;log moles&#34;
        xvar = &#34;log Xi&#34;


        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None)

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        return fig

    
    def plot_aqueous_species(self, plot_basis=False,
                             plot_width=4, plot_height=3, ppi=122):
        
        &#34;&#34;&#34;
        Generate a line plot of the log activities of aqueous species as a
        function of the log of the extent of reaction (log Xi).
        
        Parameters
        ----------
        plot_basis : bool, default False
            Plot basis species only?
            
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        if plot_basis:
            if hasattr(self, &#39;tab&#39;):
                df = self.tab[&#34;Table E2 Basis species(log activity; log fugacity for O2(g))&#34;]
                title = &#34;Solute basis species&#34;
                startcol = 2 # specific to table D1
            else:
                self.err_handler.raise_exception(&#34;Cannot plot basis species because the TAB file &#34;
                    &#34;cannot be processed. This is likely because a thermodynamic database CSV &#34;
                    &#34;was not provided when Mass_Transfer() was called.&#34;)
        else:
            df = self.aq_distribution
            title = &#34;Solute species&#34;
            startcol = 1

        df = pd.melt(df, id_vars=&#34;Xi&#34;, value_vars=df.columns[startcol:])
        df.columns = [&#34;log Xi&#34;, &#34;variable&#34;, &#34;value&#34;]
        df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel)

        df[&#34;log Xi&#34;] = pd.to_numeric(df[&#34;log Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;log Xi&#39;])
#             df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
            
        
        xlab = &#34;log Xi&#34;
        ylab = &#34;log activity&#34;
        xvar = &#34;log Xi&#34;


        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None)

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        return fig

    
    def plot_mass_contribution(self, *args, xi_decimals=3, **kwargs):
        
        &#34;&#34;&#34;
        Generate a bar plot of mass contributions (in mole percent) of aqueous
        species formed by a specified basis species at different extents of
        reaction (Xi).
        
        Parameters
        ----------
        *args : iterable
            Arguments to be passed to `Speciation.plot_mass_contribution`.

        xi_decimals : int
            Number of decimals to display in the scientific notation of the
            extent of reaction, Xi.

        **kargs : dict
            Keyword arguments to be passed to `Speciation.plot_mass_contribution`.
            
        Returns
        -------
        fig : Plotly figure object
            A mass contribution bar plot.
        &#34;&#34;&#34;
        
        basis = args[0]
        
        if &#34;sample_label&#34; not in kwargs.keys():
            kwargs[&#34;sample_label&#34;] = &#34;Xi&#34;

        
        df_sp = self.mine_6o_table(
                        table_start=&#34;Species Accounting for 99% or More of Aqueous &#34;+basis,
                        table_stop=&#34;Subtotal&#34;,
                        ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;, &#39;-&#39;],
                        col_index=-1)
        
        
        df_sp[&#39;Xi&#39;] = df_sp[&#39;Xi&#39;].astype(str)
        df_sp[&#39;Other&#39;] = 100 - df_sp.sum(axis=1, numeric_only=True)
        df_sp[&#39;Xi&#39;] = df_sp[&#39;Xi&#39;].astype(float)
        
        df_sp[df_sp[&#34;Other&#34;] &lt; 0] = 0
        
        df_sp[&#34;basis&#34;] = basis
        df_sp[&#34;factor&#34;] = None
        df_sp[&#34;molality&#34;] = None
        
        df_sp_melt = df_sp.melt(id_vars=[&#34;Xi&#34;, &#34;basis&#34;, &#34;factor&#34;, &#39;molality&#39;])
        df_sp_melt.columns = [&#34;sample&#34;, &#34;basis&#34;, &#39;factor&#39;, &#39;molality&#39;, &#34;species&#34;, &#34;percent&#34;]
        
        df_sp_melt = df_sp_melt[df_sp_melt[&#39;percent&#39;].notna()]
        
        df_sp_melt.sort_values([&#34;sample&#34;, &#34;species&#34;, &#34;percent&#34;],
                               axis = 0, ascending = True,
                               inplace = True)
        
        # handle display of Xi on the x axis
        # if number of decimals to display is too low, columns will stack
        # check to see if this happens, then increment xi_decimals until the stacking problem is solved
        if xi_decimals &lt; 0:
            self.err_handler.raise_exception(&#34;The parameter xi_decimals must be greater than or equal to 0.&#34;)
        original_xi_decimals = copy.copy(xi_decimals)
        if len(set(df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x))) &lt; len(set(df_sp_melt[&#39;sample&#39;])):
            xi_decimals += 1
            solved_decimals = False
            for i in range(xi_decimals, xi_decimals+10):
                if len(set(df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x))) == len(set(df_sp_melt[&#39;sample&#39;])):
                    print(&#34;Number of decimals to display for Xi increased to&#34;, xi_decimals, &#34;to prevent column stacking.&#34;)
                    solved_decimals = True
                    break
                else:
                    xi_decimals += 1
            if not solved_decimals:
                self.err_handler.raise_exception(&#34;Xi decimal formatting is resulting in column stacking even after attempting 10 increments of xi_decimals.&#34;)
        
        df_sp_melt[&#39;sample&#39;] = df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x) # converts Xi to string
        
        sp = Speciation(args={})
        sp.mass_contribution = df_sp_melt
        
        
        if not kwargs.get(&#34;plot_out&#34;, False):
            plot_out = False
        else:
            plot_out = True
        kwargs[&#34;plot_out&#34;] = True
        
        fig = sp.plot_mass_contribution(*args, **kwargs)
        
        fig.update_layout(
            xaxis_title=&#34;Xi&#34;, # add an x axis title
        )
        
        if plot_out:
            return fig
        else:
            fig.show()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="AqEquil.MassTransfer.Mass_Transfer.process_tab"><code class="name flex">
<span>def <span class="ident">process_tab</span></span>(<span>tab_name, thermodata_csv)</span>
</code></dt>
<dd>
<div class="desc"><p>Process a TAB file (from EQ6) into a dictionary of Pandas dataframes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tab_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Path name of the TAB file generated by EQ6.</dd>
<dt><strong><code>thermodata_csv</code></strong> :&ensp;<code>str</code> or <code>Pandas dataframe</code></dt>
<dd>Path name of the WORM-styled thermodynamic database CSV used in the
EQ6 calculation. Alternately, the thermodynamic database itself as a
Pandas dataframe itself.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tab</code></strong> :&ensp;<code>a dict</code> of <code>Pandas dataframes</code></dt>
<dd>A dictionary of dataframes representing tables mined from the TAB
file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def process_tab(tab_name, thermodata_csv):
    
    &#34;&#34;&#34;
    Process a TAB file (from EQ6) into a dictionary of Pandas dataframes.
    
    Parameters
    ----------
    tab_name : str
        Path name of the TAB file generated by EQ6.
    
    thermodata_csv : str or Pandas dataframe
        Path name of the WORM-styled thermodynamic database CSV used in the
        EQ6 calculation. Alternately, the thermodynamic database itself as a
        Pandas dataframe itself.

    Returns
    -------
    tab : a dict of Pandas dataframes
        A dictionary of dataframes representing tables mined from the TAB
        file.
    &#34;&#34;&#34;
    
    if isinstance(thermodata_csv, str):
        thermo_db = pd.read_csv(thermodata_csv)
    else:
        thermo_db = thermodata_csv
    
    
    thermo_db_names = list(thermo_db[&#34;name&#34;])

    with open(tab_name, &#34;r&#34;) as tabfile:
        tab_lines = tabfile.readlines()

    tab = {}

    tables = [&#34;B1&#34;, &#34;B2&#34;, &#34;C1&#34;, &#34;C2&#34;, &#34;C3&#34;, &#34;C4&#34;,
              &#34;D1&#34;, &#34;D2&#34;, &#34;D3&#34;, &#34;D4&#34;, &#34;E1&#34;, &#34;E2&#34;,
              &#34;E3&#34;, &#34;J&#34;, &#34;K&#34;, &#34;P&#34;, &#34;Q&#34;, &#34;T&#34;, &#34;W&#34;]

    record_lines = False
    get_header = False
    recorded_lines = []
    for line in tab_lines:
        split_line = line.split(&#34;,&#34;)

        if True in [s in [&#34;Table &#34; + t for t in tables] for s in split_line]:
            get_header = True
            table_name = &#34; &#34;.join(split_line[1:-1])
            continue

        if get_header:
            header = split_line[1:-1]

            # handle instances where the tab file creates extra columns for things like &#34;albite,low&#34;
            if table_name == &#34;Table P Moles of product minerals&#34; or table_name == &#34;Table Q Saturation indices of potential product phases&#34;:
                if table_name == &#34;Table P Moles of product minerals&#34;:
                    new_header = [&#34;Xi&#34;, &#34;t(days)&#34;] # table P
                else:
                    new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;H2O&#34;, &#34;Gas&#34;] # table Q

                for i,h in enumerate(header):

                    if h != &#34;Xi&#34; and h != &#34;t(days)&#34; and h != &#34;H2O&#34; and h != &#34;Gas&#34;:
                        if h not in thermo_db_names:
                            if header[i-1]+&#34;,&#34;+h in thermo_db_names:
                                new_header = new_header[:-1]
                                new_header.append(header[i-1]+&#34;,&#34;+h)
                            else:
                                new_header.append(h)
                        else:
                            new_header.append(h)

                header = new_header


            record_lines = True
            get_header = False
            continue

        if &#34;EndTable:&#34; in split_line:
            record_lines = False
            if len(recorded_lines) &gt; 0:
                df = pd.DataFrame(recorded_lines)
                recorded_lines = []
                df.columns = header
                tab[table_name] = df

        if record_lines:
            recorded_lines.append(split_line[1:-1])

    return tab</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="AqEquil.MassTransfer.Mass_Transfer.mine_6o_table"><code class="name flex">
<span>def <span class="ident">mine_6o_table</span></span>(<span>self, table_start='--- Distribution of Aqueous Solute Species ---', table_stop='Species with molalities less than', ignore=['', 'Species', '---'], col_index=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Mine a table in a '6o' EQ6 output file and consolidate results into a
dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table_start</code></strong> :&ensp;<code>str</code></dt>
<dd>A unique string that indicates the start of the table.</dd>
<dt><strong><code>table_stop</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A unique string that indicates the end of the table.</dd>
<dt><strong><code>ignore</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of strings representing lines to ignore when mining a table.
For example, it is prudent to ignore blank lines, or lines
containing the table column headers.
A line will be skipped if line.strip().split(' ')[0] matches any
of the strings in the given list.</dd>
<dt><strong><code>col_index</code></strong> :&ensp;<code>int</code>, default <code>-1</code></dt>
<dd>Integer representing the index of the table column to be mined.
The default is -1, which is the last column in the table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>Pandas dataframe</code></dt>
<dd>A dataframe with rows of the extent of reaction (Xi), and columns
containing the values of chemical species mined from the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mine_6o_table(self,
                  table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                  table_stop=&#34;Species with molalities less than&#34;,
                  ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                  col_index=-1):
    
    &#34;&#34;&#34;
    Mine a table in a &#39;6o&#39; EQ6 output file and consolidate results into a
    dataframe.
    
    Parameters
    ----------
    table_start : str
        A unique string that indicates the start of the table.

    table_stop : str, optional
        A unique string that indicates the end of the table.
    
    ignore : list of str
        A list of strings representing lines to ignore when mining a table.
        For example, it is prudent to ignore blank lines, or lines
        containing the table column headers.
        A line will be skipped if line.strip().split(&#39; &#39;)[0] matches any
        of the strings in the given list.
    
    col_index : int, default -1
        Integer representing the index of the table column to be mined.
        The default is -1, which is the last column in the table.
        
    Returns
    -------
    df : Pandas dataframe
        A dataframe with rows of the extent of reaction (Xi), and columns
        containing the values of chemical species mined from the file.
    &#34;&#34;&#34;
    
    f=open(self.six_o_file, mode=&#39;r&#39;)
    lines=f.readlines()
    f.close()

    species = []
    xi_vals=[]
    collect_values = False
    for i in lines:
        if len(i.strip().split(&#39; &#39;)) &gt; 1 and i.strip().split(&#39; &#39;)[0] == &#34;Xi=&#34;:
            xi_vals.append(float(i.split(&#39; &#39;)[-1]))
        if table_stop in i:
            collect_values = False
        if table_start in i:
            collect_values = True
        if collect_values:
            if i.strip().split(&#39; &#39;)[0] not in ignore:
                species.append(i.strip().split(&#39; &#39;)[0])

    species = list(set(species))
    
    species_dict = {&#34;Xi&#34;:xi_vals}
    for s in species:

        vals=[]
        collect_values = False
        for i in lines:
            if collect_values and table_stop in i:
                # stop collecting
                collect_values = False
                if not got_value:
                    vals.append(np.nan)
            if table_start in i:
                # start collecting
                collect_values = True
                got_value = False
            if collect_values:
                if len(i.strip().split(&#39; &#39;)) &gt; 2 and i.strip().split(&#39; &#39;)[0] == s:
                    split_i = i.strip().split(&#39; &#39;)
                    split_i_clean = [v for v in split_i if v != &#39;&#39;]
                    vals.append(float(split_i_clean[col_index]))
                    got_value = True
        species_dict[s] = vals

    df = pd.DataFrame(species_dict)
    
    return df</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_aqueous_species"><code class="name flex">
<span>def <span class="ident">plot_aqueous_species</span></span>(<span>self, plot_basis=False, plot_width=4, plot_height=3, ppi=122)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a line plot of the log activities of aqueous species as a
function of the log of the extent of reaction (log Xi).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_basis</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Plot basis species only?</dd>
<dt><strong><code>plot_width</code></strong>, <strong><code>plot_height</code></strong> :&ensp;<code>numeric</code>, default <code>4 by 3</code></dt>
<dd>Width and height of the plot, in inches. Size of interactive plots
is also determined by pixels per inch, set by the parameter <code>ppi</code>.</dd>
<dt><strong><code>ppi</code></strong> :&ensp;<code>numeric</code>, default <code>122</code></dt>
<dd>Pixels per inch. Along with <code>plot_width</code> and <code>plot_height</code>,
determines the size of interactive plots.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object</code></dt>
<dd>A line plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def plot_aqueous_species(self, plot_basis=False,
                             plot_width=4, plot_height=3, ppi=122):
        
        &#34;&#34;&#34;
        Generate a line plot of the log activities of aqueous species as a
        function of the log of the extent of reaction (log Xi).
        
        Parameters
        ----------
        plot_basis : bool, default False
            Plot basis species only?
            
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        if plot_basis:
            if hasattr(self, &#39;tab&#39;):
                df = self.tab[&#34;Table E2 Basis species(log activity; log fugacity for O2(g))&#34;]
                title = &#34;Solute basis species&#34;
                startcol = 2 # specific to table D1
            else:
                self.err_handler.raise_exception(&#34;Cannot plot basis species because the TAB file &#34;
                    &#34;cannot be processed. This is likely because a thermodynamic database CSV &#34;
                    &#34;was not provided when Mass_Transfer() was called.&#34;)
        else:
            df = self.aq_distribution
            title = &#34;Solute species&#34;
            startcol = 1

        df = pd.melt(df, id_vars=&#34;Xi&#34;, value_vars=df.columns[startcol:])
        df.columns = [&#34;log Xi&#34;, &#34;variable&#34;, &#34;value&#34;]
        df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel)

        df[&#34;log Xi&#34;] = pd.to_numeric(df[&#34;log Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;log Xi&#39;])
#             df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
            
        
        xlab = &#34;log Xi&#34;
        ylab = &#34;log activity&#34;
        xvar = &#34;log Xi&#34;


        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None)

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        return fig</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_mass_contribution"><code class="name flex">
<span>def <span class="ident">plot_mass_contribution</span></span>(<span>self, *args, xi_decimals=3, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a bar plot of mass contributions (in mole percent) of aqueous
species formed by a specified basis species at different extents of
reaction (Xi).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Arguments to be passed to <code>Speciation.plot_mass_contribution</code>.</dd>
<dt><strong><code>xi_decimals</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of decimals to display in the scientific notation of the
extent of reaction, Xi.</dd>
<dt><strong><code>**kargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments to be passed to <code>Speciation.plot_mass_contribution</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object</code></dt>
<dd>A mass contribution bar plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mass_contribution(self, *args, xi_decimals=3, **kwargs):
    
    &#34;&#34;&#34;
    Generate a bar plot of mass contributions (in mole percent) of aqueous
    species formed by a specified basis species at different extents of
    reaction (Xi).
    
    Parameters
    ----------
    *args : iterable
        Arguments to be passed to `Speciation.plot_mass_contribution`.

    xi_decimals : int
        Number of decimals to display in the scientific notation of the
        extent of reaction, Xi.

    **kargs : dict
        Keyword arguments to be passed to `Speciation.plot_mass_contribution`.
        
    Returns
    -------
    fig : Plotly figure object
        A mass contribution bar plot.
    &#34;&#34;&#34;
    
    basis = args[0]
    
    if &#34;sample_label&#34; not in kwargs.keys():
        kwargs[&#34;sample_label&#34;] = &#34;Xi&#34;

    
    df_sp = self.mine_6o_table(
                    table_start=&#34;Species Accounting for 99% or More of Aqueous &#34;+basis,
                    table_stop=&#34;Subtotal&#34;,
                    ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;, &#39;-&#39;],
                    col_index=-1)
    
    
    df_sp[&#39;Xi&#39;] = df_sp[&#39;Xi&#39;].astype(str)
    df_sp[&#39;Other&#39;] = 100 - df_sp.sum(axis=1, numeric_only=True)
    df_sp[&#39;Xi&#39;] = df_sp[&#39;Xi&#39;].astype(float)
    
    df_sp[df_sp[&#34;Other&#34;] &lt; 0] = 0
    
    df_sp[&#34;basis&#34;] = basis
    df_sp[&#34;factor&#34;] = None
    df_sp[&#34;molality&#34;] = None
    
    df_sp_melt = df_sp.melt(id_vars=[&#34;Xi&#34;, &#34;basis&#34;, &#34;factor&#34;, &#39;molality&#39;])
    df_sp_melt.columns = [&#34;sample&#34;, &#34;basis&#34;, &#39;factor&#39;, &#39;molality&#39;, &#34;species&#34;, &#34;percent&#34;]
    
    df_sp_melt = df_sp_melt[df_sp_melt[&#39;percent&#39;].notna()]
    
    df_sp_melt.sort_values([&#34;sample&#34;, &#34;species&#34;, &#34;percent&#34;],
                           axis = 0, ascending = True,
                           inplace = True)
    
    # handle display of Xi on the x axis
    # if number of decimals to display is too low, columns will stack
    # check to see if this happens, then increment xi_decimals until the stacking problem is solved
    if xi_decimals &lt; 0:
        self.err_handler.raise_exception(&#34;The parameter xi_decimals must be greater than or equal to 0.&#34;)
    original_xi_decimals = copy.copy(xi_decimals)
    if len(set(df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x))) &lt; len(set(df_sp_melt[&#39;sample&#39;])):
        xi_decimals += 1
        solved_decimals = False
        for i in range(xi_decimals, xi_decimals+10):
            if len(set(df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x))) == len(set(df_sp_melt[&#39;sample&#39;])):
                print(&#34;Number of decimals to display for Xi increased to&#34;, xi_decimals, &#34;to prevent column stacking.&#34;)
                solved_decimals = True
                break
            else:
                xi_decimals += 1
        if not solved_decimals:
            self.err_handler.raise_exception(&#34;Xi decimal formatting is resulting in column stacking even after attempting 10 increments of xi_decimals.&#34;)
    
    df_sp_melt[&#39;sample&#39;] = df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(xi_decimals)+&#39;e&#39;) % x) # converts Xi to string
    
    sp = Speciation(args={})
    sp.mass_contribution = df_sp_melt
    
    
    if not kwargs.get(&#34;plot_out&#34;, False):
        plot_out = False
    else:
        plot_out = True
    kwargs[&#34;plot_out&#34;] = True
    
    fig = sp.plot_mass_contribution(*args, **kwargs)
    
    fig.update_layout(
        xaxis_title=&#34;Xi&#34;, # add an x axis title
    )
    
    if plot_out:
        return fig
    else:
        fig.show()</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_product_minerals"><code class="name flex">
<span>def <span class="ident">plot_product_minerals</span></span>(<span>self, show_reactant_minerals=False, plot_width=4, plot_height=3, ppi=122)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a line plot of the log moles of product minerals as a
function of the log of the extent of reaction (log Xi).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>show_reactant_minerals</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Include log moles of reactant minerals?</dd>
<dt><strong><code>plot_width</code></strong>, <strong><code>plot_height</code></strong> :&ensp;<code>numeric</code>, default <code>4 by 3</code></dt>
<dd>Width and height of the plot, in inches. Size of interactive plots
is also determined by pixels per inch, set by the parameter <code>ppi</code>.</dd>
<dt><strong><code>ppi</code></strong> :&ensp;<code>numeric</code>, default <code>122</code></dt>
<dd>Pixels per inch. Along with <code>plot_width</code> and <code>plot_height</code>,
determines the size of interactive plots.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object</code></dt>
<dd>A line plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_product_minerals(self, show_reactant_minerals=False,
                          plot_width=4, plot_height=3, ppi=122):
    
    &#34;&#34;&#34;
    Generate a line plot of the log moles of product minerals as a
    function of the log of the extent of reaction (log Xi).
    
    Parameters
    ----------
    show_reactant_minerals : bool, default False
        Include log moles of reactant minerals?
        
    plot_width, plot_height : numeric, default 4 by 3
        Width and height of the plot, in inches. Size of interactive plots
        is also determined by pixels per inch, set by the parameter `ppi`.
        
    ppi : numeric, default 122
        Pixels per inch. Along with `plot_width` and `plot_height`,
        determines the size of interactive plots.
        
    Returns
    -------
    fig : Plotly figure object
        A line plot.
    &#34;&#34;&#34;
    
    if show_reactant_minerals:
        df = self.moles_minerals
        title = &#34;Moles of reactant and product minerals&#34;
    else:
        df = self.moles_product_minerals
        title = &#34;Moles of product minerals&#34;

    df = pd.melt(df, id_vars=&#34;Xi&#34;, value_vars=df.columns[1:])
    df.columns = [&#34;log Xi&#34;, &#34;variable&#34;, &#34;value&#34;]
    df = df[df[&#34;variable&#34;] != &#34;None&#34;]


    df[&#34;log Xi&#34;] = pd.to_numeric(df[&#34;log Xi&#34;])

    df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
    df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
    df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

    with np.errstate(divide=&#39;ignore&#39;):
        df[&#39;log Xi&#39;] = np.log10(df[&#39;log Xi&#39;])
        df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
        
    
    xlab = &#34;log Xi&#34;
    ylab = &#34;log moles&#34;
    xvar = &#34;log Xi&#34;


    fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                          width=plot_width*ppi,  height=plot_height*ppi,
                          labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                         )

    fig.update_layout(xaxis_title=xlab,
                      yaxis_title=ylab,
                      legend_title=None)

    if isinstance(title, str):
        fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

    return fig</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_reaction_paths"><code class="name flex">
<span>def <span class="ident">plot_reaction_paths</span></span>(<span>self, xyb=None, path_margin=0.25, flip_xy=False, h_line_color='red', v_line_color='blue', d_line_color='orange', res=300, plot_width=4, plot_height=3, ppi=122, borders=0, colormap='viridis')</span>
</code></dt>
<dd>
<div class="desc"><p>Create interactive plots of reaction paths in geochemical variable
space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xyb</code></strong> :&ensp;<code>list</code> of <code>three str</code>, default <code>None</code></dt>
<dd>
<p>By default, this function will plot reaction paths in all possible
dimensions.</p>
<p>Optionally, if you want to produce only a specific plot,
you can provide a list containing the basis species to be used for
the x-axis and y-axis, followed by the basis species used for
balance. For example, ["Fe+2", "Fe+3", "Mg+2"] will have the log
activity of Fe+2 on the x-axis, the log activity of Fe+3 on the
y-axis, and will be balanced on Mg+2.</p>
</dd>
<dt><strong><code>path_margin</code></strong> :&ensp;<code>float</code>, default <code>0.25</code></dt>
<dd>Controls the spacing between the reaction path and the plot axes.
Increasing this value increases the spacing.</dd>
<dt><strong><code>flip_xy</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Transpose the plot so the x and y variables switch axes?</dd>
<dt><strong><code>h_line_color</code></strong> :&ensp;<code>str</code>, default <code>"red"</code></dt>
<dd>Color of horizontal lines.</dd>
<dt><strong><code>v_line_color</code></strong> :&ensp;<code>str</code>, default <code>"blue"</code></dt>
<dd>Color of vertical lines.</dd>
<dt><strong><code>d_line_color</code></strong> :&ensp;<code>str</code>, default <code>"orange"</code></dt>
<dd>Color of diagonal lines.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig_list</code></strong> :&ensp;<code>a list</code> of <code>Plotly figure objects</code></dt>
<dd>A list of interactive Plotly figures. If xyb equals None
(the default), then the list will contain figures representing all
combinations of geochemical variables. Optionally, if xyb is
specified, fig_list will only contain the single figure of interest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_reaction_paths(self,
                        xyb=None, path_margin=0.25, flip_xy=False,
                        h_line_color=&#34;red&#34;,
                        v_line_color=&#34;blue&#34;,
                        d_line_color=&#34;orange&#34;,
                        res=300,
                        plot_width=4, plot_height=3, ppi=122,
                        borders=0,
                        colormap=&#34;viridis&#34;):
    
    &#34;&#34;&#34;
    Create interactive plots of reaction paths in geochemical variable
    space.
    
    Parameters
    ----------
    xyb : list of three str, default None
        By default, this function will plot reaction paths in all possible
        dimensions.
        
        Optionally, if you want to produce only a specific plot,
        you can provide a list containing the basis species to be used for
        the x-axis and y-axis, followed by the basis species used for
        balance. For example, [&#34;Fe+2&#34;, &#34;Fe+3&#34;, &#34;Mg+2&#34;] will have the log
        activity of Fe+2 on the x-axis, the log activity of Fe+3 on the
        y-axis, and will be balanced on Mg+2.

    path_margin : float, default 0.25
        Controls the spacing between the reaction path and the plot axes.
        Increasing this value increases the spacing.
    
    flip_xy : bool, default False
        Transpose the plot so the x and y variables switch axes?
    
    h_line_color : str, default &#34;red&#34;
        Color of horizontal lines.
    
    v_line_color : str, default &#34;blue&#34;
        Color of vertical lines.
    
    d_line_color : str, default &#34;orange&#34;
        Color of diagonal lines.
        
    Returns
    -------
    fig_list : a list of Plotly figure objects
        A list of interactive Plotly figures. If xyb equals None
        (the default), then the list will contain figures representing all
        combinations of geochemical variables. Optionally, if xyb is
        specified, fig_list will only contain the single figure of interest.
    &#34;&#34;&#34;
    
    error_messages = []
    
    # check that there is only one temperature and pressure
    if not self.__is_all_same_value(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Temp(C)&#34;]):
        error_messages.append(&#34;Reaction paths cannot be plotted when temperature changes with reaction progress.&#34;)
    if not self.__is_all_same_value(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Press(bars)&#34;]):
        error_messages.append(&#34;Reaction paths cannot be plotted when pressure changes with reaction progress.&#34;)
    
    if len(error_messages)&gt;0:
        self.err_handler.raise_exception(error_messages)
    
    self.T = float(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Temp(C)&#34;][0])
    self.P = float(self.tab[&#34;Table B1 Miscellaneous parameters I&#34;][&#34;Press(bars)&#34;][0])
    self.path_margin = path_margin
    
    minerals_formed = list(self.tab[&#34;Table P Moles of product minerals&#34;].columns[2:])

    all_elements_of_interest = []
    for mineral in minerals_formed:
        all_elements_of_interest += self.__get_elem_ox_of_interest_in_minerals(mineral)
    all_elements_of_interest = list(set(all_elements_of_interest))
    
    self.all_elements_of_interest = all_elements_of_interest
    
    # get a list of elem pairs for plotting
    alist = self.all_elements_of_interest
    element_plot_pairs = []
    for result in itertools.combinations(alist, 2):
        element_plot_pairs.append(list(result))

    if xyb == None:
        element_plot_triad = []
        for pair in element_plot_pairs:
            elem_not_in_pair = [e for e in self.all_elements_of_interest if e not in pair]
            for e in elem_not_in_pair:
                triad_to_append = pair + [e]
                element_plot_triad.append(triad_to_append)
    else:
        element_plot_triad = [[self.__get_elem_ox_of_interest_in_minerals(v)[0] for v in xyb]]
    
    if colormap == &#34;bw&#34;:
        if borders == 0:
            borders = 1
        colormap = &#34;none&#34;
        h_line_color = &#34;black&#34;
        v_line_color = &#34;black&#34;
        d_line_color = &#34;black&#34;
    
    fig_list = []
    for triad in element_plot_triad:
        fig = self.__plot_reaction_path_main(
                        triad, T=self.T, P=self.P,
                        path_margin=self.path_margin,
                        flip_xy=flip_xy,
                        h_line_color=h_line_color,
                        v_line_color=v_line_color,
                        d_line_color=d_line_color,
                        res=res,
                        plot_width=plot_width,
                        plot_height=plot_height,
                        ppi=ppi,
                        colormap=colormap,
                        borders=borders)
        
        fig_list.append(fig)
    
    return fig_list</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.print_tabs"><code class="name flex">
<span>def <span class="ident">print_tabs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the names of tables contained in a tab file processed by the
the Mass_Transfer class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_tabs(self):
    &#34;&#34;&#34;
    Print the names of tables contained in a tab file processed by the
    the Mass_Transfer class.
    &#34;&#34;&#34;
    [print(key) for key in self.tab.keys()]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="AqEquil.MassTransfer.Prepare_Reaction"><code class="flex name class">
<span>class <span class="ident">Prepare_Reaction</span></span>
<span>(</span><span>reactants, gases=[], t_option=0, t_value_1=None, t_value_2=0, t_value_3=0, p_option=0, p_value_1=None, p_value_2=0, xi_range=[0, 1], time_range=[0, 1e+38], pH_range=[-1e+38, 1e+38], Eh_range=[-1e+38, 1e+38], fO2_range=[-1e+38, 1e+38], aw_range=[-1e+38, 1e+38], max_n_steps=900, xi_print_int=1, log_xi_print_int=1, time_print_int=1e+38, log_time_print_int=1e+38, pH_print_interval=1e+38, Eh_print_interval=1e+38, logfO2_print_interval=1e+38, aw_print_interval=1e+38, n_steps_print_interval=100, max_finite_difference_order=6, beta_convergence_tolerance=0, del_convergence_tolerance=0, max_n_NR_iter=500, search_find_convergeance_tolerance=0, saturation_tolerance=0, max_n_phase_assemblage_tries=0, zero_order_step_size=0, max_interval_in_xi_between_PRS_transfers=0, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Prepare_Reaction:
    def __init__(self,
                 reactants,
                 gases=[],
                 t_option=0,
                 t_value_1=None, # temp
                 t_value_2=0,  # temp or deriv
                 t_value_3=0,  # mass ratio factor
                 p_option=0,
                 p_value_1=None,  # pressure
                 p_value_2=0,  # deriv
                 xi_range=[0, 1],
                 time_range=[0, 1e38],
                 pH_range=[-1e38, 1e38],
                 Eh_range=[-1e38, 1e38],
                 fO2_range=[-1e38, 1e38],
                 aw_range=[-1e38, 1e38],
                 max_n_steps=900,
                 xi_print_int=1,
                 log_xi_print_int=1,
                 time_print_int=1e38,
                 log_time_print_int=1e38,
                 pH_print_interval=1e38,
                 Eh_print_interval=1e38,
                 logfO2_print_interval=1e38,
                 aw_print_interval=1e38,
                 n_steps_print_interval=100,
                 max_finite_difference_order=6,
                 beta_convergence_tolerance=0,
                 del_convergence_tolerance=0,
                 max_n_NR_iter=500,
                 search_find_convergeance_tolerance=0,
                 saturation_tolerance=0,
                 max_n_phase_assemblage_tries=0,
                 zero_order_step_size=0,
                 max_interval_in_xi_between_PRS_transfers=0,
                 filename=None,
                ):
        
        if len(reactants) == 1 and not isinstance(reactants, list):
            reactants = list(reactants)
            
        if len(gases) == 0:
            gases = [Gas()]
        elif len(gases) == 1 and not isinstance(gases, list):
            gases = list(gases)
        
        self.reactants=reactants
        self.gases=gases
        self.t_option=t_option
        self.t_value_1=t_value_1
        self.t_value_2=t_value_2
        self.t_value_3=t_value_3
        self.p_option=p_option
        self.p_value_1=p_value_1
        self.p_value_2=p_value_2
        self.start_xi=xi_range[0]
        self.max_xi=xi_range[1]
        self.start_time=time_range[0]
        self.max_time=time_range[1]
        self.min_pH=pH_range[0]
        self.max_pH=pH_range[1]
        self.min_Eh=Eh_range[0]
        self.max_Eh=Eh_range[1]
        self.min_fO2=fO2_range[0]
        self.max_fO2=fO2_range[1]
        self.min_aw=aw_range[0]
        self.max_aw=aw_range[1]
        self.max_n_steps=max_n_steps
        self.xi_print_int=xi_print_int
        self.log_xi_print_int=log_xi_print_int
        self.time_print_int=time_print_int
        self.log_time_print_int=log_time_print_int
        self.pH_print_interval=pH_print_interval
        self.Eh_print_interval=Eh_print_interval
        self.logfO2_print_interval=logfO2_print_interval
        self.aw_print_interval=aw_print_interval
        self.n_steps_print_interval=n_steps_print_interval
        self.max_finite_difference_order=max_finite_difference_order
        self.beta_convergence_tolerance=beta_convergence_tolerance
        self.del_convergence_tolerance=del_convergence_tolerance
        self.max_n_NR_iter=max_n_NR_iter
        self.search_find_convergeance_tolerance=search_find_convergeance_tolerance
        self.saturation_tolerance=saturation_tolerance
        self.max_n_phase_assemblage_tries=max_n_phase_assemblage_tries
        self.zero_order_step_size=zero_order_step_size
        self.max_interval_in_xi_between_PRS_transfers=max_interval_in_xi_between_PRS_transfers
        
        self.t_checkbox_1=&#34; &#34;
        self.t_checkbox_2=&#34; &#34;
        self.t_checkbox_3=&#34; &#34;
        self.t_checkbox_4=&#34; &#34;
        self.tval1=0
        self.tval2=0
        self.tval3=0
        self.tval4=0
        self.tval5=0
        self.tval6=0
        self.tval7=0
        self.tval8=0
        self.p_checkbox_1=&#34; &#34;
        self.p_checkbox_2=&#34; &#34;
        self.p_checkbox_3=&#34; &#34;
        self.p_checkbox_4=&#34; &#34;
        self.p_checkbox_5=&#34; &#34;
        self.pval1=0
        self.pval2=0
        self.pval3=0
        self.pval4=0
        self.pval5=0
        self.i1_checkbox_1 = &#34; &#34;
        self.i1_checkbox_2 = &#34; &#34;
        self.i1_checkbox_3 = &#34; &#34;
        self.i2_checkbox_1 = &#34; &#34;
        self.i2_checkbox_2 = &#34; &#34;
        self.i3_checkbox_1 = &#34; &#34;
        self.i3_checkbox_2 = &#34; &#34;
        self.i3_checkbox_3 = &#34; &#34;
        self.i4_checkbox_1 = &#34; &#34;
        self.i4_checkbox_2 = &#34; &#34;
        self.i5_checkbox_1 = &#34; &#34;
        self.i5_checkbox_2 = &#34; &#34;
        self.i6_checkbox_1 = &#34; &#34;
        self.i6_checkbox_2 = &#34; &#34;
        self.i7_checkbox_1 = &#34; &#34;
        self.i7_checkbox_2 = &#34; &#34;
        self.i9_checkbox_1 = &#34; &#34;
        self.i9_checkbox_2 = &#34; &#34;
        self.i10_checkbox_1 = &#34; &#34;
        self.i10_checkbox_2 = &#34; &#34;
        self.i11_checkbox_1 = &#34; &#34;
        self.i11_checkbox_2 = &#34; &#34;
        self.i12_checkbox_1 = &#34; &#34;
        self.i12_checkbox_2 = &#34; &#34;
        self.i13_checkbox_1 = &#34; &#34;
        self.i13_checkbox_2 = &#34; &#34;
        self.i13_checkbox_3 = &#34; &#34;
        self.i14_checkbox_1 = &#34; &#34;
        self.i14_checkbox_2 = &#34; &#34;
        self.i14_checkbox_3 = &#34; &#34;
        self.i14_checkbox_4 = &#34; &#34;
        self.i20_checkbox_1 = &#34; &#34;
        self.i20_checkbox_2 = &#34; &#34;
        
        
        tval_var_to_format = None
        pval_var_to_format = None
        
        if t_option == 0:
            self.t_checkbox_1=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval1=t_value_1
            else:
                tval_var_to_format = 1

        elif t_option == 1:
            self.t_checkbox_2=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval2=t_value_1
                self.tval3=t_value_2
            else:
                tval_var_to_format = 2

        elif t_option == 2:
            self.t_checkbox_3=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval4=t_value_1
                self.tval5=t_value_2
            else:
                tval_var_to_format = 4
                
        elif t_option == 3:
            self.t_checkbox_4=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval6=t_value_1
                self.tval7=t_value_2
                self.tval8=t_value_3
            else:
                tval_var_to_format = 6
        else:
            raise Exception(&#34;t_option must be 0, 1, 2, or 3.&#34;)
            
        if p_option == 0:
            self.p_checkbox_1=&#34;x&#34;

        elif p_option == 1:
            self.p_checkbox_2=&#34;x&#34;

        elif p_option == 2:
            self.p_checkbox_3=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval1=p_value_1
            else:
                pval_var_to_format = 1
                
        elif p_option == 3:
            self.p_checkbox_4=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval2=p_value_1
                self.pval3=p_value_2
            else:
                pval_var_to_format = 2
                
        elif p_option == 4:
            self.p_checkbox_5=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval4=p_value_1
                self.pval5=p_value_2
            else:
                pval_var_to_format = 4

        else:
            raise Exception(&#34;p_option must be 0, 1, 2, 3, or 4.&#34;)
        
        now = datetime.now()
        self.date_created = now.strftime(&#39;%Y-%m-%d %I:%M %p&#39;)
        
        self.__format_reaction(tval_var_to_format, pval_var_to_format)
        
        if filename != None:
            with open(filename, &#39;w&#39;) as f:
                f.write(pr.formatted_reaction)
        
        
    def __format_reaction(self, tval_var_to_format=None, pval_var_to_format=None):
        reaction_options_formatted = dict(
            date_created=f&#34;{self.date_created:&lt;24}&#34;,
            start_xi=f&#34;{&#39;{:.5E}&#39;.format(self.start_xi):&gt;12}&#34;,
            max_xi=f&#34;{&#39;{:.5E}&#39;.format(self.max_xi):&gt;12}&#34;,
            start_time=f&#34;{&#39;{:.5E}&#39;.format(self.start_time):&gt;12}&#34;,
            max_time=f&#34;{&#39;{:.5E}&#39;.format(self.max_time):&gt;12}&#34;,
            min_pH=f&#34;{&#39;{:.5E}&#39;.format(self.min_pH):&gt;12}&#34;,
            max_pH=f&#34;{&#39;{:.5E}&#39;.format(self.max_pH):&gt;12}&#34;,
            min_Eh=f&#34;{&#39;{:.5E}&#39;.format(self.min_Eh):&gt;12}&#34;,
            max_Eh=f&#34;{&#39;{:.5E}&#39;.format(self.max_Eh):&gt;12}&#34;,
            min_fO2=f&#34;{&#39;{:.5E}&#39;.format(self.min_fO2):&gt;12}&#34;,
            max_fO2=f&#34;{&#39;{:.5E}&#39;.format(self.max_fO2):&gt;12}&#34;,
            min_aw=f&#34;{&#39;{:.5E}&#39;.format(self.min_aw):&gt;12}&#34;,
            max_aw=f&#34;{&#39;{:.5E}&#39;.format(self.max_aw):&gt;12}&#34;,
            max_n_steps=f&#34;{self.max_n_steps:&gt;12}&#34;,
            xi_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.xi_print_int):&gt;12}&#34;,
            log_xi_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.log_xi_print_int):&gt;12}&#34;,
            time_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.time_print_int):&gt;12}&#34;,
            log_time_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.log_time_print_int):&gt;12}&#34;,
            pH_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.pH_print_interval):&gt;12}&#34;,
            Eh_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.Eh_print_interval):&gt;12}&#34;,
            logfO2_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.logfO2_print_interval):&gt;12}&#34;,
            aw_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.aw_print_interval):&gt;12}&#34;,
            n_steps_print_interval=f&#34;{self.n_steps_print_interval:&gt;12}&#34;,
            max_finite_difference_order=f&#34;{self.max_finite_difference_order:&gt;12}&#34;,
            beta_convergence_tolerance=f&#34;{self.beta_convergence_tolerance:&gt;12}&#34;,
            del_convergence_tolerance=f&#34;{self.del_convergence_tolerance:&gt;12}&#34;,
            max_n_NR_iter=f&#34;{self.max_n_NR_iter:&gt;12}&#34;,
            search_find_convergeance_tolerance=f&#34;{self.search_find_convergeance_tolerance:&gt;12}&#34;,
            saturation_tolerance=f&#34;{self.saturation_tolerance:&gt;12}&#34;,
            max_n_phase_assemblage_tries=f&#34;{self.max_n_phase_assemblage_tries:&gt;12}&#34;,
            zero_order_step_size=f&#34;{self.zero_order_step_size:&gt;12}&#34;,
            max_interval_in_xi_between_PRS_transfers=f&#34;{self.max_interval_in_xi_between_PRS_transfers:&gt;12}&#34;,
            t_checkbox_1=self.t_checkbox_1,
            t_checkbox_2=self.t_checkbox_2,
            t_checkbox_3=self.t_checkbox_3,
            t_checkbox_4=self.t_checkbox_4,
            p_checkbox_1=self.p_checkbox_1,
            p_checkbox_2=self.p_checkbox_2,
            p_checkbox_3=self.p_checkbox_3,
            p_checkbox_4=self.p_checkbox_4,
            p_checkbox_5=self.p_checkbox_5,
            i1_checkbox_1=self.i1_checkbox_1,
            i1_checkbox_2=self.i1_checkbox_2,
            i1_checkbox_3=self.i1_checkbox_3,
            i2_checkbox_1=self.i2_checkbox_1,
            i2_checkbox_2=self.i2_checkbox_2,
            i3_checkbox_1=self.i3_checkbox_1,
            i3_checkbox_2=self.i3_checkbox_2,
            i3_checkbox_3=self.i3_checkbox_3,
            i4_checkbox_1=self.i4_checkbox_1,
            i4_checkbox_2=self.i4_checkbox_2,
            i5_checkbox_1=self.i5_checkbox_1,
            i5_checkbox_2=self.i5_checkbox_2,
            i6_checkbox_1=self.i6_checkbox_1,
            i6_checkbox_2=self.i6_checkbox_2,
            i7_checkbox_1=self.i7_checkbox_1,
            i7_checkbox_2=self.i7_checkbox_2,
            i9_checkbox_1=self.i9_checkbox_1,
            i9_checkbox_2=self.i9_checkbox_2,
            i10_checkbox_1=self.i10_checkbox_1,
            i10_checkbox_2=self.i10_checkbox_2,
            i11_checkbox_1=self.i11_checkbox_1,
            i11_checkbox_2=self.i11_checkbox_2,
            i12_checkbox_1=self.i12_checkbox_1,
            i12_checkbox_2=self.i12_checkbox_2,
            i13_checkbox_1=self.i13_checkbox_1,
            i13_checkbox_2=self.i13_checkbox_2,
            i13_checkbox_3=self.i13_checkbox_3,
            i14_checkbox_1=self.i14_checkbox_1,
            i14_checkbox_2=self.i14_checkbox_2,
            i14_checkbox_3=self.i14_checkbox_3,
            i14_checkbox_4=self.i14_checkbox_4,
            i20_checkbox_1=self.i20_checkbox_1,
            i20_checkbox_2=self.i20_checkbox_2,
        )
        
        # leave {tval1} (or {tval2}, {tval3}...) in pre_6i file so it can be updated after joining 3p
        if tval_var_to_format != None:
            reaction_options_formatted[&#34;tval&#34;+str(tval_var_to_format)] = &#34;{tval}&#34;
            for i in range(1, 9):
                if i == tval_var_to_format:
                    continue
                else:
                    reaction_options_formatted[&#34;tval&#34;+str(i)]=f&#34;{&#39;{:.5E}&#39;.format(getattr(self, &#39;tval&#39;+str(i))):&gt;12}&#34;
        else:
            reaction_options_formatted.update(dict(
                tval1=f&#34;{&#39;{:.5E}&#39;.format(self.tval1):&gt;12}&#34;,
                tval2=f&#34;{&#39;{:.5E}&#39;.format(self.tval2):&gt;12}&#34;,
                tval3=f&#34;{&#39;{:.5E}&#39;.format(self.tval3):&gt;12}&#34;,
                tval4=f&#34;{&#39;{:.5E}&#39;.format(self.tval4):&gt;12}&#34;,
                tval5=f&#34;{&#39;{:.5E}&#39;.format(self.tval5):&gt;12}&#34;,
                tval6=f&#34;{&#39;{:.5E}&#39;.format(self.tval6):&gt;12}&#34;,
                tval7=f&#34;{&#39;{:.5E}&#39;.format(self.tval7):&gt;12}&#34;,
                tval8=f&#34;{&#39;{:.5E}&#39;.format(self.tval8):&gt;12}&#34;,
            ))
            
        # leave {pval1} (or {pval2}, {pval3}...) in pre_6i file so it can be updated after joining 3p
        if pval_var_to_format != None:
            reaction_options_formatted[&#34;pval&#34;+str(pval_var_to_format)] = &#34;{pval}&#34;
            for i in range(1, 6):
                if i == pval_var_to_format:
                    continue
                else:
                    reaction_options_formatted[&#34;pval&#34;+str(i)]=f&#34;{&#39;{:.5E}&#39;.format(getattr(self, &#39;pval&#39;+str(i))):&gt;12}&#34;
        else:
            reaction_options_formatted.update(dict(
                pval1=f&#34;{&#39;{:.5E}&#39;.format(self.pval1):&gt;12}&#34;,
                pval2=f&#34;{&#39;{:.5E}&#39;.format(self.pval2):&gt;12}&#34;,
                pval3=f&#34;{&#39;{:.5E}&#39;.format(self.pval3):&gt;12}&#34;,
                pval4=f&#34;{&#39;{:.5E}&#39;.format(self.pval4):&gt;12}&#34;,
                pval5=f&#34;{&#39;{:.5E}&#39;.format(self.pval5):&gt;12}&#34;,
            ))

        
        reactant_blocks = &#34;&#34;.join([r.formatted_block for r in self.reactants])
        gas_lines = &#34;&#34;.join([r.formatted_line for r in self.gases])
        reaction_options_formatted.update(dict(reactant_blocks=reactant_blocks))
        reaction_options_formatted.update(dict(gas_lines=gas_lines))
        
        reaction_template = copy.copy(template)
        self.formatted_reaction = reaction_template.format(**reaction_options_formatted)</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Reactant"><code class="flex name class">
<span>class <span class="ident">Reactant</span></span>
<span>(</span><span>reactant_name, reactant_type='Pure mineral', reactant_status='Reacting', amount_remaining=1, amount_destroyed=0, surface_area_option=1, surface_area_value=0, surface_area_factor=0, f_rate_law='Relative rate equation', rkb_1=1, rkb_2=0, rkb_3=0, b_rate_law='Partial equilibrium')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reactant:
    def __init__(self,
                 reactant_name,
                 reactant_type=&#34;Pure mineral&#34;,
                 reactant_status=&#34;Reacting&#34;,
                 amount_remaining=1,
                 amount_destroyed=0,
                 surface_area_option=1,
                 surface_area_value=0,
                 surface_area_factor=0,
                 f_rate_law=&#34;Relative rate equation&#34;,
                 rkb_1=1,
                 rkb_2=0,
                 rkb_3=0,
                 b_rate_law=&#34;Partial equilibrium&#34;,
                 ):
        
        self.reactant_name=reactant_name
        self.reactant_type=reactant_type
        self.reactant_status=reactant_status
        self.amount_remaining=amount_remaining
        self.amount_destroyed=amount_destroyed
        self.sa_val_1=0
        self.sa_val_2=0
        self.sa_val_3=0
        self.sa_checkbox_1= &#34; &#34;
        self.sa_checkbox_2= &#34; &#34;
        self.sa_checkbox_3= &#34; &#34;
        
        if surface_area_option == 1:
            self.sa_checkbox_1 = &#34;x&#34;
            self.sa_val_1 = surface_area_value
        elif surface_area_option == 2:
            self.sa_checkbox_2 = &#34;x&#34;
            self.sa_val_2 = surface_area_value
        elif surface_area_option == 3:
            self.sa_checkbox_3 = &#34;x&#34;
            self.sa_val_3 = surface_area_value
        self.sa_factor=surface_area_factor
        
        self.f_rate_law=f_rate_law
        self.rkb_1=rkb_1
        self.rkb_2=rkb_2
        self.rkb_3=rkb_3
        self.b_rate_law=b_rate_law
        
        self.__format_block()


    def __format_block(self):
        
        rb_dict_formatted = dict(
            reactant_name = f&#34;{self.reactant_name:&lt;24}&#34;,
            reactant_type = f&#34;{self.reactant_type:&lt;24}&#34;,
            reactant_status = f&#34;{self.reactant_status:&lt;24}&#34;,
            amount_remaining = f&#34;{&#39;{:.5E}&#39;.format(self.amount_remaining):&gt;12}&#34;,
            amount_destroyed = f&#34;{&#39;{:.5E}&#39;.format(self.amount_destroyed):&gt;12}&#34;,
            sa_checkbox_1 = self.sa_checkbox_1,
            sa_checkbox_2 = self.sa_checkbox_2,
            sa_checkbox_3 = self.sa_checkbox_3,
            sa_val_1 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_1):&gt;12}&#34;,
            sa_val_2 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_2):&gt;12}&#34;,
            sa_val_3 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_3):&gt;12}&#34;,
            sa_factor = f&#34;{&#39;{:.5E}&#39;.format(self.sa_factor):&gt;12}&#34;,
            f_rate_law = f&#34;{self.f_rate_law:&lt;24}&#34;,
            rkb_1 = f&#34;{&#39;{:.5E}&#39;.format(self.rkb_1):&gt;12}&#34;,
            rkb_2 = f&#34;{&#39;{:.5E}&#39;.format(self.rkb_2):&gt;12}&#34;,
            rkb_3 = f&#34;{&#39;{:.5E}&#39;.format(self.rkb_3):&gt;12}&#34;,
            b_rate_law = f&#34;{self.b_rate_law:&lt;24}&#34;,
        )
    
        reactant_block_template = copy.copy(rb_template)
        self.formatted_block = reactant_block_template.format(**rb_dict_formatted)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AqEquil" href="index.html">AqEquil</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="AqEquil.MassTransfer.react" href="#AqEquil.MassTransfer.react">react</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AqEquil.MassTransfer.Gas" href="#AqEquil.MassTransfer.Gas">Gas</a></code></h4>
</li>
<li>
<h4><code><a title="AqEquil.MassTransfer.Mass_Transfer" href="#AqEquil.MassTransfer.Mass_Transfer">Mass_Transfer</a></code></h4>
<ul class="">
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.mine_6o_table" href="#AqEquil.MassTransfer.Mass_Transfer.mine_6o_table">mine_6o_table</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_aqueous_species" href="#AqEquil.MassTransfer.Mass_Transfer.plot_aqueous_species">plot_aqueous_species</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_mass_contribution" href="#AqEquil.MassTransfer.Mass_Transfer.plot_mass_contribution">plot_mass_contribution</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_product_minerals" href="#AqEquil.MassTransfer.Mass_Transfer.plot_product_minerals">plot_product_minerals</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_reaction_paths" href="#AqEquil.MassTransfer.Mass_Transfer.plot_reaction_paths">plot_reaction_paths</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.print_tabs" href="#AqEquil.MassTransfer.Mass_Transfer.print_tabs">print_tabs</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.process_tab" href="#AqEquil.MassTransfer.Mass_Transfer.process_tab">process_tab</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AqEquil.MassTransfer.Prepare_Reaction" href="#AqEquil.MassTransfer.Prepare_Reaction">Prepare_Reaction</a></code></h4>
</li>
<li>
<h4><code><a title="AqEquil.MassTransfer.Reactant" href="#AqEquil.MassTransfer.Reactant">Reactant</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>