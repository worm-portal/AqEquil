<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>AqEquil.MassTransfer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AqEquil.MassTransfer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
import pyCHNOSZ
from chemparse import parse_formula
import copy
import os
import shutil
from math import log10, isnan
import itertools
from operator import itemgetter
import re
import collections
from datetime import datetime
import numbers
import roman
from natsort import natsorted
from .AqSpeciation import Error_Handler, Speciation, AqEquil, chemlabel, check_balance, format_equation

FIXED_SPECIES = [&#34;H2O&#34;, &#34;H+&#34;, &#34;O2(g)&#34;, &#34;water&#34;, &#34;Cl-&#34;, &#34;e-&#34;, &#34;OH-&#34;, &#34;O2&#34;, &#34;H2O(g)&#34;]


def _format_pseudoelement_name(e):
    
    &#34;&#34;&#34;
    Format a pseudoelement name
    E.g., &#34;Fejiip&#34; -&gt; &#34;Fe+2&#34;
    &#34;&#34;&#34;
    
    if len(e) &gt; 2:
        e_split_list = e.split(&#34;j&#34;)
        
        if e_split_list[1][-1] == &#34;p&#34;:
            charge_sign = &#34;+&#34;
        elif e_split_list[1][-1] == &#34;n&#34;:
            charge_sign = &#34;-&#34;
        elif e_split_list[1][-1] == &#34;z&#34;:
            charge_sign = &#34;&#34;
        else:
            print(&#34;ERROR in format_pseudoelement_name(): charge sign is not recognized&#34;)
        
        if charge_sign != &#34;&#34;:
            charge_magnitude_roman = e_split_list[1][:-1].upper()
            charge_magnitude=roman.fromRoman(charge_magnitude_roman)
        else:
            charge_magnitude = 0
        
        formatted_elem_name = &#34;&#34;.join([e_split_list[0], charge_sign,
                                       str(charge_magnitude)])
    else:
        formatted_elem_name = e
        
    return formatted_elem_name

        
def _get_ion_ratio_exponent(num, denom):

    num_formula = parse_formula(num)
    num_plus = num_formula.get(&#34;+&#34;, 0)
    num_minus = num_formula.get(&#34;-&#34;, 0)
    num_total_charge = num_plus - num_minus

    denom_formula = parse_formula(denom)
    denom_plus = denom_formula.get(&#34;+&#34;, 0)
    denom_minus = denom_formula.get(&#34;-&#34;, 0)
    denom_total_charge = denom_plus - denom_minus

    if num_total_charge == 0 or denom_total_charge == 0:
        return 0
    
    return num_total_charge/denom_total_charge


def __delete_file(file):
    if os.path.exists(file) and os.path.isfile(file):
        os.remove(file)

def __delete_dir(d):
    if os.path.exists(d) and os.path.isdir(d):
        shutil.rmtree(d)

def __move_file(file, destination_dir, silent=False):
    try:
        shutil.move(file, destination_dir+&#39;/&#39;+file)
    except:
        if not silent:
            print(&#34;Could not move&#34;, file, &#34;to&#34;, destination_dir)

        
def react(speciation,
          reaction_setup,
          chain_mt=False,
          delete_generated_folders=False,
          hide_traceback=True,
          data1_override=None,
          eq36da=os.environ.get(&#39;EQ36DA&#39;),
          eq36co=os.environ.get(&#39;EQ36CO&#39;),
          verbose=1,
         ):
    
    &#34;&#34;&#34;
    Calculate how speciated water reacts with minerals and/or gases.
    
    Parameters
    ----------
    speciation : Speciation object
        The output of a speciation calculation produced by the
        AqEquil.speciate function.
    
    reaction_setup : str or Prepare_Reaction object
        Defines how the reaction is to be set up. There are two ways to set up
        a reaction. The first way is to prepare the reaction with
        `Prepare_Reaction`. The second way is to prepare the first half of an
        EQ6 6i file (the part without the contents of the pickup file) and then
        pass the filename to `reaction_setup`.
    
    chain_mt : bool, default False
        Is the speciation the result of another mass transfer calculation?
        Choosing True will allow mass transfer calculations to be chained
        together.
    
    delete_generated_folders : bool, default False
        Delete the &#39;rxn_6i&#39;, &#39;rxn_6o&#39;, &#39;rxn_6p&#39;, and &#39;eq6_extra_out&#39; folders
        containing raw EQ6 input, output, and pickup files once the
        reaction calculation is complete?

    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this class?
        When True, error messages handled by this class will be short and to
        the point.

    data1_override : str, optional
        The three letter code of a data1 file used to override the thermodynamic
        database used to speciate the sample(s). This is useful for chaining
        the results of one mass transfer calculation into another while
        simultaneously changing the temperature and pressure regime of the
        new system. See the description for the `chain_mt` parameter for more
        about chaining.
    
    eq36da=os.environ.get(&#39;EQ36DA&#39;),
    eq36co=os.environ.get(&#39;EQ36CO&#39;),

    Returns
    ----------
    An object of class `Speciation` modified with the results of the reaction
    (if a thermodynamic database formatted as a WORM-style CSV was used during
    speciation) or an unmodified speciation object (if a data0 or data1 file
    was used during speciation).
    &#34;&#34;&#34;
    
    prev_wd = os.getcwd()
    ae = AqEquil(load_thermo=False, eq36co=eq36co, eq36da=eq36da, verbose=verbose)
    
    speciation.join_6i_p(reaction_setup, chain_mt)
    __delete_file(&#34;data1.dyn&#34;)
    
    paths=[&#39;rxn_6o&#39;, &#39;rxn_6p&#39;, &#39;eq6_extra_out&#39;]
    for path in paths:
        if not os.path.exists(path):
            os.makedirs(path)
        else:
            shutil.rmtree(path)
            os.makedirs(path)
            
    for sample_name in list(speciation.sample_data.keys()):
        filename_6i = speciation.sample_data[sample_name][&#34;filename&#34;][:-3]+&#34;.6i&#34;
        filename_6o = filename_6i[:-3]+&#34;.6o&#34;
        filename_6p = filename_6i[:-3]+&#34;.6p&#34;
        
        if data1_override != None:
            with open(&#34;data1.&#34;+data1_override, mode=&#39;rb&#39;) as data1:
                speciation.data1[&#34;all_samples&#34;] = data1.read()
            speciation.thermo.thermo_db_filename = &#34;data1.&#34;+data1_override
            
        if &#34;all_samples&#34; not in speciation.data1.keys():
            # each sample has a unique data1. e.g., with dynamic_db
            __delete_file(&#34;eq6_extra_out/data1.dyn&#34;)
            with open(&#34;eq6_extra_out/data1.dyn&#34;, &#39;wb&#39;) as f:
                f.write(speciation.data1[speciation.sample_data[sample_name][&#34;filename&#34;][:-3]])

        else:
            # all samples use the same data1.
            with open(&#34;eq6_extra_out/data1.dyn&#34;, &#39;wb&#39;) as f:
                f.write(speciation.data1[&#34;all_samples&#34;])
        
        path_6i=&#34;rxn_6i/&#34;
        path_6o=&#34;rxn_6o&#34;
        path_6p=&#34;rxn_6p&#34;
        path_extra_out=&#34;eq6_extra_out&#34;
        
        ae.runeq6(filename_6i,
                  db=&#34;dyn&#34;,
                  path_6i=path_6i,
                  data1_path=os.getcwd()+&#34;/eq6_extra_out&#34;, # ensuring data1 is read from a folder without spaces overcomes the problem where environment variables with spaces do not work properly when assigned to EQ36DA
                  dynamic_db_name=speciation.thermo.thermo_db_filename)

        # get current working dir
        cwd = os.getcwd()
        cwdd = cwd + &#34;/&#34;
        
        filename_6o = filename_6i[:-1] + &#39;o&#39;
        filename_6p = filename_6i[:-1] + &#39;p&#39;
        filename_6ba = filename_6i[:-1] + &#39;ba&#39;
        filename_6bb = filename_6i[:-1] + &#39;bb&#39;
        filename_6t = filename_6i[:-2] + &#39;csv&#39;
        filename_6tx = filename_6i[:-1] + &#39;tx&#39;

        # The new eq36 build truncates names, e.g., MLS.Source.3i creates MLS.3o
        # Correct for this here:
        files_6o = [file for file in os.listdir(cwdd+path_6i) if file[-3:] == &#34;.6o&#34;]
        files_6p = [file for file in os.listdir(cwdd+path_6i) if file[-3:] == &#34;.6p&#34;]
        files_6ba = [file for file in os.listdir(cwdd+path_6i) if file[-4:] == &#34;.6ba&#34;]
        files_6bb = [file for file in os.listdir(cwdd+path_6i) if file[-4:] == &#34;.6bb&#34;]
        files_6t = [file for file in os.listdir(cwdd+path_6i) if file[-3:] == &#34;.6t&#34;]
        files_6tx = [file for file in os.listdir(cwdd+path_6i) if file[-4:] == &#34;.6tx&#34;]
        
        if len(files_6o) == 0:
            if ae.verbose &gt; 0:
                print(&#39;Error: EQ6 failed to produce output for &#39; + filename_6i)
        elif len(files_6o) == 1:
            file_6o = files_6o[0]
            file_6ba = files_6ba[0]
            file_6bb = files_6bb[0]
            try:
                file_6t = files_6t[0]
                file_6tx = files_6tx[0]
            except:
                pass

            try:
                # report errors in output
                with open(cwdd+path_6i+&#34;/&#34;+file_6o) as file:
                    lines = [line.rstrip() for line in file]
                EQ6_errors_found = ae._report_3o_6o_errors(lines, sample_name)
            except:
                msg = (&#34;Error: could not open &#34;+path_6i+file_6o+&#34; or there &#34;
                      &#34;is something wrong with EQ3/6 error reporting.&#34;)
                ae.err_handler.raise_exception(msg)
            
            try:
                # move output
                shutil.move(cwdd+path_6i+&#34;/&#34;+file_6o, cwdd+path_6o+&#34;/&#34;+filename_6o)
                shutil.move(cwdd+path_6i+&#34;/&#34;+file_6ba, cwdd+path_extra_out+&#34;/&#34;+filename_6ba)
                shutil.move(cwdd+path_6i+&#34;/&#34;+file_6bb, cwdd+path_extra_out+&#34;/&#34;+filename_6bb)
                try:
                    shutil.move(cwdd+path_6i+&#34;/&#34;+file_6t, cwdd+path_extra_out+&#34;/&#34;+filename_6t)
                    shutil.move(cwdd+path_6i+&#34;/&#34;+file_6tx, cwdd+path_extra_out+&#34;/&#34;+filename_6tx)
                except:
                    pass
            except:
                ae.err_handler.raise_exception((&#34;Error: could not move&#34;, path_6i+&#34;/&#34;+file_6o, &#34;to&#34;, path_6o+&#34;/&#34;+filename_6o))
        
        else:
            ae.err_handler.raise_exception(&#34;Error: multiple output files detected for one mass transfer calculation.&#34;)
            
        if len(files_6p) == 0:
            if ae.verbose &gt; 0:
                print(&#39;Error: EQ6 failed to produce a pickup file for &#39; + filename_6i)
        elif len(files_6p) == 1:
            file_6p = files_6p[0]
            try:
                # move output
                shutil.move(cwdd+path_6i+&#34;/&#34;+file_6p, cwdd+path_6p+&#34;/&#34;+filename_6p)
            except:
                ae.err_handler.raise_exception((&#34;Error: could not move&#34;, path_6i+&#34;/&#34;+file_6p, &#34;to&#34;, path_6p+&#34;/&#34;+filename_6p))
        else:
            ae.err_handler.raise_exception(&#34;Error: multiple pickup files detected for one mass transfer calculation.&#34;)
        
        if not EQ6_errors_found:
            m = Mass_Transfer(thermo=speciation.thermo,
                              six_o_file=&#39;rxn_6o/&#39;+filename_6o,
                              tab_name=&#34;eq6_extra_out/&#34;+filename_6i[:-2] + &#39;csv&#39;,
                              hide_traceback=hide_traceback)

            speciation.sample_data[sample_name][&#34;mass_transfer&#34;] = m
        else:
            speciation.sample_data[sample_name][&#34;mass_transfer&#34;] = None
            if ae.verbose &gt; 0:
                print((&#34;Mass transfer results for sample &#39;&#34;+sample_name+&#34;&#39; &#34;
                       &#34;could not be saved because the calculation did not &#34;
                       &#34;finish due to error(s).\n&#34;))
        
        # store input, output, and pickup as dicts in speciation object
        try:
            with open(path_6i + &#34;/&#34; + filename_6i, &#34;r&#34;) as f:
                lines=f.readlines()
            speciation.raw_6_input_dict[sample_name] = lines
        except:
            pass
        try:
            with open(path_6o + &#34;/&#34; + filename_6o, &#34;r&#34;) as f:
                lines=f.readlines()
            speciation.raw_6_output_dict[sample_name] = lines
        except:
            pass
        try:
            with open(path_6p + &#34;/&#34; + filename_6p, &#34;r&#34;) as f:
                lines=f.readlines()
            
            # Unlike 3p files, 6p files include headers that need to be removed
            bottom_half = []
            capture = False
            for line in lines:
                if &#34;Start of the bottom half of the input file&#34; in line:
                    capture = True
                if capture:
                    bottom_half.append(line)
            
            speciation.raw_6_pickup_dict[sample_name] = bottom_half
            
        except:
            pass
        
    if delete_generated_folders:
        __delete_dir(&#34;eq6_extra_out&#34;)
        __delete_dir(&#34;rxn_6i&#34;)
        __delete_dir(&#34;rxn_6p&#34;)
        __delete_dir(&#34;rxn_6o&#34;)
    
    return speciation


def join_mixes(m1, m2):
    &#34;&#34;&#34;
    Join the results of two mixes, m1 and m2, so that results extend from
    1:0 to 0:1 m1:m2.
    
    Parameters
    ----------
    m1, m2 : objects of class Mass_Transfer
        The mass transfer results of two mixing calculations

    Returns
    ----------
    An object of class `Mass_Transfer` with results joined for plotting.
    &#34;&#34;&#34;
    
    
    # tables belonging to the Mass Transfer class that are used by its plotting functions
    tabs = [&#34;misc_params&#34;, &#34;basis_logact&#34;, &#34;dissolved_elements_molal&#34;, &#34;dissolved_elements_ppm&#34;, 
            &#34;aq_distribution_logact&#34;, &#34;aq_distribution_molal&#34;, &#34;aq_distribution_logmolal&#34;,
            &#34;moles_minerals&#34;, &#34;moles_product_minerals&#34;]
    
    for tab in tabs:
        m2_reverse_rows = getattr(m2, tab).iloc[::-1]
        m2_reverse_rows[&#34;Xi&#34;] = [1+(1-float(xi)) for xi in m2_reverse_rows[&#34;Xi&#34;]]
        m2_reverse_rows = m2_reverse_rows[1:]
        m1_rows = getattr(m1, tab)
        setattr(m1, tab, pd.concat([m1_rows, m2_reverse_rows]).reset_index(drop=True))
        
    # do the same but for all EQ6 output tables
    if m1.tab != None and m2.tab != None:
        for tab in m1.tab.keys():
            if tab in m2.tab.keys():
                m2_reverse_rows = m2.tab[tab].iloc[::-1]
                m2_reverse_rows[&#34;Xi&#34;] = [1+(1-float(xi)) for xi in m2_reverse_rows[&#34;Xi&#34;]]
                m2_reverse_rows = m2_reverse_rows[1:]
                m1_rows = m1.tab[tab]
                m1.tab[tab] = pd.concat([m1_rows, m2_reverse_rows]).reset_index(drop=True)
    
    # do the same but for mass contribution tables
    for tab in m1.mass_contribution_dict.keys():
        if tab in m2.mass_contribution_dict.keys():
            m2_reverse_rows = m2.mass_contribution_dict[tab].iloc[::-1]
            m2_reverse_rows[&#34;Xi&#34;] = [1+(1-float(xi)) for xi in m2_reverse_rows[&#34;Xi&#34;]]
            m2_reverse_rows = m2_reverse_rows[1:]
            m1_rows = m1.mass_contribution_dict[tab]
            m1.mass_contribution_dict[tab] = pd.concat([m1_rows, m2_reverse_rows]).reset_index(drop=True)
    
    return m1


class Mass_Transfer:
    &#34;&#34;&#34;
    Class containing functions to facilitate mass transfer and reaction path
    calculations and visualize results.
    
    Parameters
    ----------
    six_o_file : str
        Path name of the &#39;6o&#39; output file generated by EQ6.
    
    thermo : an object of class Thermodata
        The subclass containing thermodynamic data in a Speciation object.
    
    thermodata_csv : str
        Path name of the WORM-styled thermodynamic database CSV used in the EQ6
        calculation.
    
    tab_name : str
        Path name of the TAB file generated by EQ6.
    
    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this class?
        When True, error messages handled by this class will be short and to
        the point.
    
    &#34;&#34;&#34;
    def __init__(self, six_o_file, thermo=None, tab_name=None, hide_traceback=True, verbose=1):
        
        self.err_handler = Error_Handler(clean=hide_traceback)
        
        self.six_o_file = six_o_file
        
        f=open(self.six_o_file, mode=&#39;r&#39;)
        self.six_o_file_lines=f.readlines()
        f.close()
        
        self.thermo=thermo
        self.tab_name = tab_name
        self.verbose = verbose
        
        self.inactive_species = self.__get_inactive_species()
        
        if isinstance(self.thermo.csv_db, pd.DataFrame):

            # these operations require a WORM-style thermodynamic database CSV
            obigt = pyCHNOSZ.thermo().OBIGT
            pyCHNOSZ.thermo(OBIGT = obigt.loc[ obigt.name.isin(FIXED_SPECIES), : ])
            _ = pyCHNOSZ.add_OBIGT(self.thermo.csv_db, force=True, messages=False)
            
            self.df = copy.deepcopy(self.thermo.csv_db)
            
            try:
                self.tab = self.process_tab(tab_name, self.thermo.csv_db)
            except:
                self.tab = None

            # remove species that do not have Gibbs free energy values
            self.df = self.df[~self.df[&#34;G&#34;].isna()]
            
            # remove inactive species from the database to prevent them from
            # showing up as mineral fields or saturation lines
            if len(self.inactive_species) &gt; 0:
                self.df = self.df[~self.df.name.isin(self.inactive_species)]
                
            basis_df = self.df[self.df[&#34;tag&#34;] == &#34;basis&#34;]
            aux_df = self.df[self.df[&#34;tag&#34;] == &#34;aux&#34;]
            
            # remove basis or aux species with no formula ox state col
            aux_df = aux_df[aux_df[&#34;formula_ox&#34;] != &#34;&#34;]
            aux_df = aux_df[~aux_df[&#39;formula_ox&#39;].isnull()]
            
            refstate_df = self.df[self.df[&#34;tag&#34;] == &#34;refstate&#34;]
            self.basis_df = pd.concat([basis_df])
            self.basis_aux_df = pd.concat([basis_df, aux_df, refstate_df])
            self.df_cr = self.df[self.df[&#34;state&#34;] == &#39;cr&#39;]
        else:
            self.df = None
            self.tab = None
            self.basis_df = None
            self.basis_aux_df = None
            self.df_cr = None
        
        self.misc_params = self.__get_misc_params()
        self.dissolved_elements_molal = self.__get_dissolved_elements(unit=&#34;molality&#34;)
        self.dissolved_elements_ppm = self.__get_dissolved_elements(unit=&#34;ppm&#34;)
 
        self.aq_distribution_logact = self.__get_aq_distribution(unit=&#34;log activity&#34;)
        self.aq_distribution_molal = self.__get_aq_distribution(unit=&#34;molality&#34;)
        self.aq_distribution_logmolal = self.__get_aq_distribution(unit=&#34;log molality&#34;)
        self.moles_minerals = self.__get_moles_minerals()

        self.saturation_states_pure_solids_log_Q_over_K = self.__get_saturation_states(unit=&#34;logQ/K&#34;)
        self.saturation_states_pure_solids_affinity = self.__get_saturation_states(unit=&#34;affinity&#34;)
        
        self.saturation_states_solid_solutions_log_Q_over_K = self.__get_ss_saturation_states(unit=&#34;logQ/K&#34;)
        self.saturation_states_solid_solutions_affinity = self.__get_ss_saturation_states(unit=&#34;affinity&#34;)
        self.solid_solution_names = [col for col in list(self.saturation_states_solid_solutions_affinity.columns) if col != &#34;Xi&#34;] # required by a few things below
        
        self.moles_product_minerals_and_solid_solutions = self.__get_moles_product_minerals(include_solid_solutions=True)
        self.moles_product_minerals = self.__get_moles_product_minerals(include_solid_solutions=False) # relies on self.solid_solution_names

        self.solid_solution_x_dict = self.__get_solid_solution_product_phases(unit=&#34;x&#34;) # relies on self.solid_solution_names
        self.moles_solid_solutions = self.moles_product_minerals_and_solid_solutions.loc[:, [&#34;Xi&#34;] + list(self.solid_solution_x_dict.keys())]
        self.solid_solution_log_x_dict = self.__get_solid_solution_product_phases(unit=&#34;log x&#34;) # relies on self.solid_solution_names
        self.solid_solution_log_lambda_dict = self.__get_solid_solution_product_phases(unit=&#34;log lambda&#34;) # relies on self.solid_solution_names
        self.solid_solution_log_lambda_dict = self.__get_solid_solution_product_phases(unit=&#34;log activity&#34;) # relies on self.solid_solution_names
        
        self.basis_molality = self.__get_basis_species(unit=&#34;molality&#34;)
        self.basis_ppm = self.__get_basis_species(unit=&#34;ppm&#34;)
        self.basis_logact = self.__get_basis_species(unit=&#34;logact&#34;) # this one needs to be after __get_aq_distribution()
        
        # format element names in case there are redox-isolated elements
        self.dissolved_elements_molal.columns = [&#34;Xi&#34;]+[_format_pseudoelement_name(e) for e in self.dissolved_elements_molal.columns if e not in [&#34;Xi&#34;, &#34;t(days)&#34;]]
        self.dissolved_elements_ppm.columns = [&#34;Xi&#34;]+[_format_pseudoelement_name(e) for e in self.dissolved_elements_ppm.columns if e not in [&#34;Xi&#34;, &#34;t(days)&#34;]]
        
        if self.moles_minerals.shape[0] == 0 and self.moles_product_minerals.shape[0] &gt; 0:
            # in the case of special reactants, there is no grand summary table in the 6o file
            # that combine reactant and product minerals (because there is no reactant mineral).
            # In this case, just assume these tables are equal.
            self.moles_minerals = self.moles_product_minerals

        self.mass_contribution_dict = self.__get_mass_contribution()
            
            
    def __get_misc_params(self):
        
        recording = False
        xi_vals = []
        t_vals = []
        p_vals = []
        pH_vals = []
        pmH_vals = []
        logfO2_vals = []
        Eh_vals = []
        pe_vals = []
        aw_vals = []
        for line in self.six_o_file_lines:
            if &#34;                    Xi=&#34; in line:
                recording = True
                splitstrings = line.strip().split(&#34; &#34;)
                xi = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#39;Xi=&#39;]][0]
                xi_vals.append(xi)
            elif &#34; Temperature=&#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                t = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#39;Temperature=&#39;, &#39;C&#39;]][0]
                t_vals.append(t)
            elif &#34; Pressure=&#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                p = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#39;Pressure=&#39;, &#39;bars&#39;]][0]
                p_vals.append(p)
            elif &#34;NBS pH scale &#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                multival = [v for v in splitstrings if v not in [&#39;&#39;, &#39;NBS&#39;, &#39;pH&#39;, &#39;scale&#39;]]
                multival = [float(v) if v != &#34;********&#34; else float(&#39;nan&#39;) for v in multival]
                pH_vals.append(multival[0])
                Eh_vals.append(multival[1])
                pe_vals.append(multival[2])
            elif &#34;Mesmer pH (pmH) scale &#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                pmH = [v for v in splitstrings if v not in [&#39;&#39;, &#39;Mesmer&#39;, &#39;pH&#39;, &#39;(pmH)&#39;, &#39;scale&#39;]]
                pmH = [float(v) if v != &#34;********&#34; else float(&#39;nan&#39;) for v in pmH][0]
                pmH_vals.append(pmH)
            elif &#34;  Log oxygen fugacity=&#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                logfO2 = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#34;Log&#34;, &#34;oxygen&#34;, &#34;fugacity=&#34;]][0]
                logfO2_vals.append(logfO2)
            elif &#34;  Activity of water=&#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                aw = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#34;Activity&#34;, &#34;of&#34;, &#34;water=&#34;]][0]
                aw_vals.append(aw)
            if &#34;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&#34; in line:
                recording = False

        df = pd.DataFrame({
            &#34;Xi&#34;:xi_vals,
            &#34;t(days)&#34;:[0]*len(xi_vals), # TODO: make this actually reflect days, need an example output file
            &#34;Temp(C)&#34;:t_vals,
            &#34;Press(bars)&#34;:p_vals,
            &#34;pH&#34;:pH_vals,
            &#34;pmH&#34;:pmH_vals,
            &#34;log fO2&#34;:logfO2_vals,
            &#34;Eh(v)&#34;:Eh_vals,
            &#34;pe&#34;:pe_vals,
            &#34;aw&#34;:aw_vals,
        })
        
        return df
            
            
    def __get_saturation_states(self, unit=&#34;logQ/K&#34;):
        
        if unit == &#34;logQ/K&#34;:
            col_index = 1
        elif unit == &#34;affinity&#34;:
            col_index = 2
        else:
            self.err_handler.raise_exception(&#34;Error in get_saturation_states()&#34;
                    &#34;. Unit not recognized.&#34;)
        
        return self.mine_6o_table(table_start=&#34;--- Saturation States of Pure Solids ---&#34;,
                table_stop=&#34;--- Saturation States of Pure Liquids ---&#34;,
                ignore = [&#34;&#34;, &#34;Phases&#34;, &#39;Phase&#39;, &#39;---&#39;, &#39;-&#39;],
                col_index=col_index)
    
    
    def __get_ss_saturation_states(self, unit=&#34;logQ/K&#34;):
        
        if unit == &#34;logQ/K&#34;:
            col_index = 1
        elif unit == &#34;affinity&#34;:
            col_index = 2
        else:
            self.err_handler.raise_exception(&#34;Error in get_ss_saturation_states()&#34;
                    &#34;. Unit not recognized.&#34;)
        
        return self.mine_6o_table(table_start=&#34;--- Saturation States of Solid Solutions ---&#34;,
                table_stop=&#34;--- Summary of Saturated and Supersaturated Phases ---&#34;,
                ignore = [&#34;&#34;, &#34;Phases&#34;, &#39;Phase&#39;, &#39;---&#39;, &#39;-&#39;],
                col_index=col_index)
    
            
    def __get_dissolved_elements(self, unit=&#34;molality&#34;):
        
        if unit == &#34;molality&#34;:
            col_index = -1
        elif unit == &#34;mg/kg.sol&#34; or unit == &#34;ppm&#34;:
            col_index = 1
        else:
            self.err_handler.raise_exception(&#34;Error in get_dissolved_elements()&#34;
                    &#34;. Unit not recognized.&#34;)
        
        return self.mine_6o_table(table_start=&#34;Elemental Composition of the Aqueous Solution&#34;,
                table_stop=&#34;Numerical Composition of the Aqueous Solution&#34;,
                ignore = [&#34;&#34;, &#34;Element&#34;, &#39;---&#39;, &#39;-&#39;],
                col_index=col_index)
            
        
    def __get_basis_species(self, unit=&#34;logact&#34;):
        
        if unit == &#34;molality&#34; or unit == &#34;logact&#34;:
            col_index = -1
        elif unit == &#34;mg/kg.sol&#34; or unit == &#34;ppm&#34;:
            col_index = 1
        else:
            self.err_handler.raise_exception(&#34;Error in get_basis_species()&#34;
                    &#34;. Unit not recognized.&#34;)
        
        basis_df = self.mine_6o_table(table_start=&#34;Numerical Composition of the Aqueous Solution&#34;,
                table_stop=&#34;Sensible Composition of the Aqueous Solution&#34;,
                ignore = [&#34;&#34;, &#34;Some&#34;, &#39;Species&#39;, &#39;---&#39;, &#39;-&#39;],
                col_index=col_index)
        
        if unit in [&#34;molality&#34;, &#34;ppm&#34;, &#39;mg/kg.sol&#39;]:
            return basis_df
        elif unit == &#34;logact&#34;:
            
            cols_to_harvest = [b for b in basis_df.columns if b not in [&#34;O2(g)&#34;, &#34;H2O&#34;]]
            
            return self.aq_distribution_logact[cols_to_harvest]
        
        
        
    def __get_mass_contribution(self):
        
        bases = [b for b in self.basis_logact.columns if b not in [&#39;Xi&#39;, &#39;t(days)&#39;, &#39;H2O&#39;, &#34;O2(g)&#34;, &#34;H+&#34;]]
        
        mass_contribution_dict = {}
        for basis in bases:

            df = self.mine_6o_table(
                            table_start=&#34;Species Accounting for 99% or More of Aqueous &#34;+basis,
                            table_stop=&#34;Subtotal&#34;,
                            ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;, &#39;-&#39;],
                            col_index=-1)


            df[&#39;Xi&#39;] = df[&#39;Xi&#39;].astype(str)
            df[&#39;Other&#39;] = 100 - df.sum(axis=1, numeric_only=True)
            df[&#39;Xi&#39;] = df[&#39;Xi&#39;].astype(float)

            df[df[&#34;Other&#34;] &lt; 0] = 0

            df[&#34;basis&#34;] = basis
            df[&#34;factor&#34;] = None
            df[&#34;molality&#34;] = None
            
            mass_contribution_dict[basis] = df
        
        return mass_contribution_dict
            
        
            
    def mine_6o_table(self,
                      table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                      table_stop=&#34;Species with molalities less than&#34;,
                      ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                      col_index=-1):
        
        &#34;&#34;&#34;
        Mine a table in a &#39;6o&#39; EQ6 output file and consolidate results into a
        dataframe.
        
        Parameters
        ----------
        table_start : str
            A unique string that indicates the start of the table.

        table_stop : str, optional
            A unique string that indicates the end of the table.
        
        ignore : list of str
            A list of strings representing lines to ignore when mining a table.
            For example, it is prudent to ignore blank lines, or lines
            containing the table column headers.
            A line will be skipped if line.strip().split(&#39; &#39;)[0] matches any
            of the strings in the given list.
        
        col_index : int, default -1
            Integer representing the index of the table column to be mined.
            The default is -1, which is the last column in the table.
            
        Returns
        -------
        df : Pandas dataframe
            A dataframe with rows of the extent of reaction (Xi), and columns
            containing the values of chemical species mined from the file.
        &#34;&#34;&#34;
        
        lines = self.six_o_file_lines
        
        species = []
        xi_vals=[]
        collect_values = False
        for i in lines:
            if len(i.strip().split(&#39; &#39;)) &gt; 1 and i.strip().split(&#39; &#39;)[0] == &#34;Xi=&#34;:
                this_xi_val = float(i.split(&#39; &#39;)[-1])
            if table_stop in i:
                collect_values = False
            if table_start in i:
                xi_vals.append(this_xi_val) # appending here prevents mismatch where there can be more Xi vals than tables to mine
                collect_values = True
            if collect_values:
                if i.strip().split(&#39; &#39;)[0] not in ignore:
                    species.append(i.strip().split(&#39; &#39;)[0])

        species = list(set(species))
        
        species_dict = {&#34;Xi&#34;:xi_vals}
        
        if len(species) == 0:
            df = pd.DataFrame(species_dict)
            return df
        
        for s in species:

            vals=[]
            collect_values = False
            for i in lines:
                if collect_values and table_stop in i:
                    # stop collecting
                    collect_values = False
                    if not got_value:
                        vals.append(np.nan)
                if table_start in i:
                    # start collecting
                    collect_values = True
                    got_value = False
                if collect_values:
                    if len(i.strip().split(&#39; &#39;)) &gt; 2 and i.strip().split(&#39; &#39;)[0] == s:
                        split_i = i.strip().split(&#39; &#39;)
                        split_i_clean = [v for v in split_i if v != &#39;&#39;]
                        val = split_i_clean[col_index]
                        try:
                            val = float(val)
                        except:
                            # if a value is not a float, e.g., 3.1450-100
                            if &#34;-&#34; in val:
                                val_list = val.split(&#34;-&#34;)
                                val = &#34;&#34;.join([val_list[0], &#34;E-&#34;, val_list[1]])
                                val = float(val)
                            elif &#34;+&#34; in val:
                                val_list = val.split(&#34;+&#34;)
                                val = &#34;&#34;.join([val_list[0], &#34;E&#34;, val_list[1]])
                                val = float(val)
                            elif &#34;SATD&#34; in val:
                                pass
                            else:
                                self.err_handler.raise_exception((&#34;Error: &#34;
                                    &#34;Encountered a non-numeric value when mining &#34;
                                    &#34;a .6o file: &#34;+val))
                        vals.append(val)
                        got_value = True
            species_dict[s] = vals
        
        df = pd.DataFrame(species_dict)
        
        if &#39;None&#39; in df.columns:
            df = df.drop([&#39;None&#39;], axis=1)
        
        return df

    
    def __get_inactive_species(self):
        
        lines=self.six_o_file_lines

        table_start = &#34;--- Inactive Species ---&#34;
        table_stop = &#34;The activity coefficients of aqueous species&#34;

        vals=[]
        collect_values=False
        for i in lines:
            if collect_values and table_stop in i:
                # stop collecting
                break
            if table_start in i:
                # start collecting
                collect_values = True
                got_value = False
            if collect_values:
                if table_start not in i:
                    split_i = i.strip().split(&#39; &#39;)
                    split_i_clean = [v for v in split_i if v != &#39;&#39; and v != &#34;None&#34;]
                    if len(split_i_clean) &gt; 0:
                        vals.append(split_i_clean[0])
                        got_value = True
        
        return vals
        
        
    def __get_aq_distribution(self, unit=&#34;log activity&#34;):
        
        if unit == &#34;log activity&#34;:
            col_index = -1
        elif unit == &#34;molality&#34;:
            col_index = 1
        elif unit == &#34;log molality&#34;:
            col_index = 2
        
        return self.mine_6o_table(
                      table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                      table_stop=&#34;Species with molalities less than&#34;,
                      ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                      col_index=col_index)

    def __get_moles_minerals(self):
        
        return self.mine_6o_table(
                      table_start=&#34;Grand Summary of Solid Phases&#34;,
                      table_stop=&#34;Mass, grams       Volume, cm3&#34;,
                      ignore = [&#34;&#34;, &#34;Phase/End-member&#34;, &#39;---&#39;],
                      col_index=2)

    
    def __get_moles_product_minerals(self, include_solid_solutions=True):
        
        if &#34;Grand Summary of Solid Phases&#34; in &#34;\n&#34;.join(self.six_o_file_lines):
            table_stop = &#34;Grand Summary of Solid Phases&#34;
        else:
            table_stop = &#34;Mass, grams       Volume, cm3&#34;
        
        df = self.mine_6o_table(
                      table_start=&#34;--- Summary of Solid Phases (ES) ---&#34;,
                      table_stop=table_stop,
                      ignore = [&#34;&#34;, &#34;Phase/End-member&#34;, &#39;---&#39;],
                      col_index=2)
        
        if not include_solid_solutions:
            mineral_names_to_keep = []
            minerals_in_solid_solutions = []
            
            recording = True
            for col in df.columns:
                if col not in self.solid_solution_names:
                    mineral_names_to_keep.append(col)
            df = df[mineral_names_to_keep]
            
        return df
        
        
    def __get_solid_solution_product_phases(self, unit=&#34;x&#34;):
        
        if unit == &#34;x&#34;:
            col_index = 1
        elif unit == &#34;log x&#34;:
            col_index = 2
        elif unit == &#34;log lambda&#34;:
            col_index = 3
        elif unit == &#34;log activity&#34;:
            col_index = 4
        
        ss_dict = {}
        for ss in self.solid_solution_names:
            df = self.mine_6o_table(
                         table_start=&#34;--- &#34;+ss+&#34; ---&#34;,
                         table_stop=&#34;Mineral&#34;,
                         ignore = [&#34;&#34;, &#34;Component&#34;, &#34;Ideal&#34;, &#39;---&#39;],
                         col_index=col_index)
            
            if not df.empty:
                ss_dict[ss] = df
        
        
        return ss_dict
        
        
    def print_tabs(self):
        &#34;&#34;&#34;
        Print the names of tables contained in a tab file processed by the
        the Mass_Transfer class.
        &#34;&#34;&#34;
        if self.tab != None:
            [print(key) for key in self.tab.keys()]
        else:
            print(&#34;A processed TAB file is not associated with this sample.&#34;)

        
    @staticmethod
    def __is_all_same_value(s):
        a = s.to_numpy()
        return (a[0] == a).all()
        
        
    def plot_reaction_paths(self,
                            xyb=None,
                            path_margin=0.25,
                            flip_xy=False,
                            show_annotation=True,
                            annotation_coords=[0,0],
                            show_nonparticipating_mineral_lines=False,
                            minerals_to_show=[],
                            calculate_projected_points=True,
                            path_line_type = &#34;markers+lines&#34;,
                            path_line_color = &#34;red&#34;,
                            path_point_fill_color = &#34;red&#34;,
                            path_point_line_color = &#34;red&#34;,
                            projected_point_fill_color = &#34;white&#34;,
                            projected_point_line_color = &#34;red&#34;,
                            h_line_color=&#34;black&#34;,
                            v_line_color=&#34;black&#34;,
                            d_line_color=&#34;black&#34;,
                            res=300,
                            plot_width=4,
                            plot_height=3,
                            ppi=122,
                            borders=0,
                            save_as=None,
                            save_format=None,
                            save_scale=1,
                            colormap=&#34;bw&#34;):
        
        &#34;&#34;&#34;
        Create interactive plots of reaction paths in geochemical variable
        space.
        
        Parameters
        ----------
        xyb : list of three str, default None
            By default, this function will plot reaction paths in all possible
            dimensions.
            
            Optionally, if you want to produce only a specific plot,
            you can provide a list containing the basis species to be used for
            the x-axis and y-axis, followed by the basis species used for
            balance. For example, [&#34;Fe+2&#34;, &#34;Fe+3&#34;, &#34;Mg+2&#34;] will have the log
            activity of Fe+2 on the x-axis, the log activity of Fe+3 on the
            y-axis, and will be balanced on Mg+2.

        path_margin : float, default 0.25
            Controls the spacing between the reaction path and the plot axes.
            Increasing this value increases the spacing.
        
        flip_xy : bool, default False
            Transpose the plot so the x and y variables switch axes?

        show_annotation : bool, default True
            Show annotation in the bottom left of the figure? The annotation
            includes the species used for balance, the temperature, and
            the pressure.

        annotation_coords : list, default [0,0]
            List of two numeric values representing the X and Y coordinates of
            the annotation, where 0,0 is the bottom left, 0.5,0 is the bottom
            center, 1,0 is the bottom right, 1,1 is the top right, and so on.
            The annotation includes the species used for balance, the
            temperature and the pressure.

        show_nonparticipating_mineral_lines : bool, default False
            Depict lines for minerals even if those minerals do not participate
            in the reaction? This does not affect the mineral field of the
            diagram, only the mineral planes denoted as lines.
        
        path_line_type : str, default &#34;markers+lines&#34;
            Reaction path line type. Can be either &#34;markers+lines&#34;, &#34;lines&#34;, or
            &#34;markers&#34;.
        
        path_line_color, str, default &#34;black&#34;
            Color of reaction path line.
        
        path_point_fill_color : str, default &#34;black&#34;
            Fill color of non-projected points along the reaction path. The
            fill color of projected points is handled by
            `projected_point_fill_color`.
        
        path_point_line_color : str, default &#34;black&#34;
            Color of the outlines of non-projected points along the reaction
            path. The outline color of projected points is handled by
            `projected_point_line_color`.
        
        projected_point_fill_color : str, default &#34;white&#34;
            Fill color of projected points along the reaction path. The
            fill color of non-projected points is handled by
            `path_point_fill_color`.
        
        projected_point_line_color : str, default &#34;black&#34;
            Color of the outlines of projected points along the reaction path.
            The outline color of non-projected points is handled by
            `path_point_line_color`.
            
        h_line_color : str, default &#34;black&#34;
            Color of horizontal lines representing minerals.
        
        v_line_color : str, default &#34;black&#34;
            Color of vertical lines representing minerals.
        
        d_line_color : str, default &#34;black&#34;
            Color of diagonal lines representing minerals.
        
        res : int, default 300
            Resolution, or number of calculations along each axis, for mineral
            stability fields. A lower number will be faster but will make appear
            boundaries blockier. A higher number takes longer to calculate, but
            will result in smoother boundaries.
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches.

        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
        
        borders : float, default 0
            Thickness of black lines forming boundaries between mineral
            stability regions. No lines appear if equal to 0.
        
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
        
        colormap : str, default &#34;bw&#34;
            Name of the colormap to color the scatterpoints. Accepts &#34;bw&#34;
            or names of matplotlib colormaps. If set to &#34;bw&#34;, the plot will be
            set to black and white, except for the reaction path line itself.
            The colors of the reaction path line and its points are controlled
            by `path_line_color`, `path_point_fill_color`,
            `path_point_line_color`, `projected_point_fill_color`,
            and `projected_point_line_color`.
        
        Returns
        -------
        fig_list : a list of Plotly figure objects
            A list of interactive Plotly figures. If xyb equals None
            (the default), then the list will contain figures representing all
            combinations of geochemical variables. Optionally, if xyb is
            specified, fig_list will only contain the single figure of interest.
        &#34;&#34;&#34;

        error_messages = []
        
        # check that there is only one temperature and pressure
        if not self.__is_all_same_value(self.misc_params[&#34;Temp(C)&#34;]):
            error_messages.append(&#34;Reaction paths cannot be plotted when temperature changes with reaction progress.&#34;)
        if not self.__is_all_same_value(self.misc_params[&#34;Press(bars)&#34;]):
            error_messages.append(&#34;Reaction paths cannot be plotted when pressure changes with reaction progress.&#34;)
        
        if isinstance(xyb, list):
            if len(xyb) != 3:
                error_messages.append((&#34;Error in xyb={}&#34;.format(xyb)+&#34;. &#34;
                        &#34;The xyb parameter must either be None or a list of &#34;
                        &#34;three basis species to serve as x, y, and balance variables.&#34;))
        
        if not isinstance(self.df, pd.DataFrame):
            error_messages.append((&#34;The plot_reaction_paths() function requires &#34;
                    &#34;a thermodynamic database in a WORM-style CSV format, e.g., &#34;
                    &#34;&#39;wrm_data.csv&#39;. You may be getting this message because &#34;
                    &#34;a data0 or data1 file was used.&#34;))
        
        if len(error_messages)&gt;0:
            self.err_handler.raise_exception(&#34;\n&#34;.join(error_messages))
        
        self.T = float(self.misc_params[&#34;Temp(C)&#34;][0])
        self.P = float(self.misc_params[&#34;Press(bars)&#34;][0])
        self.path_margin = path_margin
        
        minerals_formed = [m for m in self.moles_minerals.columns if m != &#34;Xi&#34;]
        
        all_elements_of_interest = []
        for mineral in minerals_formed:
            
            if mineral not in list(self.df[&#34;name&#34;]):
                if self.verbose &gt; 0:
                    print(&#34;The mineral&#34;, mineral, &#34;cannot be represented in a&#34;,
                           &#34;reaction path diagram, likely because it is missing&#34;,
                           &#34;a Gibbs free energy value in the thermodynamic&#34;,
                           &#34;database. Continuing anyway, but be aware that&#34;,
                           &#34;this mineral will not be represented in diagrams.&#34;)
                continue
            
            all_elements_of_interest += self.__get_elem_ox_of_interest_in_minerals(mineral)
        all_elements_of_interest_pre = list(set(all_elements_of_interest))
        
        # filter out elements like Fe+0, which has no aqueous species representative
        # for which to create an axis.
        bad_elem = []
        for elem in all_elements_of_interest_pre:
            if len(list(self.thermo.csv_db.loc[self.thermo.csv_db[&#39;name&#39;] == self.__get_basis_from_elem(elem), &#39;state&#39;])) == 0:
                bad_elem.append(elem)
            elif list(self.thermo.csv_db.loc[self.thermo.csv_db[&#39;name&#39;] == self.__get_basis_from_elem(elem), &#39;state&#39;])[0] != &#39;aq&#39;:
                bad_elem.append(elem)
                
        all_elements_of_interest = [elem for elem in all_elements_of_interest_pre if elem not in bad_elem]
        
        all_elements_of_interest = sorted(all_elements_of_interest)
        
        self.all_elements_of_interest = all_elements_of_interest
        
        fig_list = []
        
        # if there are only 2 elements of interest, these become the axes, and there is no
        # need to fuss with real vs projected points.
        if len(all_elements_of_interest) == 2:
            fig, _ , _ = self.__plot_reaction_path_main(
                                                triad = all_elements_of_interest,
                                                T=self.T, P=self.P,
                                                path_margin=self.path_margin,
                                                flip_xy=flip_xy,
                                                show_annotation=show_annotation,
                                                annotation_coords=annotation_coords,
                                                show_nonparticipating_mineral_lines=show_nonparticipating_mineral_lines,
                                                minerals_to_show=minerals_to_show,
                                                path_line_type=path_line_type,
                                                path_line_color=path_line_color,
                                                path_point_fill_color=path_point_fill_color,
                                                path_point_line_color=path_point_line_color,
                                                projected_point_fill_color=projected_point_fill_color,
                                                projected_point_line_color=projected_point_line_color,
                                                h_line_color=h_line_color,
                                                v_line_color=v_line_color,
                                                d_line_color=d_line_color,
                                                res=res,
                                                plot_width=plot_width,
                                                plot_height=plot_height,
                                                ppi=ppi,
                                                colormap=colormap,
                                                borders=borders,
                                                projected_points=[&#34;real&#34;]*self.moles_product_minerals.shape[0],
                                                first_pass=False)
        
            fig_list = [fig]
        
        elif len(all_elements_of_interest) &gt;= 3:

            # get a list of elem pairs for plotting
            alist = self.all_elements_of_interest
            element_plot_pairs = []
            for result in itertools.combinations(alist, 2):
                element_plot_pairs.append(list(result))

            element_plot_triad = []
            for pair in element_plot_pairs:
                elem_not_in_pair = [e for e in self.all_elements_of_interest if e not in pair]
                for e in elem_not_in_pair:
                    triad_to_append = pair + [e]
                    element_plot_triad.append(triad_to_append)

            if colormap == &#34;bw&#34;:
                if borders == 0:
                    borders = 1
                colormap = &#34;none&#34;
                h_line_color = &#34;black&#34;
                v_line_color = &#34;black&#34;
                d_line_color = &#34;black&#34;

            fig_list = []
            pred_minerals_from_fields_list = []
            pred_minerals_from_lines_list = []
            

            if isinstance(xyb, list):
                try:
                    xyb_element_plot_triad = [[self.__get_elem_ox_of_interest_in_minerals(v)[0] for v in xyb]]
                except:
                    err = (&#34;Plot axes cannot accomodate desired variables. &#34;
                           &#34;Available variables include {}&#34;.format([self.__get_basis_from_elem(elem) for elem in alist]))
                    self.err_handler.raise_exception(err)
                xyb_i = None
                # get index of triad that matches xyb:
                for i,triad in enumerate(element_plot_triad):
                    if set(xyb_element_plot_triad[0][0:2]) == set(triad[0:2]) and xyb_element_plot_triad[0][2] == triad[2]:
                        xyb_i = i
                if xyb_i == None:
                    err = (&#34;Plot axes cannot accomodate desired variables. &#34;
                           &#34;Available variables include {}&#34;.format([self.__get_basis_from_elem(elem) for elem in alist]))
                    self.err_handler.raise_exception(err)
            
            if not calculate_projected_points or path_line_type==&#34;lines&#34;:
                projected_points = [&#34;real&#34;]*self.moles_product_minerals.shape[0]
                fig_list_projected_points = [projected_points]*len(element_plot_triad)
                
            else:
                
                if len(element_plot_triad) &gt; 20:
                    if self.verbose &gt; 0:
                        print(&#34;Warning! There are {}&#34;.format(len(element_plot_triad)),
                              &#34;different combinations of variables that must be considered&#34;,
                              &#34;in order to plot markers.&#34;)
                        print(&#34;This might take a very long time or may not finish calculating at all.&#34;)
                        print(&#34;We recommend setting calculate_projected_points=False in&#34;,
                              &#34;plot_reaction_paths() and then restarting the&#34;,
                              &#34;calculation to avoid lengthy calculation times.&#34;)
                
                for triad in element_plot_triad:
                    
                    # do a quick first pass at making figures to see which points are projections.
                    fig, pred_minerals_from_fields, pred_minerals_from_lines = self.__plot_reaction_path_main(
                                                        triad, T=self.T, P=self.P,
                                                        show_nonparticipating_mineral_lines=False, # no need for this in first pass
                                                        minerals_to_show=[], # no need for this in first pass
                                                        path_margin=self.path_margin,
                                                        flip_xy=flip_xy,
                                                        first_pass=True, # flag for skipping certain calculations/plotting
                                                        res=1) # low res first pass

                    if pred_minerals_from_fields == None:
                        pred_minerals_from_fields=[None]*self.moles_product_minerals.shape[0]
                    
                    fig_list.append(fig)
                    pred_minerals_from_fields_list.append(pred_minerals_from_fields)
                    pred_minerals_from_lines_list.append(pred_minerals_from_lines)

                # determine which line segments in the reaction path are projections
                # and which are actually in the plane of the diagram.
                # This is the &#34;first pass&#34;
                fig_list_projected_points = []
                for i,triad in enumerate(element_plot_triad):

                    projected_points = [&#34;projection&#34;]*self.moles_product_minerals.shape[0]
                    for irow in range(0, self.moles_product_minerals.shape[0]):

                        # get names of minerals formed at this xi
                        xirow = list(self.moles_product_minerals.iloc[irow])
                        formed_minerals = [self.moles_product_minerals.columns[1:][ii] for
                                           ii,mineral in enumerate(xirow[1:]) if
                                           mineral&gt;0]
                        
                        available_pred_minerals_from_fields = [l[irow] for l in pred_minerals_from_fields_list]

                        for mineral in formed_minerals:

                            if mineral == pred_minerals_from_fields_list[i][irow]:
                                # if this mineral is in pred_minerals_from_fields_list,
                                # then it is NOT a projection.
                                projected_points[irow] = &#34;real&#34;
                            if mineral in available_pred_minerals_from_fields and mineral in pred_minerals_from_lines_list[i]:
                                # if this mineral is in the irowth location of any of the
                                # lists in pred_minerals_from_lines_list, it is NOT a
                                # projection.
                                projected_points[irow] = &#34;real&#34;

                    fig_list_projected_points.append(projected_points)
                
            if isinstance(xyb, list):
                # if xyb is defined, make element_plot_triad have a length of 1
                element_plot_triad = xyb_element_plot_triad
                # give the list of projected points lists a length of 1
                fig_list_projected_points = [fig_list_projected_points[xyb_i]]
                
            fig_list = []
            for i,triad in enumerate(element_plot_triad):
                # re-run figure generation, passing in a list of which points are projected.
                fig, _ , _ = self.__plot_reaction_path_main(
                                    triad, T=self.T, P=self.P,
                                    path_margin=self.path_margin,
                                    flip_xy=flip_xy,
                                    show_annotation=show_annotation,
                                    annotation_coords=annotation_coords,
                                    show_nonparticipating_mineral_lines=show_nonparticipating_mineral_lines,
                                    minerals_to_show=minerals_to_show,
                                    path_line_type=path_line_type,
                                    path_line_color=path_line_color,
                                    path_point_fill_color=path_point_fill_color,
                                    path_point_line_color=path_point_line_color,
                                    projected_point_fill_color=projected_point_fill_color,
                                    projected_point_line_color=projected_point_line_color,
                                    h_line_color=h_line_color,
                                    v_line_color=v_line_color,
                                    d_line_color=d_line_color,
                                    res=res,
                                    plot_width=plot_width,
                                    plot_height=plot_height,
                                    ppi=ppi,
                                    colormap=colormap,
                                    borders=borders,
                                    projected_points=fig_list_projected_points[i],
                                    first_pass=False)

                fig_list.append(fig)
        
        if not fig_list and self.verbose &gt; 0:
            print(&#34;Warning: a reaction path plot could not be generated for this system.&#34;)
        
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            for i,fig in enumerate(fig_list):
                
                if isinstance(xyb, list):
                    name_append = &#34;&#34;
                else:
                    name_append = &#34;_{}&#34;.format(i+1)
                _, _ = dummy_sp._save_figure(fig,
                        save_as+name_append, save_format, save_scale,
                        plot_width, plot_height, ppi)
        
        return fig_list
        

    
    
    @staticmethod
    def process_tab(tab_name, thermodata_csv):
        
        &#34;&#34;&#34;
        Process a TAB file (from EQ6) into a dictionary of Pandas dataframes.
        
        Parameters
        ----------
        tab_name : str
            Path name of the TAB file generated by EQ6.
        
        thermodata_csv : str or Pandas dataframe
            Path name of the WORM-styled thermodynamic database CSV used in the
            EQ6 calculation. Alternately, the thermodynamic database itself as a
            Pandas dataframe itself.

        Returns
        -------
        tab : a dict of Pandas dataframes
            A dictionary of dataframes representing tables mined from the TAB
            file.
        &#34;&#34;&#34;
        
        if isinstance(thermodata_csv, str):
            thermo_db = pd.read_csv(thermodata_csv)
        else:
            thermo_db = thermodata_csv
        
        
        thermo_db_names = list(thermo_db[&#34;name&#34;])

        with open(tab_name, &#34;r&#34;) as tabfile:
            tab_lines = tabfile.readlines()

        tab = {}

        tables = [&#34;B1&#34;, &#34;B2&#34;, &#34;C1&#34;, &#34;C2&#34;, &#34;C3&#34;, &#34;C4&#34;,
                  &#34;D1&#34;, &#34;D2&#34;, &#34;D3&#34;, &#34;D4&#34;, &#34;E1&#34;, &#34;E2&#34;,
                  &#34;E3&#34;, &#34;J&#34;, &#34;K&#34;, &#34;P&#34;, &#34;Q&#34;, &#34;T&#34;, &#34;W&#34;]

        record_lines = False
        get_header = False
        recorded_lines = []
        for line in tab_lines:
            split_line = line.split(&#34;,&#34;)

            if True in [s in [&#34;Table &#34; + t for t in tables] for s in split_line]:
                get_header = True
                table_name = &#34; &#34;.join(split_line[1:-1])
                continue

            if get_header:
                header = split_line[1:-1]

                # handle instances where the tab file creates extra columns for things like &#34;albite,low&#34;
                if table_name in [&#34;Table P Moles of product minerals&#34;,
                                  &#34;Table Q Saturation indices of potential product phases&#34;,
                                  &#34;Table J Moles of reactants destroyed/created&#34;,
                                  &#34;Table K Affinities of reactants (kcal)&#34;]:
                    
                    if table_name in [&#34;Table P Moles of product minerals&#34;,
                                      &#34;Table J Moles of reactants destroyed/created&#34;]:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;] # table P and J
                    elif table_name == &#34;Table Q Saturation indices of potential product phases&#34;:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;H2O&#34;, &#34;Gas&#34;] # table Q
                    elif table_name == &#34;Table K Affinities of reactants (kcal)&#34;:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;Total&#34;]

                    for i,h in enumerate(header):

                        if h != &#34;Xi&#34; and h != &#34;t(days)&#34; and h != &#34;H2O&#34; and h != &#34;Gas&#34; and h != &#34;Total&#34;:
                            if h not in thermo_db_names:
                                if header[i-1]+&#34;,&#34;+h in thermo_db_names:
                                    new_header = new_header[:-1]
                                    new_header.append(header[i-1]+&#34;,&#34;+h)
                                else:
                                    new_header.append(h)
                            else:
                                new_header.append(h)

                    header = new_header


                record_lines = True
                get_header = False
                continue

            if &#34;EndTable:&#34; in split_line:
                record_lines = False
                if len(recorded_lines) &gt; 0:
                    df = pd.DataFrame(recorded_lines)
                    recorded_lines = []
                    df.columns = header
                    tab[table_name] = df

            if record_lines:
                recorded_lines.append(split_line[1:-1])

        return tab

    
    def __get_mineral_elem_ox(self, mineral):
        split_list = list(self.df[self.df[&#34;name&#34;]==mineral][&#34;formula_ox&#34;])[0].split()
        split_list_clean = [s.replace(&#34; &#34;, &#34;&#34;) for s in split_list]
        try:
            elem_ox_list = [re.findall(r&#34;^(?:\d+|)([A-Z].*$)&#34;, s)[0] for s in split_list_clean]
        except:
            elem_ox_list = []
        return elem_ox_list

    
    def __get_elem_ox_of_interest_in_minerals(self, mineral_name):
        mineral_elements = self.__get_mineral_elem_ox(mineral_name)
        mineral_elements_of_interest = [e for e in mineral_elements if e not in [&#34;H+&#34;, &#34;O-2&#34;]]
        return mineral_elements_of_interest


    def __get_mineral_elem_ox_dict(self, mineral):
        split_list = list(self.df[self.df[&#34;name&#34;]==mineral][&#34;formula_ox&#34;])[0].split()
        split_list_clean = [s.replace(&#34; &#34;, &#34;&#34;) for s in split_list]
        elem_ox_names = self.__get_mineral_elem_ox(mineral)

        elem_ox_list = []
        for s in split_list:
            coeff = re.findall(r&#34;(\d+)[A-Z]&#34;, s)
            if len(coeff) == 0:
                coeff = 1
            else:
                coeff = float(coeff[0])
            elem_ox_list.append(coeff)

        return {key:val for key,val in zip(elem_ox_names, elem_ox_list)}

    
    def __get_mineral_elem_ox_dict_interest(self, mineral):
        mineral_dict = self.__get_mineral_elem_ox_dict(mineral)
        return {key:value for key,value in zip(mineral_dict.keys(), mineral_dict.values()) if key not in [&#34;H+&#34;, &#34;O-2&#34;]}


    def __get_basis_from_elem(self, elem):

        basis_species_x = None

        for s in list(self.basis_df[&#34;name&#34;]):
            if elem in self.__get_elem_ox_of_interest_in_minerals(s):
                basis_species_x = s

        if basis_species_x == None:
            for s in list(self.basis_aux_df[&#34;name&#34;]):
                if elem in self.__get_elem_ox_of_interest_in_minerals(s):
                    basis_species_x = s

        return basis_species_x

    
    def __get_reaction_path(self, plot_basis_x, plot_basis_y, div_var_name):

        xi_vals=self.aq_distribution_logact[&#34;Xi&#34;]
        proton_vals=self.aq_distribution_logact[&#34;H+&#34;]
        x_vals=self.aq_distribution_logact[plot_basis_x]
        y_vals=self.aq_distribution_logact[plot_basis_y]

        assert len(proton_vals) == len(x_vals), f&#34;number of proton values ({proton_vals}) should equal number of x values ({x_vals})&#34;
        assert len(proton_vals) == len(y_vals), f&#34;number of proton values ({proton_vals}) should equal number of y values ({y_vals})&#34;

        x_vals = [log10((10**float(x))/(10**float(d))**_get_ion_ratio_exponent(plot_basis_x, &#34;H+&#34;)) for x,d in zip(x_vals,proton_vals)]
        y_vals = [log10((10**float(y))/(10**float(d))**_get_ion_ratio_exponent(plot_basis_y, &#34;H+&#34;)) for y,d in zip(y_vals,proton_vals)]
        
        return xi_vals, x_vals, y_vals

    
    def __get_plot_range(self, x_vals, y_vals):
        min_x_val = min(x_vals)
        min_y_val = min(y_vals)
        max_x_val = max(x_vals)
        max_y_val = max(y_vals)

        path_x_range = max_x_val - min_x_val
        path_y_range = max_y_val - min_y_val

        if len(list(set(x_vals))) == 1:
            # x values form a vertical line
            plot_x_range = [min_x_val-self.path_margin*(path_x_range+1), max_x_val+self.path_margin*(path_x_range+1)]
        else:
            plot_x_range = [min_x_val-self.path_margin*path_x_range, max_x_val+self.path_margin*path_x_range]
        
        if len(list(set(y_vals))) == 1:
            # y values form a horizontal line
            plot_y_range = [min_y_val-self.path_margin*(path_y_range+1), max_y_val+self.path_margin*(path_y_range+1)]
        else:
            plot_y_range = [min_y_val-self.path_margin*path_y_range, max_y_val+self.path_margin*path_y_range]

        return plot_x_range, plot_y_range

    
    @staticmethod
    def __get_xy_labs(plot_basis_x, plot_basis_y):
        try:
            xlab = ratlab(plot_basis_x)
        except:
            xlab = &#34;log a&#34;+chemlabel(plot_basis_x)
        try:
            ylab = ratlab(plot_basis_y)
        except:
            ylab = &#34;log a&#34;+chemlabel(plot_basis_y)

        return xlab, ylab


    def __plot_reaction_path_background(self, plot_basis_x, plot_basis_y,
                                        div_var_name, x_vals, y_vals,
                                        colormap=&#34;viridis&#34;, borders=0,
                                        field_minerals_exist=True, path_margin=0.25,
                                        plot_width=4, plot_height=3, ppi=122, res=300,
                                        annotation=None, annotation_coords=[0, 0],
                                        messages=False):
        
        plot_x_range, plot_y_range = self.__get_plot_range(x_vals, y_vals)

        xlab,ylab = self.__get_xy_labs(plot_basis_x, plot_basis_y)
        
        args = {plot_basis_x:plot_x_range+[res],
                plot_basis_y:plot_y_range+[res],
                &#34;T&#34;:self.T, &#34;P&#34;:self.P, &#34;messages&#34;:messages}
        
        if field_minerals_exist:
            
            # check each value of Xi to see which mineral is most predominant
            pred_minerals_from_fields = []
            for i,val in enumerate(x_vals):
                
                args_temp = {plot_basis_x:[x_vals[i], x_vals[i], 1],
                             plot_basis_y:[y_vals[i], y_vals[i], 1],
                             &#34;T&#34;:self.T, &#34;P&#34;:self.P, &#34;messages&#34;:messages}
                
                a = pyCHNOSZ.affinity(**args_temp)
                e = pyCHNOSZ.equilibrate(a, balance=self.__get_basis_from_elem(div_var_name), messages=messages)
                table = pyCHNOSZ.diagram(e, balance=self.__get_basis_from_elem(div_var_name), interactive=True, fig_out=False, plot_it=False, messages=messages)
                
                pred_minerals_from_fields.append(table[&#34;prednames&#34;][0])
            
            a = pyCHNOSZ.affinity(**args)
            e = pyCHNOSZ.equilibrate(a, balance=self.__get_basis_from_elem(div_var_name), messages=messages)
            
            table,fig = pyCHNOSZ.diagram_interactive(e,
                                colormap=colormap, borders=borders,
                                balance=self.__get_basis_from_elem(div_var_name),
                                width=plot_width*ppi, height=plot_height*ppi,
                                xlab=xlab, ylab=ylab, annotation=annotation,
                                annotation_coords=annotation_coords,
                                plot_it=False, messages=messages)
            
            return table, fig, pred_minerals_from_fields
        
        else:
            # empty plot upon
            fig = go.Figure(go.Scatter(x=pd.Series(dtype=object),
                                       y=pd.Series(dtype=object),
                                       mode=&#34;markers&#34;,
                                       ),
                           layout_xaxis_range=plot_x_range,
                           layout_yaxis_range=plot_y_range,
                           )

            fig.add_annotation(x=annotation_coords[0],
                               y=annotation_coords[1],
                               xref=&#34;paper&#34;,
                               yref=&#34;paper&#34;,
                               align=&#39;left&#39;,
                               text=annotation,
                               bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;,
                               showarrow=False)

            fig.update_layout(
                width=plot_width*ppi, height=plot_height*ppi,
                xaxis={&#34;title&#34;: xlab},
                yaxis={&#34;title&#34;: ylab},
                template=&#34;simple_white&#34;,
            )

            fig.update_yaxes(autorange=True)

            return None,fig,None # a table, diagram without regions, and a list of predicted minerals at each Xi


    @staticmethod
    def __calc_dissrxn_logK(mineral, T, P):

        logK = pyCHNOSZ.subcrt([mineral], coeff=[-1], property=&#39;logK&#39;, T=T, P=P,
                      show=False, messages=False)[&#34;out&#34;][&#34;logK&#34;].item()
        
        return logK

    
    def __add_reaction_path_to_plot(self, x_vals, y_vals, xi_vals, fig,
                                    basis_species_x, basis_species_y,
                                    path_margin=0.25, projected_points=[],
                                    path_line_type = &#34;markers+lines&#34;,
                                    path_line_color = &#34;black&#34;,
                                    path_point_fill_color = &#34;black&#34;,
                                    path_point_line_color = &#34;black&#34;,
                                    projected_point_fill_color = &#34;white&#34;,
                                    projected_point_line_color = &#34;black&#34;):

        min_x_val = min(x_vals)
        min_y_val = min(y_vals)
        max_x_val = max(x_vals)
        max_y_val = max(y_vals)

        path_x_range = max_x_val - min_x_val
        path_y_range = max_y_val - min_y_val

        xlab,ylab = self.__get_xy_labs(basis_species_x, basis_species_y)
        
        with np.errstate(divide=&#39;ignore&#39;):
            log_xi_vals = [round(np.log10(val), 4) for val in xi_vals]
            log_xi_vals = [&#34;N/A&#34; if np.isinf(val) else val for val in log_xi_vals]
        
        
        if path_line_type in [&#34;markers+lines&#34;, &#34;lines&#34;]:
            fig.add_trace(
                go.Scatter(
                    x=x_vals,
                    y=y_vals,
                    line=go.scatter.Line(color=path_line_color),
                    mode=&#39;lines&#39;,
                    showlegend=True,
                    name=&#39;reaction path&#39;,
                    customdata = np.stack((xi_vals, log_xi_vals), axis=-1),
                    hovertemplate = &#39;Xi: %{customdata[0]}&lt;br&gt;log Xi: %{customdata[1]}&lt;br&gt;&#39;+xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab+&#39;: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    legendgroup=&#39;reaction path&#39;,
                )
            )
        
        
        if len(projected_points) &gt; 0 and path_line_type in [&#34;markers+lines&#34;, &#34;markers&#34;]:
            
            x_vals_real = []
            x_vals_projected = []
            y_vals_real = []
            y_vals_projected = []
            xi_vals_real = []
            xi_vals_projected = []
            for i,p in enumerate(projected_points):
                if p == &#34;real&#34;:
                    x_vals_real.append(x_vals[i])
                    y_vals_real.append(y_vals[i])
                    xi_vals_real.append(xi_vals[i])
                else:
                    x_vals_projected.append(x_vals[i])
                    y_vals_projected.append(y_vals[i])
                    xi_vals_projected.append(xi_vals[i])
                    
            np.seterr(divide=&#39;ignore&#39;) # todo: reset np warnings
            log_xi_vals_real = [round(np.log10(val), 4) for val in xi_vals_real]
            log_xi_vals_real = [&#34;N/A&#34; if np.isinf(val) else val for val in log_xi_vals_real]
            log_xi_vals_projected = [round(np.log10(val), 4) for val in xi_vals_projected]
            log_xi_vals_projected = [&#34;N/A&#34; if np.isinf(val) else val for val in log_xi_vals_projected]
                    
            if len(x_vals_real) &gt; 0:
                fig.add_trace(
                    go.Scatter(
                        x=x_vals_real,
                        y=y_vals_real,
                        marker=dict(
                            color=path_point_fill_color,
                            line=dict(
                                color=path_point_line_color,
                                width=2
                            )
                        ),
                        mode=&#39;markers&#39;,
                        showlegend=False,
                        name=&#39;reaction path&#39;,
                        customdata = np.stack((xi_vals_real, log_xi_vals_real), axis=-1),
                        hovertemplate = &#39;Xi: %{customdata[0]}&lt;br&gt;log Xi: %{customdata[1]}&lt;br&gt;&#39;+xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab+&#39;: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                        legendgroup=&#39;reaction path&#39;,
                    )
                )
            if len(x_vals_projected) &gt; 0:
                
                fig.add_trace(
                    go.Scatter(
                        x=x_vals_projected,
                        y=y_vals_projected,
                        marker=dict(
                            color=projected_point_fill_color,
                            line=dict(
                                color=projected_point_line_color,
                                width=2
                            )
                        ),
                        mode=&#39;markers&#39;,
                        showlegend=False,
                        name=&#39;reaction path&#39;,
                        customdata = np.stack((xi_vals_projected, log_xi_vals_projected), axis=-1),
                        hovertemplate = &#39;Xi: %{customdata[0]}&lt;br&gt;log Xi: %{customdata[1]}&lt;br&gt;&#39;+xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab+&#39;: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                        legendgroup=&#39;reaction path&#39;,
                    )
                )
            

        fig.update_xaxes(range=self.__get_plot_range(x_vals, y_vals)[0], autorange=False)
        fig.update_yaxes(range=self.__get_plot_range(x_vals, y_vals)[1], autorange=False)

        return fig

    
    def __plot_reaction_path_main(self,
                                  triad, T=25, P=1, path_margin=0.25,
                                  flip_xy=False,
                                  show_annotation=False,
                                  annotation_coords=[0,0],
                                  show_nonparticipating_mineral_lines = False,
                                  minerals_to_show=[],
                                  path_line_type = &#34;markers+lines&#34;,
                                  path_line_color = &#34;black&#34;,
                                  path_point_fill_color = &#34;black&#34;,
                                  path_point_line_color = &#34;black&#34;,
                                  projected_point_color = &#34;white&#34;,
                                  projected_point_fill_color= &#34;white&#34;,
                                  projected_point_line_color = &#34;black&#34;,
                                  h_line_color=&#34;red&#34;,
                                  v_line_color=&#34;blue&#34;,
                                  d_line_color=&#34;orange&#34;,
                                  res=300,
                                  plot_width=4,
                                  plot_height=3,
                                  ppi=122,
                                  colormap=&#34;viridis&#34;,
                                  borders=0,
                                  projected_points=[],
                                  first_pass=False):

        e_pair = triad[0:2]
        
        if len(triad) == 3:
            div_var_name = triad[2]
        elif len(triad) == 2:
            div_var_name = &#34;None&#34;

        if flip_xy:
            e_pair.reverse()
            
        basis_species_x = self.__get_basis_from_elem(e_pair[0])
        basis_species_y = self.__get_basis_from_elem(e_pair[1])

        basis_sp_list = list(set([self.__get_basis_from_elem(e) for e in triad] + [&#34;H+&#34;,&#34;H2O&#34;]))
    
        try:
            pyCHNOSZ.basis(basis_sp_list)
        except:
            pyCHNOSZ.basis(basis_sp_list + [&#34;H2&#34;])
        
        elems = []
        for elem in triad:
            elems.append(elem.split(&#34;+&#34;)[0].split(&#34;-&#34;)[0])
        
        mineral_names = []
        for elem in triad:
            elem = elem.split(&#34;+&#34;)[0].split(&#34;-&#34;)[0]
            m_idx = pyCHNOSZ.retrieve((elem), list(set([&#34;O&#34;, &#34;H&#34;]+elems)), state=[&#34;cr&#34;], messages=False)
            if len(m_idx) &gt; 0:
                mineral_names += list(pyCHNOSZ.info(m_idx, messages=False)[&#34;name&#34;])
        
        # exclude inactive minerals
        mineral_names_active = [m for m in mineral_names if m in list(self.df[&#34;name&#34;])]
        mineral_names = list(set(mineral_names_active))
        
        mineral_formula_ox = [self.__get_elem_ox_of_interest_in_minerals(m) for m in mineral_names]
        mineral_formula_ox_singles = [e if len(e)==1 else [] for e in mineral_formula_ox]
        mineral_formula_ox_doubles = [e if len(e)==2 else [] for e in mineral_formula_ox]
        mineral_formula_ox_triples = [e if len(e)==3 else [] for e in mineral_formula_ox]
        
        retrieved_minerals = []
        for i,s in enumerate(mineral_formula_ox_singles):
            if [e_pair[0]] == s:
                retrieved_minerals.append(mineral_names[i])
        x_minerals_to_plot = retrieved_minerals

        retrieved_minerals = []
        for i,s in enumerate(mineral_formula_ox_singles):
            if [e_pair[1]] == s:
                retrieved_minerals.append(mineral_names[i])
        y_minerals_to_plot = retrieved_minerals

        xy_minerals_to_plot = []
        for i,s in enumerate(mineral_formula_ox_doubles):
            if e_pair[0] in s and e_pair[1] in s:
                xy_minerals_to_plot.append(mineral_names[i])

        if len(x_minerals_to_plot) &gt; 1:
            pyCHNOSZ.species(x_minerals_to_plot, add=True)
        if len(y_minerals_to_plot) &gt; 1:
            pyCHNOSZ.species(y_minerals_to_plot, add=True)
        if len(xy_minerals_to_plot) &gt; 1:
            pyCHNOSZ.species(xy_minerals_to_plot, add=True)

#         print(&#34;x, y, xy&#34;)
#         print(x_minerals_to_plot)
#         print(y_minerals_to_plot)
#         print(xy_minerals_to_plot)
            
        field_minerals_to_plot = []
        for i,s in enumerate(mineral_formula_ox_triples):
            if e_pair[0] in s and e_pair[1] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
        for i,s in enumerate(mineral_formula_ox_doubles):
            if e_pair[0] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
            elif e_pair[1] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
        for i,s in enumerate(mineral_formula_ox_singles):
            if div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
                
        field_minerals_exist = True
        try:
            # get minerals relevant to plotted element pair
            pyCHNOSZ.species(field_minerals_to_plot)#, add=True)
        except:
            field_minerals_exist = False
        
#         print(&#34;field minerals&#34;)
#         print(field_minerals_to_plot)
    
        xi_vals, x_vals, y_vals = self.__get_reaction_path(basis_species_x, basis_species_y, div_var_name)
            
        
        if self.P &lt;= 1:
            bar_bars = &#34;bar&#34;
        else:
            bar_bars = &#34;bars&#34;
        
        if show_annotation and div_var_name != &#34;None&#34;:
            annotation = &#34;Balanced on: &#34;+chemlabel(self.__get_basis_from_elem(div_var_name))+&#34;&lt;br&gt;&#34;+&#39;%g&#39;%(self.T)+&#34; C, &#34;+&#39;%g&#39;%(self.P)+&#34; &#34;+bar_bars
        elif show_annotation:
            annotation = &#39;%g&#39;%(self.T)+&#34; C, &#34;+&#39;%g&#39;%(self.P)+&#34; &#34;+bar_bars
        else:
            annotation = None
        
        table,fig,pred_minerals_from_fields = self.__plot_reaction_path_background(
            basis_species_x, basis_species_y, div_var_name, x_vals, y_vals,
            plot_width=plot_width, plot_height=plot_height, ppi=ppi, res=res,
            colormap=colormap, borders=borders,
            annotation_coords=annotation_coords,
            field_minerals_exist=field_minerals_exist, path_margin=self.path_margin,
            annotation=annotation, messages=False)

        # plot minerals with a single element of interest as a line
        plot_x_range, plot_y_range = self.__get_plot_range(x_vals, y_vals)
        
        line_styles = [&#39;dot&#39;, &#39;dash&#39;, &#39;dashdot&#39;, &#39;longdash&#39;, &#39;longdashdot&#39;]
        line_i = 0
        line_width = 1
        
        if first_pass:
            fig = None
        else:
            for mineral in x_minerals_to_plot + y_minerals_to_plot + xy_minerals_to_plot:
                
                if not show_nonparticipating_mineral_lines and mineral not in list(self.moles_product_minerals.columns) and mineral not in minerals_to_show:
                    continue
                
                # deal with mineral line style (dot, dashed, etc.)
                if line_i % 5 == 0:
                    if line_i != 0:
                        line_width += 0.5
                    line_i = 0

                    
                line_style = line_styles[line_i]
                    
                eoi = self.__get_elem_ox_of_interest_in_minerals(mineral)

                logK = self.__calc_dissrxn_logK(mineral, T, P)
                mineral_formula_dict = self.__get_mineral_elem_ox_dict_interest(mineral)

                xlab,ylab = self.__get_xy_labs(basis_species_x, basis_species_y)
                
                if len(eoi) == 1:

                    # if the element of interest is not in the current element pair, move on
                    if eoi[0] not in e_pair:
                        continue

                    if self.__get_elem_ox_of_interest_in_minerals(mineral)[0] == e_pair[0]:
                        # vertical line
                        x0, x1 = (1/mineral_formula_dict[e_pair[0]])*logK, (1/mineral_formula_dict[e_pair[0]])*logK
                        y0 = min(plot_y_range)
                        y1 = max(plot_y_range)
                        color = v_line_color
                        hovertemplate=mineral+&#39;&lt;br&gt;&#39;+xlab+&#39; = &#39;+str(round(x0, 3))
                    elif self.__get_elem_ox_of_interest_in_minerals(mineral)[0] == e_pair[1]:
                        # horizontal line
                        y0, y1 = (1/mineral_formula_dict[e_pair[1]])*logK, (1/mineral_formula_dict[e_pair[1]])*logK
                        x0 = min(plot_x_range)
                        x1 = max(plot_x_range)
                        color=h_line_color
                        hovertemplate=mineral+&#39;&lt;br&gt;&#39;+ylab+&#39; = &#39;+str(round(y0))

                if len(eoi) == 2:
                    
                    line_slope = mineral_formula_dict[e_pair[0]]/mineral_formula_dict[e_pair[1]]
                    
                    x0 = min(plot_x_range)
                    x1 = max(plot_x_range)
                    y0 = (1/mineral_formula_dict[e_pair[1]])*logK - line_slope*x0
                    y1 = (1/mineral_formula_dict[e_pair[1]])*logK - line_slope*x1
                    
                    intercept = (1/mineral_formula_dict[e_pair[1]])*logK
                    
                    color = d_line_color
                    
                    hovertemplate = mineral+&#39;&lt;br&gt;slope = &#39;+str(round(line_slope))+&#39;&lt;br&gt;intercept = &#39;+str(round(intercept))+&#39;&lt;extra&gt;&lt;/extra&gt;&#39;

                fig.add_trace(
                    go.Scatter(x=[x0, x1], y=[y0, y1], mode=&#34;lines&#34;,
                               name=mineral,
                               line=dict(color=color, width=line_width, dash=line_style),
                               hovertemplate=hovertemplate,
                              ),
                )
                
                line_i += 1
        
            fig = self.__add_reaction_path_to_plot(x_vals, y_vals, xi_vals, fig,
                                                   basis_species_x, basis_species_y,
                                                   path_margin=self.path_margin,
                                                   projected_points=projected_points,
                                                   path_line_type=path_line_type,
                                                   path_line_color=path_line_color,
                                                   path_point_fill_color=path_point_fill_color,
                                                   path_point_line_color=path_point_line_color,
                                                   projected_point_fill_color=projected_point_fill_color,
                                                   projected_point_line_color=projected_point_line_color)
        
        pred_minerals_from_lines = x_minerals_to_plot+y_minerals_to_plot+xy_minerals_to_plot
        return fig, pred_minerals_from_fields, pred_minerals_from_lines

    
    def __get_xlab_xvar(self, x_type):
    
        x_type_dict = {
            &#34;logxi&#34; : [&#34;log Xi&#34;, &#34;log Xi&#34;],
            &#34;xi&#34; : [&#34;Xi&#34;, &#34;Xi&#34;],
            &#34;temperature&#34; : [&#34;Temp(C)&#34;, &#34;Temperature, C&#34;],
            &#34;pressure&#34; : [&#34;Press(bars)&#34;, &#34;Pressure, bars&#34;],
            &#34;pH&#34; : [&#34;pH&#34;, &#34;pH&#34;],
            &#34;pmH&#34; : [&#34;pmH&#34;, &#34;pmH&#34;],
            &#34;logfO2&#34; : [&#34;log fO2&#34;, &#34;log &lt;i&gt;f&lt;/i&gt;O&lt;sub&gt;2&lt;/sub&gt;&#34;],
            &#34;Eh&#34; : [&#34;Eh(v)&#34;, &#34;Eh, volts&#34;],
            &#34;pe&#34; : [&#34;pe&#34;, &#34;pe&#34;],
            &#34;aw&#34; : [&#34;aw&#34;, &#34;aw&#34;],
        }
        
        if x_type not in x_type_dict.keys():
            self.err_handler.raise_exception((&#34;x_type must be set to either &#34;
                &#34;&#39;logxi&#39;, &#39;xi&#39;, &#39;temperature&#39;, &#39;pressure&#39;, &#39;pH&#39;, &#39;pmH&#39;,&#34;
                &#34;&#39;log fO2&#39;, &#39;Eh(v)&#39;, &#39;pe&#39;, or &#39;aw&#39;.&#34;))
        
        xvar = x_type_dict[x_type][0]
        xlab = x_type_dict[x_type][1]
            
        return xlab, xvar
    
    
    def plot_elements(self, plot_elements=None, units=&#34;molality&#34;, log=True,
                      x_type=&#34;logxi&#34;, plot_width=4, plot_height=3, ppi=122,
                      ylim=None, show_legend=True, charge_sign_at_end=False,
                      save_as=None, save_format=None, save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of the log activities of aqueous species as a
        function of the log of the extent of reaction (log Xi).
        
        Parameters
        ----------
        plot_elements : list of str, optional
            A list of elements to plot. If undefined, every element will be
            plotted at once.
        
        units : str, default &#34;molality&#34;
            Units of elemental abundance to plot. Can be &#34;molality&#34; or &#34;ppm&#34;.
        
        log : bool, default True
            Display elemental abundances in log scale?
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        ylim : list of two numeric values, optional
            Minimum and maximum value of the y-axis.
            
        show_legend : bool, default True
            Show the legend?
            
        charge_sign_at_end : bool, default False
            Display charge with sign after the number (e.g. SO4 2-)?
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        title = &#34;Concentrations of dissolved elements&#34;
        if units == &#34;molality&#34;:
            df = pd.concat([self.dissolved_elements_molal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;{}molality&#34;
        elif units == &#34;ppm&#34;:
            df = pd.concat([self.dissolved_elements_ppm, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;{}ppm&#34;
#             elif units == &#34;molarity&#34;:

        plot_columns = [col for col in df.columns]
        if isinstance(plot_elements, list):
            plot_columns_temp = [col for col in plot_columns if col in plot_elements]
            plot_columns = plot_columns_temp
            
        df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
        df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
        df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel, charge_sign_at_end=charge_sign_at_end)

        df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
            if log:
                df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
                ylab = ylab.format(&#34;log &#34;)
        if not log:
            ylab = ylab.format(&#34;&#34;)
        
        xlab, xvar = self.__get_xlab_xvar(x_type)

        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None,
                          showlegend=show_legend,
                          yaxis={&#39;showexponent&#39;: &#39;all&#39;,
                                 &#39;exponentformat&#39;: &#39;power&#39;},
                         )

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})
            
        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)

        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        return fig
    
    
    def plot_pH(self, x_type=&#34;logxi&#34;, show_neutrality=True, title=None,
                plot_width=4, plot_height=3, ppi=122, ylim=None, save_as=None,
                save_format=None, save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of pH as a function of the log of the extent of
        reaction (log Xi) or some other variable.
        
        Parameters
        ----------
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
        
        show_neutrality : bool, default True,
            Display a reference line representing neutral pH? Setting this
            option to True requires a thermodynamic database in a WORM-style CSV
            format, e.g., &#39;wrm_data.csv&#39;.
        
        title : str
            Title of the plot to display.
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        ylim : list of two numeric values, optional
            Minimum and maximum value of the y-axis.
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;

        df = copy.deepcopy(self.misc_params)
        
        xlab, xvar = self.__get_xlab_xvar(x_type)
        
        if x_type == &#34;logxi&#34;:
            with np.errstate(divide=&#39;ignore&#39;):
                df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])

        fig = px.line(df, x=xvar, y=&#34;pH&#34;, template=&#34;simple_white&#34;,
                      width=plot_width*ppi,  height=plot_height*ppi,
                      labels=dict(value=&#34;pH&#34;, x=xlab), render_mode=&#39;svg&#39;,
                      )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=&#34;pH&#34;,
                          showlegend=False)
        
        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
        
        if show_neutrality and isinstance(self.thermo.csv_db, pd.DataFrame):
            _, df_pH = self.plot_energy(species=[&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;],
                                        stoich=[-1, 1, 1],
                                        divisor=-2,
                                        x_type=x_type,
                                        y_type=&#34;logK&#34;,
                                        df_out=True,
                                        )
            
            fig.add_trace(go.Scatter(x=df_pH[xvar],
                                     y=df_pH[&#34;logK&#34;],
                                     mode=&#39;lines&#39;,
                                     name=&#39;neutral pH&#39;,
                                     showlegend=True,
                                     hovertemplate = xlab+&#39;: %{x}&lt;br&gt;pH: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                                     line=dict(color=&#39;silver&#39;,
                                               width=3,
                                               dash=&#39;dot&#39;)
                                    ))

            fig[&#39;data&#39;][0][&#39;showlegend&#39;]=True
            fig[&#39;data&#39;][0][&#39;name&#39;]=&#39;pH&#39;
            fig[&#39;data&#39;][1][&#39;showlegend&#39;]=True
            fig[&#39;data&#39;][1][&#39;name&#39;]=&#39;neutral pH&#39;
            fig.update_layout(showlegend=True)

            
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        return fig
    
    
    def plot_product_minerals(self, show_reactant_minerals=False,
                              plot_minerals=None, x_type=&#34;logxi&#34;, y_type=&#34;mole&#34;,
                              log_y=True, df_out=False, markers=False,
                              plot_width=4, plot_height=3, ppi=122, ylim=None,
                              show_legend=True, save_as=None, save_format=None,
                              save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of the log moles of product minerals as a
        function of the log of the extent of reaction (log Xi) or some other
        variable.
        
        Parameters
        ----------
        show_reactant_minerals : bool, default False
            Include log moles of reactant minerals?
            
        plot_minerals : list, optional
            List of minerals to plot. Useful for isolating one or more
            minerals.
            
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
            
        y_type : str, default &#39;mole&#39;
            The variable to plot on the y-axis. Can be either &#39;mole&#39; (for moles
            of minerals), &#39;mass&#39; (for masses of minerals), or &#39;volume&#39; (for
            volumes of minerals).
        
        log_y : bool, default True
            Should the y-axis be logarithmic?
            
        df_out : bool, default False
            Should a dataframe of values also be returned? For example, if
            `y_type` is set to &#39;volume&#39;, should a table of mineral volumes be
            returned?
            
        markers : bool, default True
            Add circular markers to lines to indicate calculation steps?
            
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        ylim : list of two numeric values, optional
            Minimum and maximum value of the y-axis.
            
        show_legend : bool, default True
            Show the legend?
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
            
        df : a Pandas dataframe
            A dataframe is only returned if `df_out` is set to True (it is
            set to False by default).
        
        &#34;&#34;&#34;
        
        xlab, xvar = self.__get_xlab_xvar(x_type)
        
        if show_reactant_minerals:
            df = pd.concat([self.moles_minerals, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            title = &#34;{} of reactant and product minerals&#34;
        else:
            df = pd.concat([self.moles_product_minerals, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            title = &#34;{} of product minerals&#34;
            
        if log_y:
            log_text = &#34;log &#34;
        else:
            log_text = &#34;&#34;

        # sort in order of appearance along Xi
        sort_order = list(self.moles_minerals.columns)
        
        sort_order = [v for v in sort_order if v not in self.misc_params.columns]
            
        if y_type == &#34;mole&#34;:
            ylab = &#34;{}moles&#34;.format(log_text)
            title = title.format(log_text, &#34;Moles&#34;)
        elif y_type == &#34;mass&#34;: # not yet supported
            y_lab = &#34;{}grams&#34;.format(log_text)
            title = title.format(log_text, &#34;Masses&#34;)
            self.err_handler.raise_exception(&#34;Plotting mineral masses is not yet &#34;
                    &#34;supported.&#34;)
        elif y_type == &#34;volume&#34;:
            ylab = &#34;{}cm&lt;sup&gt;3&lt;/sup&gt;&#34;.format(log_text)
            title = title.format(&#34;Volumes&#34;)
            temps = df[&#34;Temp(C)&#34;]
            
            minerals = [col for col in df.columns if col not in list(self.misc_params.columns)]

            for i,T in enumerate(temps):
                for ii,mineral in enumerate(minerals):
                    mineral_df = copy.deepcopy(self.df[self.df[&#34;name&#34;]==mineral])
                    polymorph_idxs = []
                    for iii in range(0, mineral_df.shape[0]): # loop through mineral polymorphs

                        if float(T) &lt; float(list(mineral_df[&#34;z.T&#34;])[0]):
                            polymorph_idxs.append(iii)
                    if len(polymorph_idxs)==0:
                        polymorph_idx = iii
                    else:
                        polymorph_idx = polymorph_idxs[0]


                    partial_molal_volume = list(mineral_df[&#34;V&#34;])[polymorph_idx]

                    df.at[i, mineral] = df[mineral][i]*partial_molal_volume
        else:
            self.err_handler.raise_exception(&#34;y_type must be either &#39;mole&#39;, &#34;
                        &#34;&#39;mass&#39;, or &#39;volume&#39;.&#34;)
            
        
        plot_columns = [col for col in df.columns if col not in list(self.misc_params.columns)]

        if isinstance(plot_minerals, list):
            plot_columns_temp = [col for col in plot_columns if col in plot_minerals]
            plot_columns = plot_columns_temp
            
        plot_columns = sorted(plot_columns, key=sort_order.index)
        
        df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
        df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
        
        df = df[df[&#34;variable&#34;] != &#34;None&#34;]

        df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
            if log_y:
                df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)
                df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])

        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                      width=plot_width*ppi,  height=plot_height*ppi, markers=markers,
                      labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                      )
        
        df_to_return = copy.deepcopy(df)
        
        # add lines that go to -9999 (representing -Inf) in log y plots
        if log_y:
            if not isinstance(ylim, list):
                # grab the automatic y-axis range from the plot, above
                full_fig = fig.full_figure_for_development(warn=False)
                ylim = list(full_fig.layout.yaxis.range)
                
            # add new rows
            for irow in range(0, df.shape[0]):
                if not isnan(df[&#34;value&#34;].iloc[irow]) and irow != 0 and irow != df.shape[0]-1:
                    if isnan(df[&#34;value&#34;].iloc[irow-1]):
                        
                        df_dict = {}
                        for col in list(self.misc_params.columns)+[&#34;log Xi&#34;]:
                            df_dict[col] = df.loc[irow-1, col]
                        df_dict[&#34;variable&#34;] = df.loc[irow-1, &#34;variable&#34;]
                        df_dict[&#34;value&#34;] = df.loc[irow-1, &#34;value&#34;]
                            
                        new_row = pd.DataFrame(df_dict, index=[irow-1])
                        df = pd.concat([df.iloc[:irow], new_row, df.iloc[irow:]]).reset_index(drop=True)
                        irow=0
                        
                    if isnan(df[&#34;value&#34;].iloc[irow+1]):
                        
                        df_dict = {}
                        for col in list(self.misc_params.columns)+[&#34;log Xi&#34;]:
                            df_dict[col] = df.loc[irow+1, col]
                        df_dict[&#34;variable&#34;] = df.loc[irow+1, &#34;variable&#34;]
                        df_dict[&#34;value&#34;] = df.loc[irow+1, &#34;value&#34;]
                        
                        new_row = pd.DataFrame(df_dict, index=[irow+1])
                        df = pd.concat([df.iloc[:irow], new_row, df.iloc[irow:]]).reset_index(drop=True)
                        irow=0
            
            # fill new rows with -9999 value
            for irow in range(0, df.shape[0]):
                if not isnan(df[&#34;value&#34;].iloc[irow]) and irow != 0 and irow != df.shape[0]-1:
                    if isnan(df[&#34;value&#34;].iloc[irow-1]):
                        df.loc[irow-1, &#34;value&#34;] = -9999
                    if isnan(df[&#34;value&#34;].iloc[irow+1]):
                        df.loc[irow+1, &#34;value&#34;] = -9999
                        
            # re-create the plot with log values down to -9999. This will screw up the
            # automatic y-axis range, but we grabbed it from the first generated plot.
            # We will reset the range in update_layout(yaxis_range) a little later.
            fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                          width=plot_width*ppi,  height=plot_height*ppi, markers=markers,
                          labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                          )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None,
                          showlegend=show_legend)
        
        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})
        
        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
        
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
        
        if df_out:
            df_to_return = pd.pivot_table(df_to_return, index=&#39;log Xi&#39;, columns=&#39;variable&#39;, values=&#39;value&#39;).reset_index()
            df_to_return.columns = [col for col in df_to_return.columns[:]] # make index column name blank
            return df_to_return, fig
        else:
            return fig

    
    def plot_aqueous_species(self, plot_basis=False, plot_species=None,
                             x_type=&#34;logxi&#34;, y_type=&#34;log activity&#34;,
                             initially_visible=None, show_legend=True,
                             charge_sign_at_end=False,
                             plot_width=4, plot_height=3, ppi=122, xlim=None,
                             ylim=None, save_as=None, save_format=None,
                             save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of the log activities of aqueous species as a
        function of the log of the extent of reaction (log Xi) or some other
        variable.
        
        Parameters
        ----------
        plot_basis : bool, default False
            Plot basis species only?
        
        plot_species : list of str, optional
            A list of aqueous species to plot. If undefined, every species at
            will be plotted at once.
        
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
        
        y_type : str, default &#39;log activity&#39;
            The variable to plot on the y-axis. Can be either &#39;log activity&#39;,
            &#39;molality&#39;, or &#39;log molality&#39;.
        
        initially_visible : list of str, optional
            A list of aqueous species that will be visible on the plot
            initially. All other species will be hidden, but can still be
            toggled back on in the legend.
        
        show_legend : bool, default True
            Show the legend?
        
        charge_sign_at_end : bool, default False
            Display charge with sign after the number (e.g. SO4 2-)?
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        xlim, ylim : list of two numeric values, optional
            Minimum and maximum value of the x-axis and y-axis, respectively.
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        if plot_basis:

            df = pd.concat([self.basis_logact, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            title = &#34;Solute basis species&#34;
            ylab = &#34;log activity&#34;

        else:
            if y_type == &#34;log activity&#34;:
                df = pd.concat([self.aq_distribution_logact, self.misc_params[self.misc_params.columns[1:]]], axis=1)
                ylab = &#34;log activity&#34;
            elif y_type == &#34;molality&#34;:
                df = pd.concat([self.aq_distribution_molal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
                ylab = &#34;molality&#34;
            elif y_type == &#34;log molality&#34;:
                df = pd.concat([self.aq_distribution_logmolal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
                ylab = &#34;log molality&#34;
            title = &#34;Solute species&#34;
            
        plot_columns = [col for col in df.columns]
        if isinstance(plot_species, list):
            plot_columns_temp = [col for col in plot_columns if col in plot_species]
            plot_columns = plot_columns_temp
            
        df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
        df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
        
        df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel, charge_sign_at_end=charge_sign_at_end)

        df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
        
        xlab, xvar = self.__get_xlab_xvar(x_type)
        
        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        if isinstance(initially_visible, list):
            initially_visible_html = [chemlabel(sp, charge_sign_at_end=charge_sign_at_end) for sp in initially_visible]
            for trace in fig[&#39;data&#39;]: 
                if (not trace[&#39;name&#39;] in initially_visible_html):
                    trace[&#39;showlegend&#39;] = True
                    trace[&#39;visible&#39;] = &#39;legendonly&#39;
        
        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None,
                          showlegend=show_legend)

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
            
        if isinstance(xlim, list):
            fig.update_layout(xaxis_range=xlim)
            
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        return fig

    
    def plot_energy(self, species, stoich,
                    divisor=1, x_type=&#34;logxi&#34;, y_type=&#34;A&#34;, y_units=&#34;kcal&#34;, 
                    show_zero_line=False, limiting=None, xlab=None, ylab=None,
                    title=None, charge_sign_at_end=False, log_y=False,
                    plot_width=4, plot_height=3, ppi=122,
                    xlim=None, ylim=None, df_out=False,
                    save_as=None, save_format=None,
                    save_scale=1, print_logK_messages=False):
        
        &#34;&#34;&#34;
        Generate a line plot of the energy profile for a reaction as a
        function of the log of the extent of reaction (log Xi) or some other
        variable.
        
        Parameters
        ----------
        species : list of str
            A list of species that match the order of the stoichiometric
            reaction coefficients in the `stoich` parameter.

        stoich : list of numeric
            A list of stoichiometric reaction coefficients that match the order
            of the species in the `species` parameter.
        
        divisor : float, default 1
            Divide all values in the energy profile by this number. Useful for
            calculating energy per electron transferred or similar.
        
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
        
        y_type : str, default &#39;A&#39;
            The variable to plot on the y-axis. Can be either &#39;A&#39; (for chemical
            affinity), &#39;G&#39; (for Gibbs free energy, G), &#39;logK&#39; (for the log
            of the equilibrium constant), &#39;logQ&#39; (for the log of the reaction
            quotient), or &#39;E&#39; for energy supply.
        
        y_units : str, default &#39;kcal&#39;
            The unit that energy will be reported in (per mol for G and A, or
            per kg fluid for energy supply, or unitless for logK and logQ).
            Can be &#39;kcal&#39;, &#39;cal&#39;, &#39;J&#39;, or &#39;kJ&#39;.
        
        show_zero_line : bool, default False
            If True, displays a dotted line where affinity or G equals 0 (at
            equilibrium).
        
        limiting : str, optional
            Name of the species to act as the limiting reactant when calculating
            energy supply. If this parameter is left undefined, then a
            limiting reactant will be chosen automatically based on
            concentration and stoichiometry. This parameter is ignored unless
            `y_type` is set to &#39;E&#39; (energy supply).
        
        xlab, ylab : str, optional
            Custom x and y axis labels.
        
        title : str, optional
            Title of the plot to display.
        
        charge_sign_at_end : bool, default False
            Display charge with sign after the number (e.g. SO4 2- instead of
            SO4-2) in species names when the reaction is displayed in the plot
            title?
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        xlim, ylim : list of two numeric values, optional
            Minimum and maximum value of the x-axis and y-axis, respectively.
            
        df_out = bool, default False
            Return a pandas dataframe in addition to a figure?
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        print_logK_messages : bool, default False
            Print pyCHNOSZ messages while the logK of the reaction is
            calculated?
            
        Returns
        -------
        fig : Plotly figure object, optionally a Pandas Dataframe
            A line plot. If `df_out` is True, also returns a dataframe.
        &#34;&#34;&#34;
        # check that a thermodynamic CSV is being used
        if not isinstance(self.thermo.csv_db, pd.DataFrame):
            self.err_handler.raise_exception(&#34;The plot_energy() function requires &#34;
                    &#34;a thermodynamic database in a WORM-style CSV format, e.g., &#34;
                    &#34;&#39;wrm_data.csv&#39;. You may be getting this message because &#34;
                    &#34;a data0 or data1 file was used.&#34;)
        
        # check that the divisor is valid
        if isinstance(divisor, list) or isinstance(divisor, pd.Series):
            if len(divisor) != len(self.misc_params[&#34;Temp(C)&#34;]):
                self.err_handler.raise_exception(&#34;The length of the divisor is &#34;
                    &#34;not equal to the number of reported xi steps.&#34;)

        # check that the reaction is balanced
        formulas = []
        for s in species:
            if s == &#34;H+&#34;:
                formulas.append(&#34;H+&#34;)
            elif s == &#34;H2O&#34;:
                formulas.append(&#34;H2O&#34;)
            else:
                if s in list(self.thermo.csv_db[&#34;name&#34;]):
                    formulas.append(list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;formula&#34;])[0])
                else:
                    self.err_handler.raise_exception(&#34;Valid thermodynamic data &#34;
                            &#34;was not found for species &#34;+str(s)+&#34;&#34;)
                    
        missing_composition = check_balance(formulas, stoich)
        
        
        # check that there are valid limiting reactants when calculating energy
        # e.g., prevent issue when the only reactant is a mineral, etc.
        reactant_idx = [1 if i&lt;0 else 0 for i in stoich]
        reactants = [species[i] for i,idx in enumerate(reactant_idx) if idx == 1]
        invalid_limiting_reactants = []
        for r in reactants:
            if r not in [&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;]:
                if list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==r][&#34;state&#34;])[0] != &#34;aq&#34;:
                    invalid_limiting_reactants.append(r)
            else:
                invalid_limiting_reactants.append(r)
        if reactants == invalid_limiting_reactants and y_type == &#34;E&#34;:
            self.err_handler.raise_exception(&#34;Energy supply for this reaction &#34;
                &#34;cannot be calculated because none of the reactants are &#34;
                &#34;limiting. A limiting reactant must be aqueous and cannot be H+ &#34;
                &#34;or OH-.&#34;)
        
        if limiting != None:
            # check that the limiting reactant is in the thermodynamic database
            if limiting not in list(self.thermo.csv_db[&#34;name&#34;]):
                self.err_handler.raise_exception(&#34;Valid thermodynamic data was &#34;
                        &#34;not found for limiting reactant &#34;+str(limiting)+&#34;&#34;)
            
            # check that the limiting reactant is aqueous or gaseous
            if list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==limiting][&#34;state&#34;])[0] != &#34;aq&#34;:
                self.err_handler.raise_exception(&#34;The limiting reactant must &#34;
                        &#34;be an aqueous species.&#34;)
            
            # check that the limiting reactant is a reactant in the `species` parameter
            if limiting not in reactants:
                self.err_handler.raise_exception(&#34;The species specified as a &#34;
                        &#34;limiting reactant, &#39;&#34;+str(limiting)+&#34;&#39;, is not a &#34;
                        &#34;reactant in this reaction.&#34;)
                
        # format reaction equation
        equation_to_display = format_equation(
                                      species,
                                      stoich,
                                      charge_sign_at_end=charge_sign_at_end,
                                      )
        
        # create a dictionary of species logacts across xi
        s_logact_dict = {}
        s_molal_dict = {}
        for s in species:
            if s == &#34;H+&#34;:
                s_logact_dict[s] = [-pH for pH in list(self.misc_params[&#34;pH&#34;])]
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;pH&#34;])
            elif s == &#34;H2O&#34;:
                s_logact_dict[s] = [0]*len(self.misc_params[&#34;Temp(C)&#34;])
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;Temp(C)&#34;])
            elif list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;state&#34;])[0] not in [&#34;cr&#34;, &#34;liq&#34;]:
                if s in self.aq_distribution_logact.columns:
                    # aqueous species
                    s_logact_dict[s] = list(self.aq_distribution_logact[s])
                    s_molal_dict[s] = list(self.aq_distribution_molal[s])
                else:
                    self.err_handler.raise_exception(&#34;The species &#34;+str(s)+&#34; is &#34;
                            &#34;not among the distribution of aqueous species in &#34;
                            &#34;this calculation.&#34;)
            else:
                # liq and cr species
                s_logact_dict[s] = [0]*len(self.misc_params[&#34;Temp(C)&#34;])
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;Temp(C)&#34;])
                
            
        xlab, xvar = self.__get_xlab_xvar(x_type)
            
        if y_type not in [&#34;logK&#34;, &#34;logQ&#34;]:
            if y_units in [&#34;cal&#34;, &#34;kcal&#34;]:
                r_div = 4.184
            elif y_units in [&#34;J&#34;, &#34;kJ&#34;]:
                r_div = 1
            R = 8.314/r_div  # gas constant, unit = [cal/mol/K]

        if &#34;k&#34; in y_units:
            k_div = 1000
        else:
            k_div = 1
            
        y_list = []
        lr_name_list = []
        for i,T in enumerate(list(self.misc_params[&#34;Temp(C)&#34;])):
            
            if isinstance(divisor, list):
                divisor_i = divisor[i]
            else:
                divisor_i = divisor
            
            if y_type != &#34;logQ&#34;:
                logK = pyCHNOSZ.subcrt(
                              species,
                              stoich,
                              T=T,
                              P=list(self.misc_params[&#34;Press(bars)&#34;])[i],
                              show=False,
                              messages=print_logK_messages).out[&#34;logK&#34;]

                logK = float(logK.iloc[0])

            if y_type == &#34;logK&#34;:
                ylab_out = &#34;log K&#34;
                if title == None:
                    title = &#34;Equilibrium constant for the reaction&lt;br&gt;&#34;+equation_to_display
                y_list.append(round(logK/divisor_i, 4))
                df_y_name = &#34;logK&#34;
                continue
                

            logQ = sum([st*s_logact_dict[sp][i] for st,sp in zip(stoich,species)])

            if y_type == &#34;logQ&#34;:
                ylab_out = &#34;log Q&#34;
                if title == None:
                    title = &#34;Reaction quotient for the reaction&lt;br&gt;&#34;+equation_to_display
                y_list.append(round(logQ/divisor_i, 4))
                df_y_name = &#34;logQ&#34;
                continue
            
            else:
                A = 2.303 * R * (273.15+T) * (logK - logQ)  # affinity, unit = [cal/mol]
                A = A/k_div
                
                if title == None:
                    title = &#34;Energy profile for the reaction&lt;br&gt;&#34;+equation_to_display
                
                if y_type==&#34;G&#34;:
                    G = -A # gibbs free energy, unit = [cal/mol]
                    y_list.append(G/divisor_i)
                    ylab_out=&#34;G, {}/mol&#34;.format(y_units)
                    y_units_out = y_units+&#34;/mol&#34;
                elif y_type==&#34;A&#34;:
                    y_list.append(round(A/divisor_i, 4))
                    ylab_out=&#34;A, {}/mol&#34;.format(y_units)
                    y_units_out = y_units+&#34;/mol&#34;
                elif y_type==&#34;E&#34;:
                    
                    if not isinstance(limiting, str):
                        lrc_dict = {}
                        for i_s,s in enumerate(species):
                            # identify valid limiting reactants and record concentrations
                            # 1. negative coefficient (reactant)
                            # 2. can&#39;t be OH-, H+, H2O
                            # 3. can&#39;t be cr or liq
                            if stoich[i_s] &lt; 0 and s not in [&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;] and list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;state&#34;])[0] not in [&#34;cr&#34;, &#34;liq&#34;]:
                                lrc_dict[s] = s_molal_dict[s][i]/abs(stoich[i_s])
                    
                    if not isinstance(limiting, str):
                        lr_name = min(lrc_dict, key=lrc_dict.get)
                        lr_val = lrc_dict[lr_name]
                        
                        # handle situations where there might be multiple limiting reactants
                        lr_list = []
                        for k,v in zip(lrc_dict.keys(), lrc_dict.values()):
                            if v == lr_val:
                                lr_list.append(str(k))
            
                    else:
                        lr_list = [limiting]
                        
                    lr_list_formatted = [chemlabel(lr_name, charge_sign_at_end=charge_sign_at_end) for lr_name in lr_list]
                    if len(lr_list_formatted) &gt; 1:
                        lr_reported = &#34;, &#34;.join(lr_list_formatted)
                    else:
                        lr_reported = lr_list[0]
                        
                    lr_name = lr_list[0] # doesn&#39;t matter which lr is used to calculate
                    lr_concentration = s_molal_dict[lr_name][i]
                    lr_name_list.append(lr_reported)
                    lr_stoich = -stoich[species.index(lr_name)]
                    E = A * (lr_concentration/lr_stoich)

                    y_list.append(round(E/divisor_i, 4))
                    y_units_out = y_units+&#34;/kg fluid&#34;
                    ylab_out=&#34;Energy Supply, {}&#34;.format(y_units+&#34;/kg fluid&#34;)
#                     else:
#                         lr_name_list.append(&#34;NA&#34;)
#                         y_list.append(float(&#39;NaN&#39;))
#                         y_units_out = y_units+&#34;/kg fluid&#34;
#                         ylab_out=&#34;Energy Supply, {}&#34;.format(y_units+&#34;/kg fluid&#34;)

                df_y_name = y_type+&#34;, &#34;+y_units_out

            
        if xlab != None:
            xlab_out = xlab
        if ylab != None:
            ylab_out = ylab

        df = copy.deepcopy(self.misc_params)
        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
            
        df[df_y_name] = y_list

        
        fig = px.line(df, x=xvar, y=df_y_name, log_y=log_y,
                      width=plot_width*ppi, height=plot_height*ppi,
                      template=&#34;simple_white&#34;)
        
        if y_type==&#34;E&#34;:
            fig.add_trace(
                go.Scatter(
                    x=df[xvar],
                    y=df[df_y_name],
                    mode=&#39;lines&#39;,
                    customdata = lr_name_list,
                    hovertemplate = xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab_out+&#39;: %{y}&lt;br&gt;Limiting : %{customdata}&lt;extra&gt;&lt;/extra&gt;&#39;,
                )
            )
            fig.data[0].visible=False
        
        fig.update_layout(xaxis_title=xlab_out,
                          yaxis_title=ylab_out)
        
        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
            
        if isinstance(xlim, list):
            fig.update_layout(xaxis_range=xlim)
            
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        if show_zero_line:
            fig.add_hline(y=0, line_width=3, line_dash=&#34;dash&#34;, line_color=&#34;black&#34;)
            
        if df_out:
            return fig, df
        else:
            return fig
    
    
    def plot_mass_contribution(self, *args, x_type=&#34;xi&#34;, x_decimals=3,
                                     track_steps=True, keep_xi_order=False,
                                     **kwargs):
        
        &#34;&#34;&#34;
        Generate a bar plot of mass contributions (in mole percent) of aqueous
        species formed as a function of reaction progress Xi or some other
        variable.
        
        Parameters
        ----------
        *args : iterable
            Arguments to be passed to `Speciation.plot_mass_contribution`.

        x_type : str, default &#34;xi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.

        x_decimals : int
            Number of decimals to display in the numeric values of the x-axis
            variable defined by `x_type`.

        track_steps : bool, default True
            Show reported xi steps on x-axis ticks? Useful for plotting as a
            function of an x-axis variable that can be out-of-order, like
            Eh or temperature. This parameter will become True automatically
            if it will prevent column stacking (which happens if there are
            duplicate x-axis values).

        **kargs : dict
            Keyword arguments to be passed to `Speciation.plot_mass_contribution`.
            
        Returns
        -------
        fig : Plotly figure object
            A mass contribution bar plot.
        &#34;&#34;&#34;
        
        basis = args[0]
        
        xlab, kwargs[&#34;sample_label&#34;] = self.__get_xlab_xvar(x_type)
        
        df_sp = pd.concat([self.mass_contribution_dict.get(basis, &#34;error&#34;),
                           self.misc_params[self.misc_params.columns[1:]]], axis=1)
        
        with np.errstate(divide=&#39;ignore&#39;):
            df_sp[&#39;log Xi&#39;] = np.log10(df_sp[&#39;Xi&#39;])
        
        # handle display of the x axis variable
        # if number of decimals to display is too low, columns will stack
        # check to see if this happens, then increment x_decimals until the stacking problem is solved
        if x_decimals &lt; 0:
            msg = &#34;The parameter x_decimals must be greater than or equal to 0.&#34;
            self.err_handler.raise_exception(msg)
        original_x_decimals = copy.copy(x_decimals)
        
        len_unique_labels_rounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x)))
        len_unique_labels_unrounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]]))
        
        if len_unique_labels_rounded &lt; len_unique_labels_unrounded:
            x_decimals += 1
            solved_decimals = False
            for i in range(x_decimals, x_decimals+10):
                len_unique_labels_rounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x)))
                if len_unique_labels_rounded == len_unique_labels_unrounded:
                    if self.verbose &gt; 0:
                        print(&#34;Number of decimals to display for x-axis variable&#34;,
                              &#34;increased to&#34;, x_decimals, &#34;to prevent column stacking.&#34;)
                    solved_decimals = True
                    break
                else:
                    x_decimals += 1
            if not solved_decimals:
                msg = (&#34;X-axis value decimal formatting is resulting in column &#34;
                       &#34;stacking even after attempting 10 increments of x_decimals.&#34;)
                self.err_handler.raise_exception(msg)

        if isinstance(df_sp, str):
            msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
                   &#34;among available basis species: &#34;
                   &#34;{}&#34;.format(str(list(self.mass_contribution_dict.keys()))))
            self.err_handler.raise_exception(msg)
        
        df_sp[&#34;position&#34;] = list(range(0, df_sp.shape[0]))
        
        df_sp_melt = df_sp.melt(
                id_vars=list(self.misc_params.columns)+[&#34;log Xi&#34;, &#34;basis&#34;, &#34;factor&#34;, &#34;molality&#34;, &#34;position&#34;])
        
        df_sp_melt.rename(columns={kwargs[&#34;sample_label&#34;] : &#34;sample&#34;,
                                   df_sp_melt.columns[-2] : &#34;species&#34;,
                                   df_sp_melt.columns[-1] : &#34;percent&#34;,
                                   }, inplace=True)
                                      
        df_sp_melt = df_sp_melt[df_sp_melt[&#39;percent&#39;].notna()]
        
        if keep_xi_order:
            sample_order = [&#34;position&#34;, &#34;species&#34;, &#34;percent&#34;]
        else:
            sample_order = [&#34;sample&#34;, &#34;position&#34;, &#34;species&#34;, &#34;percent&#34;]
            
        df_sp_melt.sort_values(sample_order, axis=0, ascending=True, inplace=True)

        if df_sp_melt.dtypes[&#34;sample&#34;] != &#34;O&#34;: # if the column isn&#39;t formatted as a string
            if any([&#34;e&#34; in v2 for v2 in [str(v1) for v1 in df_sp_melt[&#39;sample&#39;]]]): # if value is in scientific notation
                df_sp_melt[&#39;sample&#39;] = df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x) # converts numeric to string
            else:
                df_sp_melt[&#39;sample&#39;] = [(&#39;{0:.&#39;+str(x_decimals)+&#39;f}&#39;).format(v) for v in df_sp_melt[&#39;sample&#39;]]
            
            
        if len(list(set(df_sp_melt[&#34;sample&#34;]))) != len(list(set(df_sp_melt[&#34;position&#34;]))) or track_steps:
            # handle duplicate x-axis values to prevent stacking
            temp_col = []
            for i,v in enumerate(df_sp_melt[&#34;sample&#34;]):
                temp_col.append(&#34; (step &#34;+str(list(df_sp_melt[&#34;position&#34;])[i])+&#34;)&#34;)
            df_sp_melt[&#34;sample&#34;] = [str(v)+a for v,a in zip(df_sp_melt[&#34;sample&#34;], temp_col)]
            if not track_steps and self.verbose &gt; 0:
                print(&#34;Reported Xi step tracking has been added to x-axis ticks to prevent column stacking.&#34;)
            
        sp = Speciation(args={})
        sp.mass_contribution = df_sp_melt

        if not kwargs.get(&#34;plot_out&#34;, False):
            plot_out = False
        else:
            plot_out = True
        kwargs[&#34;plot_out&#34;] = True
        
        fig = sp.plot_mass_contribution(*args, **kwargs)
        
        fig.update_layout(
            xaxis_title=xlab, # add an x axis title
        )
        
        if plot_out:
            return fig
        else:
            fig.show()


template = &#34;&#34;&#34;|------------------------------------------------------------------------------|
| Main Title             | (utitl1(n))                                         |
|------------------------------------------------------------------------------|
|Sample: {{sample_name}}                                                         |
|Date created:  {date_created}                                       |
|EQ6 input file generated by AqEquil                                           |
|                                                                              |
|------------------------------------------------------------------------------|
|Temperature option (jtemp):                                                   |
|  [{t_checkbox_1}] ( 0) Constant temperature:                                              |
|             Value (C)         |{tval1}| (tempcb)                        |
|  [{t_checkbox_2}] ( 1) Linear tracking in Xi:                                             |
|             Base Value (C)    |{tval2}| (tempcb)                        |
|             Derivative        |{tval3}| (ttk(1))                        |
|  [{t_checkbox_3}] ( 2) Linear tracking in time:                                           |
|             Base Value (C)    |{tval4}| (tempcb)                        |
|             Derivative        |{tval5}| (ttk(1))                        |
|  [{t_checkbox_4}] ( 3) Fluid mixing tracking (fluid 2 = special reactant):                |
|             T of fluid 1 (C)  |{tval6}| (tempcb)                        |
|             T of fluid 2 (C)  |{tval7}| (ttk(2))                        |
|             Mass ratio factor |{tval8}| (ttk(1))                        |
|------------------------------------------------------------------------------|
|Pressure option (jpress):                                                     |
|  [{p_checkbox_1}] ( 0) Follow the data file reference pressure curve                      |
|  [{p_checkbox_2}] ( 1) Follow the 1.013-bar/steam-saturation curve                        |
|  [{p_checkbox_3}] ( 2) Constant pressure:                                                 |
|             Value (bars)      |{pval1}| (pressb)                        |
|  [{p_checkbox_4}] ( 3) Linear tracking in Xi:                                             |
|             Base Value (bars) |{pval2}| (pressb)                        |
|             Derivative        |{pval3}| (ptk(1))                        |
|  [{p_checkbox_5}] ( 4) Linear tracking in time:                                           |
|             Base Value (bars) |{pval4}| (pressb)                        |
|             Derivative        |{pval5}| (ptk(1))                        |
|------------------------------------------------------------------------------|
|Reactants (Irreversible Reactions) | (nrct)                                   |
|------------------------------------------------------------------------------|{reactant_blocks}
* Valid reactant type strings (urcjco(jcode(n))) are:                          *
*    Pure mineral                Solid solution                                *
*    Special reactant            Aqueous species                               *
*    Gas species                 Generic ion exchanger                         *
*------------------------------------------------------------------------------*
* Valid reactant status strings (urcjre(jreac(n))) are:                        *
*    Saturated, reacting         Reacting                                      *
*    Exhausted                   Saturated, not reacting                       *
*------------------------------------------------------------------------------*
* Valid forward rate law strings (urcnrk(nrk(1,n))) are:                       *
*    Use backward rate law       Relative rate equation                        *
*    TST rate equation           Linear rate equation                          *
*------------------------------------------------------------------------------*
* Valid backward rate law strings (urcnrk(nrk(2,n))) are:                      *
*    Use forward rate law        Partial equilibrium                           *
*    Relative rate equation      TST rate equation                             *
*    Linear rate equation                                                      *
*------------------------------------------------------------------------------*
|Starting, minimum, and maximum values of key run parameters.                  |
|------------------------------------------------------------------------------|
|Starting Xi value        |{start_xi}| (xistti)                              |
|------------------------------------------------------------------------------|
|Maximum Xi value         |{max_xi}| (ximaxi)                              |
|------------------------------------------------------------------------------|
|Starting time (seconds)  |{start_time}| (tistti)                              |
|------------------------------------------------------------------------------|
|Maximum time (seconds)   |{max_time}| (timmxi)                              |
|------------------------------------------------------------------------------|
|Minimum value of pH      |{min_pH}| (phmini)                              |
|------------------------------------------------------------------------------|
|Maximum value of pH      |{max_pH}| (phmaxi)                              |
|------------------------------------------------------------------------------|
|Minimum value of Eh (v)  |{min_Eh}| (ehmini)                              |
|------------------------------------------------------------------------------|
|Maximum value of Eh (v)  |{max_Eh}| (ehmaxi)                              |
|------------------------------------------------------------------------------|
|Minimum value of log fO2 |{min_fO2}| (o2mini)                              |
|------------------------------------------------------------------------------|
|Maximum value of log fO2 |{max_fO2}| (o2maxi)                              |
|------------------------------------------------------------------------------|
|Minimum value of aw      |{min_aw}| (awmini)                              |
|------------------------------------------------------------------------------|
|Maximum value of aw      |{max_aw}| (awmaxi)                              |
|------------------------------------------------------------------------------|
|Maximum number of steps  |{max_n_steps}| (kstpmx)                              |
|------------------------------------------------------------------------------|
|Print interval parameters.                                                    |
|------------------------------------------------------------------------------|
|Xi print interval        |{xi_print_int}| (dlxprn)                              |
|------------------------------------------------------------------------------|
|Log Xi print interval    |{log_xi_print_int}| (dlxprl)                              |
|------------------------------------------------------------------------------|
|Time print interval      |{time_print_int}| (dltprn)                              |
|------------------------------------------------------------------------------|
|Log time print interval  |{log_time_print_int}| (dltprl)                              |
|------------------------------------------------------------------------------|
|pH print interval        |{pH_print_interval}| (dlhprn)                              |
|------------------------------------------------------------------------------|
|Eh (v) print interval    |{Eh_print_interval}| (dleprn)                              |
|------------------------------------------------------------------------------|
|Log fO2 print interval   |{logfO2_print_interval}| (dloprn)                              |
|------------------------------------------------------------------------------|
|aw print interval        |{aw_print_interval}| (dlaprn)                              |
|------------------------------------------------------------------------------|
|Steps print interval     |{n_steps_print_interval}| (ksppmx)                              |
|------------------------------------------------------------------------------|
|Plot interval parameters.                                                     |
|------------------------------------------------------------------------------|
|Xi plot interval         | 1.00000E+38| (dlxplo)                              |
|------------------------------------------------------------------------------|
|Log Xi plot interval     | 1.00000E+38| (dlxpll)                              |
|------------------------------------------------------------------------------|
|Time plot interval       | 1.00000E+38| (dltplo)                              |
|------------------------------------------------------------------------------|
|Log time plot interval   | 1.00000E+38| (dltpll)                              |
|------------------------------------------------------------------------------|
|pH plot interval         | 1.00000E+38| (dlhplo)                              |
|------------------------------------------------------------------------------|
|Eh (v) plot interval     | 1.00000E+38| (dleplo)                              |
|------------------------------------------------------------------------------|
|Log fO2 plot interval    | 1.00000E+38| (dloplo)                              |
|------------------------------------------------------------------------------|
|aw plot interval         | 1.00000E+38| (dlaplo)                              |
|------------------------------------------------------------------------------|
|Steps plot interval      |       10000| (ksplmx)                              |
|------------------------------------------------------------------------------|
|Iopt Model Option Switches (&#34;( 0)&#34; marks default choices)                     |
|------------------------------------------------------------------------------|
|iopt(1) - Physical System Model Selection:                                    |
|  [{i1_checkbox_1}] ( 0) Closed system                                                      |
|  [{i1_checkbox_2}] ( 1) Titration system                                                   |
|  [{i1_checkbox_3}] ( 2) Fluid-centered flow-through open system                            |
|------------------------------------------------------------------------------|
|iopt(2) - Kinetic Mode Selection:                                             |
|  [{i2_checkbox_1}] ( 0) Reaction progress mode (arbitrary kinetics)                        |
|  [{i2_checkbox_2}] ( 1) Reaction progress/time mode (true kinetics)                        |
|------------------------------------------------------------------------------|
|iopt(3) - Phase Boundary Searches:                                            |
|  [{i3_checkbox_1}] ( 0) Search for phase boundaries and constrain the step size to match   |
|  [{i3_checkbox_2}] ( 1) Search for phase boundaries and print their locations              |
|  [{i3_checkbox_3}] ( 2) Don&#39;t search for phase boundaries                                  |
|------------------------------------------------------------------------------|
|iopt(4) - Solid Solutions:                                                    |
|  [{i4_checkbox_1}] ( 0) Ignore                                                             |
|  [{i4_checkbox_2}] ( 1) Permit                                                             |
|------------------------------------------------------------------------------|
|iopt(5) - Clear the ES Solids Read from the INPUT File:                       |
|  [{i5_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i5_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(6) - Clear the ES Solids at the Initial Value of Reaction Progress:      |
|  [{i6_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i6_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(7) - Clear the ES Solids at the End of the Run:                          |
|  [{i7_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i7_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(9) - Clear the PRS Solids Read from the INPUT file:                      |
|  [{i9_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i9_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(10) - Clear the PRS Solids at the End of the Run:                        |
|  [{i10_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i10_checkbox_2}] ( 1) Do it, unless numerical problems cause early termination           |
|------------------------------------------------------------------------------|
|iopt(11) - Auto Basis Switching in pre-N-R Optimization:                      |
|  [{i11_checkbox_1}] ( 0) Turn off                                                           |
|  [{i11_checkbox_2}] ( 1) Turn on                                                            |
|------------------------------------------------------------------------------|
|iopt(12) - Auto Basis Switching after Newton-Raphson Iteration:               |
|  [{i12_checkbox_1}] ( 0) Turn off                                                           |
|  [{i12_checkbox_2}] ( 1) Turn on                                                            |
|------------------------------------------------------------------------------|
|iopt(13) - Calculational Mode Selection:                                      |
|  [{i13_checkbox_1}] ( 0) Normal path tracing                                                |
|  [{i13_checkbox_2}] ( 1) Economy mode (if permissible)                                      |
|  [{i13_checkbox_3}] ( 2) Super economy mode (if permissible)                                |
|------------------------------------------------------------------------------|
|iopt(14) - ODE Integrator Corrector Mode Selection:                           |
|  [{i14_checkbox_1}] ( 0) Allow Stiff and Simple Correctors                                  |
|  [{i14_checkbox_2}] ( 1) Allow Only the Simple Corrector                                    |
|  [{i14_checkbox_3}] ( 2) Allow Only the Stiff Corrector                                     |
|  [{i14_checkbox_4}] ( 3) Allow No Correctors                                                |
|------------------------------------------------------------------------------|
|iopt(15) - Force the Suppression of All Redox Reactions:                      |
|  [{i15_checkbox_1}] ( 0) Don&#39;t do it                                                        |
|  [{i15_checkbox_2}] ( 1) Do it                                                              |
|------------------------------------------------------------------------------|
|iopt(16) - BACKUP File Options:                                               |
|  [ ] (-1) Don&#39;t write a BACKUP file                                          |
|  [x] ( 0) Write BACKUP files                                                 |
|  [ ] ( 1) Write a sequential BACKUP file                                     |
|------------------------------------------------------------------------------|
|iopt(17) - PICKUP File Options:                                               |
|  [ ] (-1) Don&#39;t write a PICKUP file                                          |
|  [x] ( 0) Write a PICKUP file                                                |
|------------------------------------------------------------------------------|
|iopt(18) - TAB File Options:                                                  |
|  [{i18_checkbox_1}] (-1) Don&#39;t write a TAB file                                             |
|  [{i18_checkbox_2}] ( 0) Write a TAB file                                                   |
|  [{i18_checkbox_3}] ( 1) Write a TAB file, prepending TABX file data from a previous run    |
|------------------------------------------------------------------------------|
|iopt(20) - Advanced EQ6 PICKUP File Options:                                  |
|  [{i20_checkbox_1}] ( 0) Write a normal EQ6 PICKUP file                                     |
|  [{i20_checkbox_2}] ( 1) Write an EQ6 INPUT file with Fluid 1 set up for fluid mixing       |
|------------------------------------------------------------------------------|
|Iopr Print Option Switches (&#34;( 0)&#34; marks default choices)                     |
|------------------------------------------------------------------------------|
|iopr(1) - Print All Species Read from the Data File:                          |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print                                                              |
|------------------------------------------------------------------------------|
|iopr(2) - Print All Reactions:                                                |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print the reactions                                                |
|  [ ] ( 2) Print the reactions and log K values                               |
|  [ ] ( 3) Print the reactions, log K values, and associated data             |
|------------------------------------------------------------------------------|
|iopr(3) - Print the Aqueous Species Hard Core Diameters:                      |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print                                                              |
|------------------------------------------------------------------------------|
|iopr(4) - Print a Table of Aqueous Species Concentrations, Activities, etc.:  |
|  [ ] (-3) Omit species with molalities &lt; 1.e-8                               |
|  [ ] (-2) Omit species with molalities &lt; 1.e-12                              |
|  [ ] (-1) Omit species with molalities &lt; 1.e-20                              |
|  [x] ( 0) Omit species with molalities &lt; 1.e-100                             |
|  [ ] ( 1) Include all species                                                |
|------------------------------------------------------------------------------|
|iopr(5) - Print a Table of Aqueous Species/H+ Activity Ratios:                |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print cation/H+ activity ratios only                               |
|  [ ] ( 2) Print cation/H+ and anion/H+ activity ratios                       |
|  [ ] ( 3) Print ion/H+ activity ratios and neutral species activities        |
|------------------------------------------------------------------------------|
|iopr(6) - Print a Table of Aqueous Mass Balance Percentages:                  |
|  [ ] (-1) Don&#39;t print                                                        |
|  [x] ( 0) Print those species comprising at least 99% of each mass balance   |
|  [ ] ( 1) Print all contributing species                                     |
|------------------------------------------------------------------------------|
|iopr(7) - Print Tables of Saturation Indices and Affinities:                  |
|  [ ] (-1) Don&#39;t print                                                        |
|  [x] ( 0) Print, omitting those phases undersaturated by more than 10 kcal   |
|  [ ] ( 1) Print for all phases                                               |
|------------------------------------------------------------------------------|
|iopr(8) - Print a Table of Fugacities:                                        |
|  [x] (-1) Don&#39;t print                                                        |
|  [ ] ( 0) Print                                                              |
|------------------------------------------------------------------------------|
|iopr(9) - Print a Table of Mean Molal Activity Coefficients:                  |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print                                                              |
|------------------------------------------------------------------------------|
|iopr(10) - Print a Tabulation of the Pitzer Interaction Coefficients:         |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print a summary tabulation                                         |
|  [ ] ( 2) Print a more detailed tabulation                                   |
|------------------------------------------------------------------------------|
|iopr(17) - PICKUP file format (&#34;W&#34; or &#34;D&#34;):                                   |
|  [x] ( 0) Use the format of the INPUT file                                   |
|  [ ] ( 1) Use &#34;W&#34; format                                                     |
|  [ ] ( 2) Use &#34;D&#34; format                                                     |
|------------------------------------------------------------------------------|
|Iodb Debugging Print Option Switches (&#34;( 0)&#34; marks default choices)           |
|------------------------------------------------------------------------------|
|iodb(1) - Print General Diagnostic Messages:                                  |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print Level 1 diagnostic messages                                  |
|  [ ] ( 2) Print Level 1 and Level 2 diagnostic messages                      |
|------------------------------------------------------------------------------|
|iodb(2) - Kinetics Related Diagnostic Messages:                               |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print Level 1 kinetics diagnostic messages                         |
|  [ ] ( 2) Print Level 1 and Level 2 kinetics diagnostic messages             |
|------------------------------------------------------------------------------|
|iodb(3) - Print Pre-Newton-Raphson Optimization Information:                  |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information (including the beta and del vectors)    |
|  [ ] ( 3) Print more detailed information (including matrix equations)       |
|  [ ] ( 4) Print most detailed information (including activity coefficients)  |
|------------------------------------------------------------------------------|
|iodb(4) - Print Newton-Raphson Iteration Information:                         |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information (including the beta and del vectors)    |
|  [ ] ( 3) Print more detailed information (including the Jacobian)           |
|  [ ] ( 4) Print most detailed information (including activity coefficients)  |
|------------------------------------------------------------------------------|
|iodb(5) - Print Step-Size and Order Selection:                                |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information                                         |
|------------------------------------------------------------------------------|
|iodb(6) - Print Details of Hypothetical Affinity Calculations:                |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information                                         |
|------------------------------------------------------------------------------|
|iodb(7) - Print General Search (e.g., for a phase boundary) Information:      |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|------------------------------------------------------------------------------|
|iodb(8) - Print ODE Corrector Iteration Information:                          |
|  [x] ( 0) Don&#39;t print                                                        |
|  [ ] ( 1) Print summary information                                          |
|  [ ] ( 2) Print detailed information (including the betar and delvcr vectors)|
|------------------------------------------------------------------------------|
|Mineral Sub-Set Selection Suppression Options | (nxopt)                       |
|------------------------------------------------------------------------------|
|Option  |Sub-Set Defining Species| (this is a table header)                   |
|------------------------------------------------------------------------------|{mineral_suppress_lines}
|------------------------------------------------------------------------------|
* Valid mineral sub-set selection suppression option strings (uxopt(n)) are:   *
*    None        All         Alwith      Allwith                               *
*------------------------------------------------------------------------------*
|Exceptions to the Mineral Sub-Set Selection Suppression Options | (nxopex)    |
|------------------------------------------------------------------------------|
|Mineral                 | (this is a table header)                            |
|------------------------------------------------------------------------------|
|None                    | (uxopex(n))                                         |
|------------------------------------------------------------------------------|
|Fixed Fugacity Options | (nffg)                                               |
|------------------------------------------------------------------------------|
|Gas                     |Moles to Add |Log Fugacity | --                      |
| (uffg(n))              | (moffg(n))  | (xlkffg(n)) | --                      |
|------------------------------------------------------------------------------|{gas_lines}
|------------------------------------------------------------------------------|
|Numerical Parameters                                                          |
|------------------------------------------------------------------------------|
|Max. finite-difference order               |{max_finite_difference_order}| (nordmx)            |
|Beta convergence tolerance                 |{beta_convergence_tolerance}| (tolbt)             |
|Del convergence tolerance                  |{del_convergence_tolerance}| (toldl)             |
|Max. No. of N-R iterations                 |{max_n_NR_iter}| (itermx)            |
|Search/find convergence tolerance          |{search_find_convergeance_tolerance}| (tolxsf)            |
|Saturation tolerance                       |{saturation_tolerance}| (tolsat)            |
|Max. No. of Phase Assemblage Tries         |{max_n_phase_assemblage_tries}| (ntrymx)            |
|Zero order step size (in Xi)               |{zero_order_step_size}| (dlxmx0)            |
|Max. interval in Xi between PRS transfers  |{max_interval_in_xi_between_PRS_transfers}| (dlxdmp)            |
|------------------------------------------------------------------------------|&#34;&#34;&#34;


rb_template = &#34;&#34;&#34;
|Reactant        |{reactant_name}| (ureac(n))                         |
|------------------------------------------------------------------------------|
|-&gt;|Type         |{reactant_type}| (urcjco(jcode(n)))                 |
|------------------------------------------------------------------------------|
|-&gt;|Status       |{reactant_status}| (urcjre(jreac(n)))                 |
|------------------------------------------------------------------------------|
|-&gt;|Amount remaining (moles) |{amount_remaining}| (morr(n))                          |
|------------------------------------------------------------------------------|
|-&gt;|Amount destroyed (moles) |{amount_destroyed}| (modr(n))                          |
|------------------------------------------------------------------------------|{sr_block}
|-&gt;|Surface area option (nsk(n)):                                              |
|-&gt;|  [{sa_checkbox_1}] ( 0) Constant surface area:                                          |
|-&gt;|             Value (cm2)       |{sa_val_1}| (sfcar(n))                   |
|-&gt;|  [{sa_checkbox_2}] ( 1) Constant specific surface area:                                 |
|-&gt;|             Value (cm2/g)     |{sa_val_2}| (ssfcar(n))                  |
|-&gt;|  [{sa_checkbox_3}] ( 2) n**2/3 growth law- current surface area:                        |
|-&gt;|             Value (cm2)       |{sa_val_3}| (sfcar(n))                   |
|------------------------------------------------------------------------------|
|-&gt;|Surface area factor      |{sa_factor}| (fkrc(n))                          |
|------------------------------------------------------------------------------|
|-&gt;|Forward rate law          |{f_rate_law}| (urcnrk(nrk(1,n)))    |
|------------------------------------------------------------------------------|{f_rate_block}
|-&gt;|Backward rate law         |{b_rate_law}| (urcnrk(nrk(2,n)))    |
|------------------------------------------------------------------------------|{b_rate_block}&#34;&#34;&#34;


relative_rate_equation_template = &#34;&#34;&#34;
|---&gt;|dXi(n)/dXi (mol/mol)      |{eq1}| (rkb(1,1,n))                    |
|------------------------------------------------------------------------------|
|---&gt;|d2Xi(n)/dXi2 (mol/mol2)   |{eq2}| (rkb(2,1,n))                    |
|------------------------------------------------------------------------------|
|---&gt;|d3Xi(n)/dXi3 (mol/mol3)   |{eq3}| (rkb(3,1,n))                    |
|------------------------------------------------------------------------------|&#34;&#34;&#34;

# not yet supported
TST_equation_template = &#34;&#34;&#34;
|---&gt;|Mechanism  1                                                             |
|------------------------------------------------------------------------------|
|-----&gt;|sigma(i,+,n)            |{eq1}| csigma(i,1,n)                   |
|------------------------------------------------------------------------------|
|-----&gt;|k(i,+,n) (mol/cm2/sec)  |{eq2}| rkb(i,1,n)                      |
|------------------------------------------------------------------------------|
|-----&gt;|Ref. Temperature (C)    |{eq3}| trkb(i,1,n)                     |
|------------------------------------------------------------------------------|
|-----&gt;|Temperature dependence option (iact(i,1,n)):                           |
|-----&gt;|  [{rate_checkbox_1}] ( 0) No temperature dependence                                   |
|-----&gt;|  [{rate_checkbox_2}] ( 1) Constant activation energy:                                 |
|-----&gt;|             Value (kcal/mol)  |{eq4}| (eact(i,1,n))            |
|-----&gt;|  [{rate_checkbox_3}] ( 2) Constant activation enthalpy:                               |
|-----&gt;|             Value (kcal/mol)  |{eq5}| (hact(i,1,n))            |
|------------------------------------------------------------------------------|
|-----&gt;|Kinetic activity product species (ndact(i,1,n))                        |
|------------------------------------------------------------------------------|
|-------&gt;|Species                                         |-N(j,i,+,n)         |
|-------&gt;| (udac(j,i,1,n))                                | (cdac(j,i,1,n))    |
|------------------------------------------------------------------------------|{k_act_prod_species_block}
|------------------------------------------------------------------------------|&#34;&#34;&#34;
# part of TST rate equation; not yet supported
k_act_prod_species_template = &#34;&#34;&#34;
|-------&gt;|{sp_name}}|{sp_N}|&#34;&#34;&#34;

gl_template = &#34;&#34;&#34;
|{gas_name}|{gas_moles}|{gas_log_fugacity}| --                      |&#34;&#34;&#34;

mineral_suppress_template = &#34;&#34;&#34;
|{mineral_suppress_option}|                        | (uxopt(n), uxcat(n))                       |&#34;&#34;&#34;

srb_template = &#34;&#34;&#34;
|-&gt;|Molar volume (cm3/mol)   |{molar_volume}| (vreac(n))                         |
|------------------------------------------------------------------------------|
|-&gt;|Composition                                                                |
|------------------------------------------------------------------------------|
|---&gt;|Element |Stoich. Number        | (this is a table header)                |
|------------------------------------------------------------------------------|{srb_stoich}
|------------------------------------------------------------------------------|
|-&gt;|Reaction                                                                   |
|------------------------------------------------------------------------------|
|---&gt;|Species                 |Reaction Coefficient  | (this is a table header)|
|------------------------------------------------------------------------------|
|------------------------------------------------------------------------------|&#34;&#34;&#34;

srb_stoich_template = &#34;&#34;&#34;
|---&gt;|{elem}|{elem_val}| (uesri(i,n), cesri(i,n))                |&#34;&#34;&#34;


class Mixing_Fluid:
    def __init__(self,
                 speciation,
                 sample_name,
                 amount_remaining=1,
                 amount_destroyed=0,
                 molar_volume=1,
                 mass_ratio=1,
                 hide_traceback=True,
                ):

        &#34;&#34;&#34;
        Class used to define the fluid to be mixed with other fluids in
        `Prepare_Reaction`.

        Parameters
        ----------
        speciation : object of class Speciation
            The speciation object containing the fluid to be mixed.

        sample_name : str
            The name of the fluid sample that will be mixed with all other
            speciated fluids.

        amount_remaining : float, default 1
            Number of moles of the fluid to be mixed with all others.

        amount_destroyed : float, default 0
            Number of moles of the mixing fluid that has been destroyed.

        molar_volume : float, default 1
            Molar volume of the mixing fluid, in moles/cm3.

        mass_ratio : float, default 1
            Ratio of mass of the mixing fluid to all other fluids.

        hide_traceback : bool, default True
            Hide traceback message when encountering errors handled by this
            class? When True, error messages handled by this class will be short
            and to the point.
            
        &#34;&#34;&#34;
        
        self.err_handler = Error_Handler(clean=hide_traceback)

        # Prepare a special reactant to be used in a mixing calculation.
        if isinstance(speciation, Speciation):
            
            self.sample_name = sample_name
            self.speciation_sample_data = speciation.sample_data[sample_name]
            self.T = self.speciation_sample_data[&#34;temperature&#34;]
            self.mass_ratio = mass_ratio
            
            elemental_composition_lines = []
            capture = False
            for i,line in enumerate(speciation.raw_3_pickup_dict_top[sample_name]):
                if &#34;|-&gt;|Composition&#34; in line:
                    capture = True
                    i_start = i
                if &#34;|-&gt;|Reaction&#34; in line:
                    capture = False
                if capture and i &gt; i_start + 3:
                    elemental_composition_lines.append(line)
            
            # ignore last line, which is a divider &#34;|----------...&#34;
            elemental_composition_lines = elemental_composition_lines[:-1]

            fluid_2_dict = {}
            for line in elemental_composition_lines:
                split_line = line.split(&#34;|&#34;)
                element = split_line[2].strip()
                value = float(split_line[3])
                fluid_2_dict[element] = value
            
            self.reactant = Reactant(reactant_name=&#34;Fluid 2&#34;,
                                     reactant_type=&#34;Special reactant&#34;,
                                     special_reactant_dict=fluid_2_dict,
                                     amount_remaining=amount_remaining,
                                     amount_destroyed=amount_destroyed,
                                     molar_volume=molar_volume,
                                     hide_traceback=hide_traceback)
            
            self.formatted_block = self.reactant.formatted_block
            self.reactant_type = &#34;Special reactant&#34;
            
        else:
            self.err_handler.raise_exception((&#34;The speciation parameter was&#34;
                    &#34; not given a Speciation object. A Speciation object is&#34;
                    &#34; produced by the AqEquil.speciate() function.&#34;))

        # handle fluid mixing reaction block

        lines_to_keep = self.formatted_block.split(&#34;\n&#34;)
        raw_p_dict_top = speciation.raw_3_pickup_dict_top

        # grab this fluid&#39;s reaction block
        reaction_block_lines = []
        capture = False
        for line in raw_p_dict_top[sample_name]:
            if &#34;|-&gt;|Reaction&#34; in line:
                capture = True
            if &#34;|-&gt;|Surface area&#34; in line:
                capture = False
            if capture:
                reaction_block_lines.append(line)

        # insert this fluid&#39;s reaction block
        before_lines = []
        after_lines = []
        is_before = True
        for i,line in enumerate(lines_to_keep):
            if &#34;|-&gt;|Reaction&#34; in line:
                is_before=False
            if is_before:
                before_lines.append(line)
            else:
                after_lines.append(line)

        # trim redundant lines
        after_lines = after_lines[5:]

        lines_to_keep = before_lines + reaction_block_lines + after_lines

        self.formatted_block = &#34;\n&#34;.join(lines_to_keep)

class Reactant:
    def __init__(self,
                 reactant_name,
                 reactant_type=&#34;Pure mineral&#34;,
                 reactant_status=&#34;Reacting&#34;,
                 amount_remaining=1,
                 amount_destroyed=0,
                 molar_volume=0,
                 surface_area_option=0,
                 surface_area_value=0,
                 surface_area_factor=0,
                 f_rate_law=&#34;Relative rate equation&#34;,
                 f_eq1=1,
                 f_eq2=0,
                 f_eq3=0,
                 b_rate_law=&#34;Partial equilibrium&#34;,
                 b_eq1=1,
                 b_eq2=0,
                 b_eq3=0,
                 special_reactant_dict={},
                 hide_traceback=True,
                 ):
        
        &#34;&#34;&#34;
        Class used to define reactants for `Prepare_Reaction`.

        Parameters
        ----------
        reactant_name : str
            Name of the reactant.

        reactant_type : str, default &#34;Pure mineral&#34;
            Reactant type. Valid types include
            - Pure mineral
            - Solid solution
            - Special reactant
            - Aqueous species
            - Gas species
            - Generic ion exchanger

        reactant_status : str, default &#34;Reacting&#34;
            Status of the reactant. Valid statuses include
            - Reacting
            - Saturated, reacting
            - Exhausted
            - Saturated, not reacting

        amount_remaining : float, default 1
            Moles of reactant remaining.

        amount_destroyed : float, default 0
            Moles of reactant destroyed.

        surface_area_option : int, default 0
            Option for reactant surface area. Valid options include:
            - 0, for Constant surface area (in cm2)
            - 1, for Constant specific surface area (in cm2/g). Surface area
            changes in proportion to the reactant mass.
            - 2, for n**2/3 growth law- current surface area (in cm2)

        surface_area_value : float, default 0
            Value assigned to choice of surface area option.
            - If `surface_area_option` is 0, value is in cm2.
            - If `surface_area_option` is 1, value is in cm2/g.
            - If `surface_area_option` is 2, value is in cm2.

        surface_area_factor : float, default 0
            Value assigned to surface area factor.

        f_rate_law : str, default &#34;Relative rate equation&#34;
            Type of forward rate law. Valid types include
            - Use backward rate law
            - Relative rate equation
            The TST rate equation is not yet supported.

        f_eq1, f_eq2, f_eq3 : float, default 1, 0, 0, respectively
            Coefficients of the forward rate law defined for `f_rate_law`.
            If `f_rate_law` is &#34;Relative rate equation&#34;, then:
            - f_eq1 is dXi(n)/dXi (mol/mol)
            - f_eq2 is d2Xi(n)/dXi2 (mol/mol2)
            - f_eq3 is d3Xi(n)/dXi3 (mol/mol3)

        b_rate_law : str, default &#34;Partial equilibrium&#34;
            Type of backward rate law. Valid types include
            - Use forward rate law
            - Partial equilibrium
            - Relative rate equation
            The TST rate equation is not yet supported.
            
        b_eq1, b_eq2, b_eq3 : float, default 1, 0, 0, respectively
            Coefficients of the backward rate law defined for `b_rate_law`.
            If `b_rate_law` is &#34;Relative rate equation&#34;, then:
            - the value of b_eq1 represents dXi(n)/dXi (mol/mol)
            - the value of b_eq2 represents d2Xi(n)/dXi2 (mol/mol2)
            - the value of b_eq3 represents d3Xi(n)/dXi3 (mol/mol3)
        
        hide_traceback : bool, default True
            Hide traceback message when encountering errors handled by this class?
            When True, error messages handled by this class will be short and to
            the point.

        &#34;&#34;&#34;
    
        self.err_handler = Error_Handler(clean=hide_traceback)
        
        if f_rate_law not in [&#34;Use backward rate law&#34;, &#34;Relative rate equation&#34;]:
            self.err_handler.raise_exception((&#34;f_rate_law must be either &#34;
                    &#34;&#39;Use backward rate law&#39; or &#39;Relative rate equation&#39;.&#34;))
        if b_rate_law not in [&#34;Use forward rate law&#34;, &#34;Partial equilibrium&#34;, &#34;Relative rate equation&#34;]:
            self.err_handler.raise_exception((&#34;b_rate_law must be either &#34;
                    &#34;&#39;Use forward rate law&#39;, &#39;Partial equilibrium&#39;, or &#39;Relative rate equation&#39;.&#34;))
        
        self.reactant_name=reactant_name
        self.reactant_type=reactant_type
        self.reactant_status=reactant_status
        self.amount_remaining=amount_remaining
        self.amount_destroyed=amount_destroyed
        self.molar_volume=molar_volume
        self.sa_val_1=0
        self.sa_val_2=0
        self.sa_val_3=0
        self.sa_checkbox_1= &#34; &#34;
        self.sa_checkbox_2= &#34; &#34;
        self.sa_checkbox_3= &#34; &#34;
        
        self.special_reactant_dict=special_reactant_dict
        
        if surface_area_option == 0:
            self.sa_checkbox_1 = &#34;x&#34;
            self.sa_val_1 = surface_area_value
        elif surface_area_option == 1:
            self.sa_checkbox_2 = &#34;x&#34;
            self.sa_val_2 = surface_area_value
        elif surface_area_option == 2:
            self.sa_checkbox_3 = &#34;x&#34;
            self.sa_val_3 = surface_area_value
        self.sa_factor=surface_area_factor
        
        self.f_rate_law=f_rate_law
        self.f_eq1=f_eq1
        self.f_eq2=f_eq2
        self.f_eq3=f_eq3
        self.b_rate_law=b_rate_law
        self.b_eq1=b_eq1
        self.b_eq2=b_eq2
        self.b_eq3=b_eq3
        
        self.__format_rate_block(&#34;forward&#34;)
        self.__format_rate_block(&#34;backward&#34;)

        self.__format_block()


    def __format_block(self):
        
        rb_dict_formatted = dict(
                reactant_name = f&#34;{self.reactant_name:&lt;24}&#34;,
                reactant_type = f&#34;{self.reactant_type:&lt;24}&#34;,
                reactant_status = f&#34;{self.reactant_status:&lt;24}&#34;,
                amount_remaining = f&#34;{&#39;{:.5E}&#39;.format(self.amount_remaining):&gt;12}&#34;,
                amount_destroyed = f&#34;{&#39;{:.5E}&#39;.format(self.amount_destroyed):&gt;12}&#34;,
                sa_checkbox_1 = self.sa_checkbox_1,
                sa_checkbox_2 = self.sa_checkbox_2,
                sa_checkbox_3 = self.sa_checkbox_3,
                sa_val_1 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_1):&gt;12}&#34;,
                sa_val_2 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_2):&gt;12}&#34;,
                sa_val_3 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_3):&gt;12}&#34;,
                sa_factor = f&#34;{&#39;{:.5E}&#39;.format(self.sa_factor):&gt;12}&#34;,
                f_rate_law = f&#34;{self.f_rate_law:&lt;24}&#34;,
                b_rate_law = f&#34;{self.b_rate_law:&lt;24}&#34;,
                f_rate_block = self.formatted_f_rate_block,
                b_rate_block = self.formatted_b_rate_block,
                )

        if self.reactant_type.lower() == &#34;special reactant&#34;:
            elem_lines = []
            for key in list(self.special_reactant_dict.keys()):
                sp_elem_line = copy.copy(srb_stoich_template)
                elem_name = f&#34;{str(key):&lt;8}&#34;
                elem_value = f&#34;{&#39;{:.15E}&#39;.format(float(self.special_reactant_dict[key])):&gt;22}&#34;
                sp_elem_line = sp_elem_line.format(**{&#34;elem&#34;:elem_name, &#34;elem_val&#34;:elem_value})
                elem_lines.append(sp_elem_line)
            elem_lines = &#34;&#34;.join(elem_lines)
            
            srb_dict_formatted = dict(
                    molar_volume = f&#34;{&#39;{:.5E}&#39;.format(self.molar_volume):&gt;12}&#34;,
                    srb_stoich = elem_lines,
                    )
            
            sp_reactant_block_template = copy.copy(srb_template)
            sp_reactant_block_formatted = sp_reactant_block_template.format(**srb_dict_formatted)
            rb_dict_formatted[&#34;sr_block&#34;] = sp_reactant_block_formatted
        else:
            rb_dict_formatted[&#34;sr_block&#34;] = &#34;&#34;
   
        reactant_block_template = copy.copy(rb_template)
        self.formatted_block = reactant_block_template.format(**rb_dict_formatted)
    
    def __format_rate_block(self, direction):
        if direction == &#34;forward&#34;:
            d=&#34;f&#34;
            od=&#34;b&#34;
            odirection=&#34;backward&#34;
        else:
            d=&#34;b&#34;
            od=&#34;f&#34;
            odirection=&#34;forward&#34;

        eq1 = getattr(self, d+&#34;_eq1&#34;)
        eq2 = getattr(self, d+&#34;_eq2&#34;)
        eq3 = getattr(self, d+&#34;_eq3&#34;)

        if getattr(self, d+&#34;_rate_law&#34;) == &#34;Relative rate equation&#34;:
            rate_block = copy.deepcopy(relative_rate_equation_template)
            
            rate_options_formatted = dict(
                eq1=f&#34;{&#39;{:.5E}&#39;.format(eq1):&gt;12}&#34;,
                eq2=f&#34;{&#39;{:.5E}&#39;.format(eq2):&gt;12}&#34;,
                eq3=f&#34;{&#39;{:.5E}&#39;.format(eq3):&gt;12}&#34;,
            )
            
            rate_block = rate_block.format(**rate_options_formatted)
            setattr(self, &#34;formatted_&#34;+d+&#34;_rate_block&#34;, rate_block)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;Linear rate equation&#34;:
            # Note: &#34;Linear rate equation&#34; is valid in EQ6, but I cannot find any
            # EQ6 input files formatted for this option. My guess is that linear
            # rate equations can be imposed by only specifying the first parameter
            # of a relative rate equation.
            self.err_handler.raise_exception(&#34;The &#39;Linear rate equation&#39; option is not supported at this time.&#34;)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;TST rate equation&#34;:
            self.err_handler.raise_exception(&#34;TST rate equations are not supported at this time.&#34;)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;Partial equilibrium&#34;:
            setattr(self, &#34;formatted_&#34;+d+&#34;_rate_block&#34;, &#34;&#34;)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;Use backward rate law&#34;:
            setattr(self, &#34;formatted_&#34;+d+&#34;_rate_block&#34;, &#34;&#34;)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;Use forward rate law&#34;:
            setattr(self, &#34;formatted_&#34;+d+&#34;_rate_block&#34;, &#34;&#34;)
        else:
            msg = (&#34;Valid rate laws for the &#34;+direction+&#34; rate law includes &#34;
                &#34;&#39;Relative rate equation&#39;, &#39;TST rate equation&#39;, &#34;
                &#34;&#39;Linear rate equation&#39;, or &#39;Use &#34;+odirection+&#34; rate law&#39;&#34;)
            self.err_handler.raise_exception(msg)

class Gas:
    def __init__(self,
                 gas_name=&#34;None&#34;,
                 gas_moles=0,
                 gas_log_fugacity=0,
                ):
        
        &#34;&#34;&#34;
        Class used to define gases for `Prepare_Reaction`.

        Parameters
        ----------
        gas_name : str, default &#34;None&#34;
            Name of the gas.
        
        gas_moles : float, default 0
            Moles of gas.
        
        gas_log_fugacity : float, default 0
            The log10 fugacity of the gas.

        &#34;&#34;&#34;
        
        self.gas_name=gas_name
        self.gas_moles=gas_moles
        self.gas_log_fugacity=gas_log_fugacity
        
        self.__format_line()
        
    def __format_line(self):
        
        gas_options_formatted = dict(
            gas_name = f&#34;{self.gas_name:&lt;24}&#34;,
            gas_moles = f&#34;{&#39;{:.5E}&#39;.format(self.gas_moles):&gt;13}&#34;,
            gas_log_fugacity = f&#34;{&#39;{:.5E}&#39;.format(self.gas_log_fugacity):&gt;13}&#34;,
        )
    
        gas_line_template = copy.copy(gl_template)
        self.formatted_line = gas_line_template.format(**gas_options_formatted)
        

class Prepare_Reaction:
    def __init__(self,
                 reactants,
                 gases=[],
                 t_option=None,
                 t_value_1=None, # temp
                 t_value_2=None,  # temp or deriv
                 t_value_3=None,  # mass ratio factor
                 p_option=0,
                 p_value_1=None,  # pressure
                 p_value_2=0,  # deriv
                 xi_range=[0, 1],
                 time_range=[0, 1e38],
                 pH_range=[-1e38, 1e38],
                 Eh_range=[-1e38, 1e38],
                 fO2_range=[-1e38, 1e38],
                 aw_range=[-1e38, 1e38],
                 max_n_steps=900,
                 xi_print_int=1,
                 log_xi_print_int=1,
                 time_print_int=1e38,
                 log_time_print_int=1e38,
                 pH_print_interval=1e38,
                 Eh_print_interval=1e38,
                 logfO2_print_interval=1e38,
                 aw_print_interval=1e38,
                 n_steps_print_interval=100,
                 physical_system_model=&#34;closed&#34;,
                 kinetic_mode=&#34;arbitrary&#34;,
                 phase_boundary_search=0,
                 permit_solid_solutions=False,
                 clear_es_solids_read=False,
                 clear_es_solids_initial=False,
                 clear_es_solids_end=False,
                 clear_prs_solids_read=False,
                 clear_prs_solids_end=False,
                 auto_basis_switching_pre_NR=False,
                 auto_basis_switching_post_NR=False,
                 calc_mode_selection=0,
                 ODE_corrector_mode=0,
                 mineral_suppression_option=&#34;None&#34;,
                 write_tab=-1, # do not write a TAB file by default because EQ6 can encounter an access violation when writing a TAB file
                 fluid_mixing_setup=False,
                 max_finite_difference_order=6,
                 beta_convergence_tolerance=0,
                 del_convergence_tolerance=0,
                 max_n_NR_iter=500,
                 search_find_convergeance_tolerance=0,
                 saturation_tolerance=0,
                 max_n_phase_assemblage_tries=0,
                 zero_order_step_size=0,
                 max_interval_in_xi_between_PRS_transfers=0,
                 filename=None,
                 hide_traceback=True,
                ):
        
        &#34;&#34;&#34;
        Class used to set the parameters of a reaction between the results of a
        speciation calculation and minerals, gases, etc.

        Parameters
        ----------
         reactants : list
             List of reactants defined by the &#39;Reactant&#39; class. Can be an empty
             list if no reactants are desired.
             
         gases : list, default []
             List of gases defined by the &#39;Gas&#39; class. Can be an empty
             list if no gases are desired.
         
         t_option : int, default 0
             Desired option for handling temperature of the reaction. Valid
             choices include:
             - 0 for constant temperature
             - 1 for linear tracking in Xi
             - 2 for linear tracking in time
             Fluid mixing tracking is not yet supported.
         
         t_value_1, t_value_2, t_value_3 P: default None, 0, 0, respectively
             By default, the temperature of samples in the speciation
             calculation will be used, so the user does not need to specify
             temperature values here. However, if a user wishes, temperature
             values can be defined here that will be applied to all samples in
             the speciation. Note that doing so may result in incongruous
             results. That said, the values specified here depend on which
             option is selected for `t_option`:
             - If &#39;t_option&#39; is 0, then t_value_1 is the value of the constant
             temperature (in degrees C), and t_value_2 and t_value_3 are ignored.
             - If &#39;t_option&#39; is 1, then t_value_1 is the base value
             temperature (in degrees C), t_value_2 is the derivative, and
             t_value_3 is ignored.
             - If &#39;t_option&#39; is 2, then t_value_1 is the base value
             temperature (in degrees C), t_value_2 is the derivative, and
             t_value_3 is ignored.
         
         p_option : int, default 0
             Desired option for handling pressure of the reaction. Valid
             choices include:
             - 0 to follow the data file reference pressure curve
             - 1 to follow the 1.013-bar/steam-saturation curve
             - 2 for constant pressure
             - 3 for linear tracking in Xi
             - 4 for linear tracking in time
         
         p_value_1, p_value_2 : float default None, 0
             Values assigned to desired `p_option`.
             - If `p_option` is 0 or 1, p_value_1 and p_value_2 are ignored.
             - If `p_option` is 2, p_value_1 represents a constant pressure,
             in bars, and p_value_2 is ignored.
             - If `p_option` is 3 or 4, p_value_1 represents the base pressure
             value, in bars, and p_value_2 is the derivative.
         
         xi_range : list of two float, default [0, 1]
             A list containing the starting and maximum value of Xi,
             respectively.
         
         time_range : list of two float, default [0, 1e38]
             A list containing the starting and maximum time, respectively.
         
         pH_range : list of two float, default [-1e38, 1e38]
             A list containing the minimum and maximum values of pH.
         
         Eh_range : list of two float, default [-1e38, 1e38]
             A list containing the minimum and maximum values of Eh.
         
         fO2_range : list of two float, default [-1e38, 1e38]
             A list containing the minimum and maximum values of the fugacity
             of oxygen, fO2.
         
         aw_range : list of two float, default [-1e38, 1e38]
             A list containing the minimum and maximum values of water activity.
         
         max_n_steps : int, default 900
             Maximum number of steps of Xi allowed.
         
         xi_print_int : int, default 1
             Xi print interval.
         
         log_xi_print_int : int, default 1
             Log Xi print interval.
         
         time_print_int : int, default 1e38
             Time print interval.
         
         log_time_print_int : int, default 1e38
             Log time print interval.
         
         pH_print_interval : int, default 1e38
             pH print interval.
         
         Eh_print_interval : int, default 1e38
             Eh (v) print interval.
         
         logfO2_print_interval : int, default 1e38
             Log fO2 print interval.
         
         aw_print_interval : int, default 1e38
             Activity of water (aw) print interval.
         
         n_steps_print_interval : int, default 100
             Steps print interval.

        physical_system_model : str, default &#34;closed&#34;
            Selection for the physical system model. Valid options include:
            - &#34;closed&#34;
            - &#34;titration&#34;
            - &#34;fluid-centered flow-through open&#34;
        
        kinetic_mode : str, default &#34;arbitrary&#34;
            Selection for kinetic mode. Valid options include:
            - &#34;arbitrary&#34; for arbitrary kinetics, reaction progress mode
            - &#34;true&#34; for true kinetics, reaction progress/time mode 
         
        phase_boundary_search : int, default 0
            Selection for phase boundary searches. Valid options include:
            - 0 to search for phase boundaries and constrain the step size to
            match.
            - 1 to search for phase boundaries and print their locations.
            - 2 to not search for phase boundaries.
        
        permit_solid_solutions : bool, default False
            Permit solid solutions? If False, solid solutions are ignored.
        
        clear_es_solids_read : bool, default False
            Clear the ES solids read from the input file?
        
        clear_es_solids_initial : bool, default False
            Clear the ES solids at the initial value of reaction progress?
        
        clear_es_solids_end : bool, default False
            Clear the ES solids at the end of the run?
        
        clear_prs_solids_read : bool, default False
            Clear the PRS solids read from the input file?
        
        clear_prs_solids_end : bool, default False
            Clear the PRS solids at the end of the run? If True, PRS solids will
            be cleared unless numerical problems cause early termination.
        
        auto_basis_switching_pre_NR : bool, default False
            Turn on auto basis switching in pre-Newton-Raphson optimization?
        
        auto_basis_switching_post_NR : bool, default False
            Turn on auto basis switching after Newton-Raphson iteration?
        
        calc_mode_selection : int, default 0
            Calculational mode selection. Valid options include:
            - 0 for normal path tracing
            - 1 for economy mode (if permissible)
            - 2 for super economy mode (if permissible)
        
        ODE_corrector_mode : int, default 0
            ODE integrator corrector mode selection. Valid options include:
            - 0 to allow stiff and simple correctors
            - 1 to allow only simple corrector
            - 2 to allow only stiff corrector
            - 3 to allow no correctors
        
        mineral_suppression_option : str, default &#34;None&#34;
            Option to suppress formation of minerals. Can be either &#34;None&#34; (no
            minerals are suppressed) or &#34;All&#34; (all minerals are suppressed).
        
        write_tab : int, default -1
            Option to write a TAB file. Valid options include:
            - -1 do not write a TAB file (default)
            - 0 write a TAB file
            - 1 write a TAB file prepending TABX file data from a previous run
        
        fluid_mixing_setup : bool, default False
            If True, will write an EQ6 input file with Fluid 1 set up for
            fluid mixing. If False, a normal EQ6 pickup file will be written.
         
         max_finite_difference_order : int, default 6
             Maximum finite-difference order (numerical parameter).
         
         beta_convergence_tolerance : float, default 0
             Beta convergence tolerance (numerical parameter).
         
         del_convergence_tolerance : float, default 0
             Delta convergence tolerance (numerical parameter).
         
         max_n_NR_iter : int, default 500
             Maximum number of N-R iterations (numerical parameter).
         
         search_find_convergeance_tolerance : float, default 0
             Search/find convergence tolerance (numerical parameter).
         
         saturation_tolerance : float, default 0
             Saturation tolerance (numerical parameter).
         
         max_n_phase_assemblage_tries : int, default 0
             Maximum number of phase assemblage tries (numerical parameter).
         
         zero_order_step_size : int, default 0
             Zero order step size in Xi (numerical parameter).
         
         max_interval_in_xi_between_PRS_transfers : int, default 0
             Maximum interval in Xi between PRS transfers (numerical parameter).
         
         filename : str, default None
             Filename where the results of `Prepare_Reaction` will be written.
             This is equivalent to the top half of an EQ3/6 6i file. If None,
             no file will be written.
             
        hide_traceback : bool, default True
            Hide traceback message when encountering errors handled by this class?
            When True, error messages handled by this class will be short and to
            the point.

        &#34;&#34;&#34;
        
        self.err_handler = Error_Handler(clean=hide_traceback)
        
        if len(reactants) == 1 and not isinstance(reactants, list):
            reactants = list(reactants)
            
        if len(gases) == 0:
            gases = [Gas()]
        elif len(gases) == 1 and not isinstance(gases, list):
            gases = list(gases)
        
        self.reactants=reactants
        self.gases=gases
        self.t_option=t_option
        self.t_value_1=t_value_1
        self.t_value_2=t_value_2
        self.t_value_3=t_value_3
        self.p_option=p_option
        self.p_value_1=p_value_1
        self.p_value_2=p_value_2
        self.start_xi=xi_range[0]
        self.max_xi=xi_range[1]
        self.start_time=time_range[0]
        self.max_time=time_range[1]
        self.min_pH=pH_range[0]
        self.max_pH=pH_range[1]
        self.min_Eh=Eh_range[0]
        self.max_Eh=Eh_range[1]
        self.min_fO2=fO2_range[0]
        self.max_fO2=fO2_range[1]
        self.min_aw=aw_range[0]
        self.max_aw=aw_range[1]
        self.max_n_steps=max_n_steps
        self.xi_print_int=xi_print_int
        self.log_xi_print_int=log_xi_print_int
        self.time_print_int=time_print_int
        self.log_time_print_int=log_time_print_int
        self.pH_print_interval=pH_print_interval
        self.Eh_print_interval=Eh_print_interval
        self.logfO2_print_interval=logfO2_print_interval
        self.aw_print_interval=aw_print_interval
        self.n_steps_print_interval=n_steps_print_interval
        self.max_finite_difference_order=max_finite_difference_order
        self.beta_convergence_tolerance=beta_convergence_tolerance
        self.del_convergence_tolerance=del_convergence_tolerance
        self.max_n_NR_iter=max_n_NR_iter
        self.search_find_convergeance_tolerance=search_find_convergeance_tolerance
        self.saturation_tolerance=saturation_tolerance
        self.max_n_phase_assemblage_tries=max_n_phase_assemblage_tries
        self.zero_order_step_size=zero_order_step_size
        self.max_interval_in_xi_between_PRS_transfers=max_interval_in_xi_between_PRS_transfers
        self.mineral_suppression_option=mineral_suppression_option
        
        self.t_checkbox_1=&#34; &#34;
        self.t_checkbox_2=&#34; &#34;
        self.t_checkbox_3=&#34; &#34;
        self.t_checkbox_4=&#34; &#34;
        self.tval1=0
        self.tval2=0
        self.tval3=0
        self.tval4=0
        self.tval5=0
        self.tval6=0
        self.tval7=0
        self.tval8=0
        self.p_checkbox_1=&#34; &#34;
        self.p_checkbox_2=&#34; &#34;
        self.p_checkbox_3=&#34; &#34;
        self.p_checkbox_4=&#34; &#34;
        self.p_checkbox_5=&#34; &#34;
        self.pval1=0
        self.pval2=0
        self.pval3=0
        self.pval4=0
        self.pval5=0
        self.i1_checkbox_1 = &#34; &#34;
        self.i1_checkbox_2 = &#34; &#34;
        self.i1_checkbox_3 = &#34; &#34;
        self.i2_checkbox_1 = &#34; &#34;
        self.i2_checkbox_2 = &#34; &#34;
        self.i3_checkbox_1 = &#34; &#34;
        self.i3_checkbox_2 = &#34; &#34;
        self.i3_checkbox_3 = &#34; &#34;
        self.i4_checkbox_1 = &#34; &#34;
        self.i4_checkbox_2 = &#34; &#34;
        self.i5_checkbox_1 = &#34; &#34;
        self.i5_checkbox_2 = &#34; &#34;
        self.i6_checkbox_1 = &#34; &#34;
        self.i6_checkbox_2 = &#34; &#34;
        self.i7_checkbox_1 = &#34; &#34;
        self.i7_checkbox_2 = &#34; &#34;
        self.i9_checkbox_1 = &#34; &#34;
        self.i9_checkbox_2 = &#34; &#34;
        self.i10_checkbox_1 = &#34; &#34;
        self.i10_checkbox_2 = &#34; &#34;
        self.i11_checkbox_1 = &#34; &#34;
        self.i11_checkbox_2 = &#34; &#34;
        self.i12_checkbox_1 = &#34; &#34;
        self.i12_checkbox_2 = &#34; &#34;
        self.i13_checkbox_1 = &#34; &#34;
        self.i13_checkbox_2 = &#34; &#34;
        self.i13_checkbox_3 = &#34; &#34;
        self.i14_checkbox_1 = &#34; &#34;
        self.i14_checkbox_2 = &#34; &#34;
        self.i14_checkbox_3 = &#34; &#34;
        self.i14_checkbox_4 = &#34; &#34;
        self.i15_checkbox_1 = &#34; &#34;
        self.i15_checkbox_2 = &#34; &#34;
        self.i18_checkbox_1 = &#34; &#34;
        self.i18_checkbox_2 = &#34; &#34;
        self.i18_checkbox_3 = &#34; &#34;
        self.i20_checkbox_1 = &#34; &#34;
        self.i20_checkbox_2 = &#34; &#34;
        
        tval_var_to_format = None
        pval_var_to_format = None
        
        # set t_option and t_value defaults when there is a mixing calculation
        n_mixing_fluid_reactants=0
        for reactant in reactants:
            if isinstance(reactant, Mixing_Fluid):
                n_mixing_fluid_reactants += 1
                if t_option == None:
                    t_option = 3
                    self.t_option=t_option
                if t_value_1 == None:
                    t_value_1 = None # will be formatted with temp of fluid 1 later
                    self.t_value_1=t_value_1
                if t_value_2 == None:
                    t_value_2 = float(reactant.T) # temp of fluid 2
                    self.t_value_2=t_value_2
                if t_value_3 == None:
                    t_value_3 = reactant.mass_ratio # mass ratio factor
                    self.t_value_3=t_value_3
                
        if n_mixing_fluid_reactants == 0:
            # set t_option and t_value defaults when there is no mixing calculation
            if t_option == None:
                t_option = 0
                self.t_option = 0
#             if t_value_1 == None:
#                 t_value_1 = None
#                 self.t_value_1 = 0
#             if t_value_2 == None:
#                 t_value_2 = 0
#                 self.t_value_2 = 0
#             if t_value_3 == None:
#                 t_value_3 = 0
#                 self.t_value_3 = 0
        elif n_mixing_fluid_reactants == 1:
            pass
        else:
            self.err_handler.raise_exception((&#34;&#34;
                    &#34;There are {} mixing fluids &#34;.format(n_mixing_fluid_reactants)+&#34;&#34;
                    &#34;in the list of reactants. There may only be one.&#34;))
        if t_option == 0:
            self.t_checkbox_1=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval1=t_value_1
            else:
                tval_var_to_format = 1

        elif t_option == 1:
            self.t_checkbox_2=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval2=t_value_1
                self.tval3=t_value_2
            else:
                tval_var_to_format = 2

        elif t_option == 2:
            self.t_checkbox_3=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval4=t_value_1
                self.tval5=t_value_2
            else:
                tval_var_to_format = 4
                
        elif t_option == 3:
            self.t_checkbox_4=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval6=t_value_1
                self.tval7=t_value_2
                self.tval8=t_value_3
            else:
                self.tval7=t_value_2
                self.tval8=t_value_3
                tval_var_to_format = 6
        else:
            raise Exception(&#34;t_option must be 0, 1, 2, or 3.&#34;)
            
        if p_option == 0:
            self.p_checkbox_1=&#34;x&#34;

        elif p_option == 1:
            self.p_checkbox_2=&#34;x&#34;

        elif p_option == 2:
            self.p_checkbox_3=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval1=p_value_1
            else:
                pval_var_to_format = 1
                
        elif p_option == 3:
            self.p_checkbox_4=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval2=p_value_1
                self.pval3=p_value_2
            else:
                pval_var_to_format = 2
                
        elif p_option == 4:
            self.p_checkbox_5=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval4=p_value_1
                self.pval5=p_value_2
            else:
                pval_var_to_format = 4

        else:
            raise Exception(&#34;p_option must be 0, 1, 2, 3, or 4.&#34;)
        
        
        if physical_system_model == &#34;closed&#34;:
            self.i1_checkbox_1 = &#34;x&#34;
        elif physical_system_model == &#34;titration&#34;:
            self.i1_checkbox_2 = &#34;x&#34;
        elif physical_system_model == &#34;fluid-centered flow-through open&#34;:
            self.i1_checkbox_3 = &#34;x&#34;
        else:
            msg = (&#34;physical_system_model must either be &#39;closed&#39;, &#39;titration&#39;,&#34;
                &#34; or &#39;fluid-centered flow-through open&#39;.&#34;)
            self.err_handler.raise_exception(msg)

        if kinetic_mode == &#34;arbitrary&#34;:
            self.i2_checkbox_1 = &#34;x&#34;
        elif kinetic_mode == &#34;true&#34;:
            self.i2_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;kinetic_mode must either be &#39;arbitrary&#39; or &#39;true&#39;.&#34;
            self.err_handler.raise_exception(msg)
        
        if phase_boundary_search == 0:
            self.i3_checkbox_1 = &#34;x&#34;
        elif phase_boundary_search == 1:
            self.i3_checkbox_2 = &#34;x&#34;
        elif phase_boundary_search == 2:
            self.i3_checkbox_3 = &#34;x&#34;
        else:
            msg = &#34;phase_boundary_search must be 0, 1, or 2.&#34;
            self.err_handler.raise_exception(msg)
            
        if permit_solid_solutions == False:
            self.i4_checkbox_1 = &#34;x&#34;
        elif permit_solid_solutions == True:
            self.i4_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;permit_solid_solutions must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if clear_es_solids_read == False:
            self.i5_checkbox_1 = &#34;x&#34;
        elif clear_es_solids_read == True:
            self.i5_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_es_solids_read must be True or False.&#34;
            self.err_handler.raise_exception(msg)

        if clear_es_solids_initial == False:
            self.i6_checkbox_1 = &#34;x&#34;
        elif clear_es_solids_initial == True:
            self.i6_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_es_solids_initial must be True or False.&#34;
            self.err_handler.raise_exception(msg)

        if clear_es_solids_end == False:
            self.i7_checkbox_1 = &#34;x&#34;
        elif clear_es_solids_end == True:
            self.i7_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_es_solids_end must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        # there is no iopt8
            
        if clear_prs_solids_read == False:
            self.i9_checkbox_1 = &#34;x&#34;
        elif clear_prs_solids_read == True:
            self.i9_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_prs_solids_read must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if clear_prs_solids_end == False:
            self.i10_checkbox_1 = &#34;x&#34;
        elif clear_prs_solids_end == True:
            self.i10_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_prs_solids_end must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if auto_basis_switching_pre_NR == False:
            self.i11_checkbox_1 = &#34;x&#34;
        elif auto_basis_switching_pre_NR == True:
            self.i11_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;auto_basis_switching_pre_NR must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if auto_basis_switching_post_NR == False:
            self.i12_checkbox_1 = &#34;x&#34;
        elif auto_basis_switching_post_NR == True:
            self.i12_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;auto_basis_switching_post_NR must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if calc_mode_selection == 0:
            self.i13_checkbox_1 = &#34;x&#34;
        elif calc_mode_selection == 1:
            self.i13_checkbox_2 = &#34;x&#34;
        elif calc_mode_selection == 2:
            self.i13_checkbox_3 = &#34;x&#34;
        else:
            msg = &#34;calc_mode_selection must be 0, 1, or 2.&#34;
            self.err_handler.raise_exception(msg)

        if ODE_corrector_mode == 0:
            self.i14_checkbox_1 = &#34;x&#34;
        elif ODE_corrector_mode == 1:
            self.i14_checkbox_2 = &#34;x&#34;
        elif ODE_corrector_mode == 2:
            self.i14_checkbox_3 = &#34;x&#34;
        elif ODE_corrector_mode == 3:
            self.i14_checkbox_4 = &#34;x&#34;
        else:
            msg = &#34;ODE_corrector_mode must be 0, 1, or 2.&#34;
            self.err_handler.raise_exception(msg)

        # The suppress redox option in EQ6 doesn&#39;t work with WORM data.
        # Use redox-isolated elements from the redox suppression
        # option in the AqEquil class instead.
        self.i15_checkbox_1 = &#34;x&#34;

        if write_tab == -1:
            self.i18_checkbox_1 = &#34;x&#34;
        elif write_tab == 0:
            self.i18_checkbox_2 = &#34;x&#34;
        elif write_tab == 1:
            self.i18_checkbox_3 = &#34;x&#34;
        else:
            self.err_handler.raise_exception(&#34;write_tab_option must be -1, 0, &#34;
                    &#34;or 1.&#34;)
            
        
        if fluid_mixing_setup == False:
            self.i20_checkbox_1 = &#34;x&#34;
        elif fluid_mixing_setup == True:
            self.i20_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;fluid_mixing_setup must be True or False.&#34;
            self.err_handler.raise_exception(msg)

        now = datetime.now()
        self.date_created = now.strftime(&#39;%Y-%m-%d %I:%M %p&#39;)
        
        self.__format_reaction(tval_var_to_format, pval_var_to_format)
        
        if filename != None:
            with open(filename, &#39;w&#39;) as f:
                f.write(pr.formatted_reaction)
        
        
    def __format_reaction(self, tval_var_to_format=None, pval_var_to_format=None):
        reaction_options_formatted = dict(
            date_created=f&#34;{self.date_created:&lt;24}&#34;,
            start_xi=f&#34;{&#39;{:.5E}&#39;.format(self.start_xi):&gt;12}&#34;,
            max_xi=f&#34;{&#39;{:.5E}&#39;.format(self.max_xi):&gt;12}&#34;,
            start_time=f&#34;{&#39;{:.5E}&#39;.format(self.start_time):&gt;12}&#34;,
            max_time=f&#34;{&#39;{:.5E}&#39;.format(self.max_time):&gt;12}&#34;,
            min_pH=f&#34;{&#39;{:.5E}&#39;.format(self.min_pH):&gt;12}&#34;,
            max_pH=f&#34;{&#39;{:.5E}&#39;.format(self.max_pH):&gt;12}&#34;,
            min_Eh=f&#34;{&#39;{:.5E}&#39;.format(self.min_Eh):&gt;12}&#34;,
            max_Eh=f&#34;{&#39;{:.5E}&#39;.format(self.max_Eh):&gt;12}&#34;,
            min_fO2=f&#34;{&#39;{:.5E}&#39;.format(self.min_fO2):&gt;12}&#34;,
            max_fO2=f&#34;{&#39;{:.5E}&#39;.format(self.max_fO2):&gt;12}&#34;,
            min_aw=f&#34;{&#39;{:.5E}&#39;.format(self.min_aw):&gt;12}&#34;,
            max_aw=f&#34;{&#39;{:.5E}&#39;.format(self.max_aw):&gt;12}&#34;,
            max_n_steps=f&#34;{self.max_n_steps:&gt;12}&#34;,
            xi_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.xi_print_int):&gt;12}&#34;,
            log_xi_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.log_xi_print_int):&gt;12}&#34;,
            time_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.time_print_int):&gt;12}&#34;,
            log_time_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.log_time_print_int):&gt;12}&#34;,
            pH_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.pH_print_interval):&gt;12}&#34;,
            Eh_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.Eh_print_interval):&gt;12}&#34;,
            logfO2_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.logfO2_print_interval):&gt;12}&#34;,
            aw_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.aw_print_interval):&gt;12}&#34;,
            n_steps_print_interval=f&#34;{self.n_steps_print_interval:&gt;12}&#34;,
            max_finite_difference_order=f&#34;{self.max_finite_difference_order:&gt;12}&#34;,
            beta_convergence_tolerance=f&#34;{self.beta_convergence_tolerance:&gt;12}&#34;,
            del_convergence_tolerance=f&#34;{self.del_convergence_tolerance:&gt;12}&#34;,
            max_n_NR_iter=f&#34;{self.max_n_NR_iter:&gt;12}&#34;,
            search_find_convergeance_tolerance=f&#34;{self.search_find_convergeance_tolerance:&gt;12}&#34;,
            saturation_tolerance=f&#34;{self.saturation_tolerance:&gt;12}&#34;,
            max_n_phase_assemblage_tries=f&#34;{self.max_n_phase_assemblage_tries:&gt;12}&#34;,
            zero_order_step_size=f&#34;{self.zero_order_step_size:&gt;12}&#34;,
            max_interval_in_xi_between_PRS_transfers=f&#34;{self.max_interval_in_xi_between_PRS_transfers:&gt;12}&#34;,
            t_checkbox_1=self.t_checkbox_1,
            t_checkbox_2=self.t_checkbox_2,
            t_checkbox_3=self.t_checkbox_3,
            t_checkbox_4=self.t_checkbox_4,
            p_checkbox_1=self.p_checkbox_1,
            p_checkbox_2=self.p_checkbox_2,
            p_checkbox_3=self.p_checkbox_3,
            p_checkbox_4=self.p_checkbox_4,
            p_checkbox_5=self.p_checkbox_5,
            i1_checkbox_1=self.i1_checkbox_1,
            i1_checkbox_2=self.i1_checkbox_2,
            i1_checkbox_3=self.i1_checkbox_3,
            i2_checkbox_1=self.i2_checkbox_1,
            i2_checkbox_2=self.i2_checkbox_2,
            i3_checkbox_1=self.i3_checkbox_1,
            i3_checkbox_2=self.i3_checkbox_2,
            i3_checkbox_3=self.i3_checkbox_3,
            i4_checkbox_1=self.i4_checkbox_1,
            i4_checkbox_2=self.i4_checkbox_2,
            i5_checkbox_1=self.i5_checkbox_1,
            i5_checkbox_2=self.i5_checkbox_2,
            i6_checkbox_1=self.i6_checkbox_1,
            i6_checkbox_2=self.i6_checkbox_2,
            i7_checkbox_1=self.i7_checkbox_1,
            i7_checkbox_2=self.i7_checkbox_2,
            i9_checkbox_1=self.i9_checkbox_1,
            i9_checkbox_2=self.i9_checkbox_2,
            i10_checkbox_1=self.i10_checkbox_1,
            i10_checkbox_2=self.i10_checkbox_2,
            i11_checkbox_1=self.i11_checkbox_1,
            i11_checkbox_2=self.i11_checkbox_2,
            i12_checkbox_1=self.i12_checkbox_1,
            i12_checkbox_2=self.i12_checkbox_2,
            i13_checkbox_1=self.i13_checkbox_1,
            i13_checkbox_2=self.i13_checkbox_2,
            i13_checkbox_3=self.i13_checkbox_3,
            i14_checkbox_1=self.i14_checkbox_1,
            i14_checkbox_2=self.i14_checkbox_2,
            i14_checkbox_3=self.i14_checkbox_3,
            i14_checkbox_4=self.i14_checkbox_4,
            i15_checkbox_1=self.i15_checkbox_1,
            i15_checkbox_2=self.i15_checkbox_2,
            i18_checkbox_1=self.i18_checkbox_1,
            i18_checkbox_2=self.i18_checkbox_2,
            i18_checkbox_3=self.i18_checkbox_3,
            i20_checkbox_1=self.i20_checkbox_1,
            i20_checkbox_2=self.i20_checkbox_2,
        )
        
        # leave {tval1} (or {tval2}, {tval3}...) in pre_6i file so it can be updated after joining 3p
        if tval_var_to_format != None:
            reaction_options_formatted[&#34;tval&#34;+str(tval_var_to_format)] = &#34;{tval}&#34;
            for i in range(1, 9):
                if i == tval_var_to_format:
                    continue
                else:
                    reaction_options_formatted[&#34;tval&#34;+str(i)]=f&#34;{&#39;{:.5E}&#39;.format(getattr(self, &#39;tval&#39;+str(i))):&gt;12}&#34;
        else:
            reaction_options_formatted.update(dict(
                tval1=f&#34;{&#39;{:.5E}&#39;.format(self.tval1):&gt;12}&#34;,
                tval2=f&#34;{&#39;{:.5E}&#39;.format(self.tval2):&gt;12}&#34;,
                tval3=f&#34;{&#39;{:.5E}&#39;.format(self.tval3):&gt;12}&#34;,
                tval4=f&#34;{&#39;{:.5E}&#39;.format(self.tval4):&gt;12}&#34;,
                tval5=f&#34;{&#39;{:.5E}&#39;.format(self.tval5):&gt;12}&#34;,
                tval6=f&#34;{&#39;{:.5E}&#39;.format(self.tval6):&gt;12}&#34;,
                tval7=f&#34;{&#39;{:.5E}&#39;.format(self.tval7):&gt;12}&#34;,
                tval8=f&#34;{&#39;{:.5E}&#39;.format(self.tval8):&gt;12}&#34;,
            ))
            
        # leave {pval1} (or {pval2}, {pval3}...) in pre_6i file so it can be updated after joining 3p
        if pval_var_to_format != None:
            reaction_options_formatted[&#34;pval&#34;+str(pval_var_to_format)] = &#34;{pval}&#34;
            for i in range(1, 6):
                if i == pval_var_to_format:
                    continue
                else:
                    reaction_options_formatted[&#34;pval&#34;+str(i)]=f&#34;{&#39;{:.5E}&#39;.format(getattr(self, &#39;pval&#39;+str(i))):&gt;12}&#34;
        else:
            reaction_options_formatted.update(dict(
                pval1=f&#34;{&#39;{:.5E}&#39;.format(self.pval1):&gt;12}&#34;,
                pval2=f&#34;{&#39;{:.5E}&#39;.format(self.pval2):&gt;12}&#34;,
                pval3=f&#34;{&#39;{:.5E}&#39;.format(self.pval3):&gt;12}&#34;,
                pval4=f&#34;{&#39;{:.5E}&#39;.format(self.pval4):&gt;12}&#34;,
                pval5=f&#34;{&#39;{:.5E}&#39;.format(self.pval5):&gt;12}&#34;,
            ))

        
        reactant_blocks = &#34;&#34;.join([r.formatted_block for r in self.reactants])
        gas_lines = &#34;&#34;.join([r.formatted_line for r in self.gases])
        reaction_options_formatted.update(dict(reactant_blocks=reactant_blocks))
        reaction_options_formatted.update(dict(gas_lines=gas_lines))
        
        if self.mineral_suppression_option == &#34;None&#34;:
            mineral_suppress_option_value = &#34;None    &#34;
        elif self.mineral_suppression_option == &#34;All&#34;:
            mineral_suppress_option_value = &#34;All     &#34;
        else:
            msg = (&#34;Error in Prepare_Reaction(): `mineral_suppression_option` &#34;
                   &#34;must be &#39;None&#39; or &#39;All&#39;.&#34;)
            self.err_handler.raise_exception(msg)
            
        min_supp_temp = copy.copy(mineral_suppress_template)
        min_supp_dict = dict(mineral_suppress_option=mineral_suppress_option_value)
        min_supp_temp = min_supp_temp.format(**min_supp_dict)
        
        reaction_options_formatted.update(
                dict(mineral_suppress_lines=min_supp_temp)
                )
        
        reaction_template = copy.copy(template)
        self.formatted_reaction = reaction_template.format(**reaction_options_formatted)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="AqEquil.MassTransfer.join_mixes"><code class="name flex">
<span>def <span class="ident">join_mixes</span></span>(<span>m1, m2)</span>
</code></dt>
<dd>
<div class="desc"><p>Join the results of two mixes, m1 and m2, so that results extend from
1:0 to 0:1 m1:m2.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m1</code></strong>, <strong><code>m2</code></strong> :&ensp;<code>objects</code> of <code>class <a title="AqEquil.MassTransfer.Mass_Transfer" href="#AqEquil.MassTransfer.Mass_Transfer">Mass_Transfer</a></code></dt>
<dd>The mass transfer results of two mixing calculations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An object of class <code><a title="AqEquil.MassTransfer.Mass_Transfer" href="#AqEquil.MassTransfer.Mass_Transfer">Mass_Transfer</a></code> with results joined for plotting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_mixes(m1, m2):
    &#34;&#34;&#34;
    Join the results of two mixes, m1 and m2, so that results extend from
    1:0 to 0:1 m1:m2.
    
    Parameters
    ----------
    m1, m2 : objects of class Mass_Transfer
        The mass transfer results of two mixing calculations

    Returns
    ----------
    An object of class `Mass_Transfer` with results joined for plotting.
    &#34;&#34;&#34;
    
    
    # tables belonging to the Mass Transfer class that are used by its plotting functions
    tabs = [&#34;misc_params&#34;, &#34;basis_logact&#34;, &#34;dissolved_elements_molal&#34;, &#34;dissolved_elements_ppm&#34;, 
            &#34;aq_distribution_logact&#34;, &#34;aq_distribution_molal&#34;, &#34;aq_distribution_logmolal&#34;,
            &#34;moles_minerals&#34;, &#34;moles_product_minerals&#34;]
    
    for tab in tabs:
        m2_reverse_rows = getattr(m2, tab).iloc[::-1]
        m2_reverse_rows[&#34;Xi&#34;] = [1+(1-float(xi)) for xi in m2_reverse_rows[&#34;Xi&#34;]]
        m2_reverse_rows = m2_reverse_rows[1:]
        m1_rows = getattr(m1, tab)
        setattr(m1, tab, pd.concat([m1_rows, m2_reverse_rows]).reset_index(drop=True))
        
    # do the same but for all EQ6 output tables
    if m1.tab != None and m2.tab != None:
        for tab in m1.tab.keys():
            if tab in m2.tab.keys():
                m2_reverse_rows = m2.tab[tab].iloc[::-1]
                m2_reverse_rows[&#34;Xi&#34;] = [1+(1-float(xi)) for xi in m2_reverse_rows[&#34;Xi&#34;]]
                m2_reverse_rows = m2_reverse_rows[1:]
                m1_rows = m1.tab[tab]
                m1.tab[tab] = pd.concat([m1_rows, m2_reverse_rows]).reset_index(drop=True)
    
    # do the same but for mass contribution tables
    for tab in m1.mass_contribution_dict.keys():
        if tab in m2.mass_contribution_dict.keys():
            m2_reverse_rows = m2.mass_contribution_dict[tab].iloc[::-1]
            m2_reverse_rows[&#34;Xi&#34;] = [1+(1-float(xi)) for xi in m2_reverse_rows[&#34;Xi&#34;]]
            m2_reverse_rows = m2_reverse_rows[1:]
            m1_rows = m1.mass_contribution_dict[tab]
            m1.mass_contribution_dict[tab] = pd.concat([m1_rows, m2_reverse_rows]).reset_index(drop=True)
    
    return m1</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.react"><code class="name flex">
<span>def <span class="ident">react</span></span>(<span>speciation, reaction_setup, chain_mt=False, delete_generated_folders=False, hide_traceback=True, data1_override=None, eq36da='/repos/WORM-db', eq36co='/usr/local/bin', verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate how speciated water reacts with minerals and/or gases.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>speciation</code></strong> :&ensp;<code>Speciation object</code></dt>
<dd>The output of a speciation calculation produced by the
AqEquil.speciate function.</dd>
<dt><strong><code>reaction_setup</code></strong> :&ensp;<code>str</code> or <code><a title="AqEquil.MassTransfer.Prepare_Reaction" href="#AqEquil.MassTransfer.Prepare_Reaction">Prepare_Reaction</a> object</code></dt>
<dd>Defines how the reaction is to be set up. There are two ways to set up
a reaction. The first way is to prepare the reaction with
<code><a title="AqEquil.MassTransfer.Prepare_Reaction" href="#AqEquil.MassTransfer.Prepare_Reaction">Prepare_Reaction</a></code>. The second way is to prepare the first half of an
EQ6 6i file (the part without the contents of the pickup file) and then
pass the filename to <code>reaction_setup</code>.</dd>
<dt><strong><code>chain_mt</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Is the speciation the result of another mass transfer calculation?
Choosing True will allow mass transfer calculations to be chained
together.</dd>
<dt><strong><code>delete_generated_folders</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Delete the 'rxn_6i', 'rxn_6o', 'rxn_6p', and 'eq6_extra_out' folders
containing raw EQ6 input, output, and pickup files once the
reaction calculation is complete?</dd>
<dt><strong><code>hide_traceback</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Hide traceback message when encountering errors handled by this class?
When True, error messages handled by this class will be short and to
the point.</dd>
<dt><strong><code>data1_override</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The three letter code of a data1 file used to override the thermodynamic
database used to speciate the sample(s). This is useful for chaining
the results of one mass transfer calculation into another while
simultaneously changing the temperature and pressure regime of the
new system. See the description for the <code>chain_mt</code> parameter for more
about chaining.</dd>
</dl>
<p>eq36da=os.environ.get('EQ36DA'),
eq36co=os.environ.get('EQ36CO'),</p>
<h2 id="returns">Returns</h2>
<dl>
<dt>An object of class <code>Speciation</code> modified with the results of the reaction</dt>
<dt>(if a thermodynamic database formatted as a WORM-style CSV was used during</dt>
<dt><code>speciation)</code> or <code>an unmodified speciation object (if a data0</code> or <code>data1 file</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>was used during speciation).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def react(speciation,
          reaction_setup,
          chain_mt=False,
          delete_generated_folders=False,
          hide_traceback=True,
          data1_override=None,
          eq36da=os.environ.get(&#39;EQ36DA&#39;),
          eq36co=os.environ.get(&#39;EQ36CO&#39;),
          verbose=1,
         ):
    
    &#34;&#34;&#34;
    Calculate how speciated water reacts with minerals and/or gases.
    
    Parameters
    ----------
    speciation : Speciation object
        The output of a speciation calculation produced by the
        AqEquil.speciate function.
    
    reaction_setup : str or Prepare_Reaction object
        Defines how the reaction is to be set up. There are two ways to set up
        a reaction. The first way is to prepare the reaction with
        `Prepare_Reaction`. The second way is to prepare the first half of an
        EQ6 6i file (the part without the contents of the pickup file) and then
        pass the filename to `reaction_setup`.
    
    chain_mt : bool, default False
        Is the speciation the result of another mass transfer calculation?
        Choosing True will allow mass transfer calculations to be chained
        together.
    
    delete_generated_folders : bool, default False
        Delete the &#39;rxn_6i&#39;, &#39;rxn_6o&#39;, &#39;rxn_6p&#39;, and &#39;eq6_extra_out&#39; folders
        containing raw EQ6 input, output, and pickup files once the
        reaction calculation is complete?

    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this class?
        When True, error messages handled by this class will be short and to
        the point.

    data1_override : str, optional
        The three letter code of a data1 file used to override the thermodynamic
        database used to speciate the sample(s). This is useful for chaining
        the results of one mass transfer calculation into another while
        simultaneously changing the temperature and pressure regime of the
        new system. See the description for the `chain_mt` parameter for more
        about chaining.
    
    eq36da=os.environ.get(&#39;EQ36DA&#39;),
    eq36co=os.environ.get(&#39;EQ36CO&#39;),

    Returns
    ----------
    An object of class `Speciation` modified with the results of the reaction
    (if a thermodynamic database formatted as a WORM-style CSV was used during
    speciation) or an unmodified speciation object (if a data0 or data1 file
    was used during speciation).
    &#34;&#34;&#34;
    
    prev_wd = os.getcwd()
    ae = AqEquil(load_thermo=False, eq36co=eq36co, eq36da=eq36da, verbose=verbose)
    
    speciation.join_6i_p(reaction_setup, chain_mt)
    __delete_file(&#34;data1.dyn&#34;)
    
    paths=[&#39;rxn_6o&#39;, &#39;rxn_6p&#39;, &#39;eq6_extra_out&#39;]
    for path in paths:
        if not os.path.exists(path):
            os.makedirs(path)
        else:
            shutil.rmtree(path)
            os.makedirs(path)
            
    for sample_name in list(speciation.sample_data.keys()):
        filename_6i = speciation.sample_data[sample_name][&#34;filename&#34;][:-3]+&#34;.6i&#34;
        filename_6o = filename_6i[:-3]+&#34;.6o&#34;
        filename_6p = filename_6i[:-3]+&#34;.6p&#34;
        
        if data1_override != None:
            with open(&#34;data1.&#34;+data1_override, mode=&#39;rb&#39;) as data1:
                speciation.data1[&#34;all_samples&#34;] = data1.read()
            speciation.thermo.thermo_db_filename = &#34;data1.&#34;+data1_override
            
        if &#34;all_samples&#34; not in speciation.data1.keys():
            # each sample has a unique data1. e.g., with dynamic_db
            __delete_file(&#34;eq6_extra_out/data1.dyn&#34;)
            with open(&#34;eq6_extra_out/data1.dyn&#34;, &#39;wb&#39;) as f:
                f.write(speciation.data1[speciation.sample_data[sample_name][&#34;filename&#34;][:-3]])

        else:
            # all samples use the same data1.
            with open(&#34;eq6_extra_out/data1.dyn&#34;, &#39;wb&#39;) as f:
                f.write(speciation.data1[&#34;all_samples&#34;])
        
        path_6i=&#34;rxn_6i/&#34;
        path_6o=&#34;rxn_6o&#34;
        path_6p=&#34;rxn_6p&#34;
        path_extra_out=&#34;eq6_extra_out&#34;
        
        ae.runeq6(filename_6i,
                  db=&#34;dyn&#34;,
                  path_6i=path_6i,
                  data1_path=os.getcwd()+&#34;/eq6_extra_out&#34;, # ensuring data1 is read from a folder without spaces overcomes the problem where environment variables with spaces do not work properly when assigned to EQ36DA
                  dynamic_db_name=speciation.thermo.thermo_db_filename)

        # get current working dir
        cwd = os.getcwd()
        cwdd = cwd + &#34;/&#34;
        
        filename_6o = filename_6i[:-1] + &#39;o&#39;
        filename_6p = filename_6i[:-1] + &#39;p&#39;
        filename_6ba = filename_6i[:-1] + &#39;ba&#39;
        filename_6bb = filename_6i[:-1] + &#39;bb&#39;
        filename_6t = filename_6i[:-2] + &#39;csv&#39;
        filename_6tx = filename_6i[:-1] + &#39;tx&#39;

        # The new eq36 build truncates names, e.g., MLS.Source.3i creates MLS.3o
        # Correct for this here:
        files_6o = [file for file in os.listdir(cwdd+path_6i) if file[-3:] == &#34;.6o&#34;]
        files_6p = [file for file in os.listdir(cwdd+path_6i) if file[-3:] == &#34;.6p&#34;]
        files_6ba = [file for file in os.listdir(cwdd+path_6i) if file[-4:] == &#34;.6ba&#34;]
        files_6bb = [file for file in os.listdir(cwdd+path_6i) if file[-4:] == &#34;.6bb&#34;]
        files_6t = [file for file in os.listdir(cwdd+path_6i) if file[-3:] == &#34;.6t&#34;]
        files_6tx = [file for file in os.listdir(cwdd+path_6i) if file[-4:] == &#34;.6tx&#34;]
        
        if len(files_6o) == 0:
            if ae.verbose &gt; 0:
                print(&#39;Error: EQ6 failed to produce output for &#39; + filename_6i)
        elif len(files_6o) == 1:
            file_6o = files_6o[0]
            file_6ba = files_6ba[0]
            file_6bb = files_6bb[0]
            try:
                file_6t = files_6t[0]
                file_6tx = files_6tx[0]
            except:
                pass

            try:
                # report errors in output
                with open(cwdd+path_6i+&#34;/&#34;+file_6o) as file:
                    lines = [line.rstrip() for line in file]
                EQ6_errors_found = ae._report_3o_6o_errors(lines, sample_name)
            except:
                msg = (&#34;Error: could not open &#34;+path_6i+file_6o+&#34; or there &#34;
                      &#34;is something wrong with EQ3/6 error reporting.&#34;)
                ae.err_handler.raise_exception(msg)
            
            try:
                # move output
                shutil.move(cwdd+path_6i+&#34;/&#34;+file_6o, cwdd+path_6o+&#34;/&#34;+filename_6o)
                shutil.move(cwdd+path_6i+&#34;/&#34;+file_6ba, cwdd+path_extra_out+&#34;/&#34;+filename_6ba)
                shutil.move(cwdd+path_6i+&#34;/&#34;+file_6bb, cwdd+path_extra_out+&#34;/&#34;+filename_6bb)
                try:
                    shutil.move(cwdd+path_6i+&#34;/&#34;+file_6t, cwdd+path_extra_out+&#34;/&#34;+filename_6t)
                    shutil.move(cwdd+path_6i+&#34;/&#34;+file_6tx, cwdd+path_extra_out+&#34;/&#34;+filename_6tx)
                except:
                    pass
            except:
                ae.err_handler.raise_exception((&#34;Error: could not move&#34;, path_6i+&#34;/&#34;+file_6o, &#34;to&#34;, path_6o+&#34;/&#34;+filename_6o))
        
        else:
            ae.err_handler.raise_exception(&#34;Error: multiple output files detected for one mass transfer calculation.&#34;)
            
        if len(files_6p) == 0:
            if ae.verbose &gt; 0:
                print(&#39;Error: EQ6 failed to produce a pickup file for &#39; + filename_6i)
        elif len(files_6p) == 1:
            file_6p = files_6p[0]
            try:
                # move output
                shutil.move(cwdd+path_6i+&#34;/&#34;+file_6p, cwdd+path_6p+&#34;/&#34;+filename_6p)
            except:
                ae.err_handler.raise_exception((&#34;Error: could not move&#34;, path_6i+&#34;/&#34;+file_6p, &#34;to&#34;, path_6p+&#34;/&#34;+filename_6p))
        else:
            ae.err_handler.raise_exception(&#34;Error: multiple pickup files detected for one mass transfer calculation.&#34;)
        
        if not EQ6_errors_found:
            m = Mass_Transfer(thermo=speciation.thermo,
                              six_o_file=&#39;rxn_6o/&#39;+filename_6o,
                              tab_name=&#34;eq6_extra_out/&#34;+filename_6i[:-2] + &#39;csv&#39;,
                              hide_traceback=hide_traceback)

            speciation.sample_data[sample_name][&#34;mass_transfer&#34;] = m
        else:
            speciation.sample_data[sample_name][&#34;mass_transfer&#34;] = None
            if ae.verbose &gt; 0:
                print((&#34;Mass transfer results for sample &#39;&#34;+sample_name+&#34;&#39; &#34;
                       &#34;could not be saved because the calculation did not &#34;
                       &#34;finish due to error(s).\n&#34;))
        
        # store input, output, and pickup as dicts in speciation object
        try:
            with open(path_6i + &#34;/&#34; + filename_6i, &#34;r&#34;) as f:
                lines=f.readlines()
            speciation.raw_6_input_dict[sample_name] = lines
        except:
            pass
        try:
            with open(path_6o + &#34;/&#34; + filename_6o, &#34;r&#34;) as f:
                lines=f.readlines()
            speciation.raw_6_output_dict[sample_name] = lines
        except:
            pass
        try:
            with open(path_6p + &#34;/&#34; + filename_6p, &#34;r&#34;) as f:
                lines=f.readlines()
            
            # Unlike 3p files, 6p files include headers that need to be removed
            bottom_half = []
            capture = False
            for line in lines:
                if &#34;Start of the bottom half of the input file&#34; in line:
                    capture = True
                if capture:
                    bottom_half.append(line)
            
            speciation.raw_6_pickup_dict[sample_name] = bottom_half
            
        except:
            pass
        
    if delete_generated_folders:
        __delete_dir(&#34;eq6_extra_out&#34;)
        __delete_dir(&#34;rxn_6i&#34;)
        __delete_dir(&#34;rxn_6p&#34;)
        __delete_dir(&#34;rxn_6o&#34;)
    
    return speciation</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AqEquil.MassTransfer.Gas"><code class="flex name class">
<span>class <span class="ident">Gas</span></span>
<span>(</span><span>gas_name='None', gas_moles=0, gas_log_fugacity=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to define gases for <code><a title="AqEquil.MassTransfer.Prepare_Reaction" href="#AqEquil.MassTransfer.Prepare_Reaction">Prepare_Reaction</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gas_name</code></strong> :&ensp;<code>str</code>, default <code>"None"</code></dt>
<dd>Name of the gas.</dd>
<dt><strong><code>gas_moles</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Moles of gas.</dd>
<dt><strong><code>gas_log_fugacity</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>The log10 fugacity of the gas.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gas:
    def __init__(self,
                 gas_name=&#34;None&#34;,
                 gas_moles=0,
                 gas_log_fugacity=0,
                ):
        
        &#34;&#34;&#34;
        Class used to define gases for `Prepare_Reaction`.

        Parameters
        ----------
        gas_name : str, default &#34;None&#34;
            Name of the gas.
        
        gas_moles : float, default 0
            Moles of gas.
        
        gas_log_fugacity : float, default 0
            The log10 fugacity of the gas.

        &#34;&#34;&#34;
        
        self.gas_name=gas_name
        self.gas_moles=gas_moles
        self.gas_log_fugacity=gas_log_fugacity
        
        self.__format_line()
        
    def __format_line(self):
        
        gas_options_formatted = dict(
            gas_name = f&#34;{self.gas_name:&lt;24}&#34;,
            gas_moles = f&#34;{&#39;{:.5E}&#39;.format(self.gas_moles):&gt;13}&#34;,
            gas_log_fugacity = f&#34;{&#39;{:.5E}&#39;.format(self.gas_log_fugacity):&gt;13}&#34;,
        )
    
        gas_line_template = copy.copy(gl_template)
        self.formatted_line = gas_line_template.format(**gas_options_formatted)</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer"><code class="flex name class">
<span>class <span class="ident">Mass_Transfer</span></span>
<span>(</span><span>six_o_file, thermo=None, tab_name=None, hide_traceback=True, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Class containing functions to facilitate mass transfer and reaction path
calculations and visualize results.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>six_o_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path name of the '6o' output file generated by EQ6.</dd>
<dt><strong><code>thermo</code></strong> :&ensp;<code>an object</code> of <code>class Thermodata</code></dt>
<dd>The subclass containing thermodynamic data in a Speciation object.</dd>
<dt><strong><code>thermodata_csv</code></strong> :&ensp;<code>str</code></dt>
<dd>Path name of the WORM-styled thermodynamic database CSV used in the EQ6
calculation.</dd>
<dt><strong><code>tab_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Path name of the TAB file generated by EQ6.</dd>
<dt><strong><code>hide_traceback</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Hide traceback message when encountering errors handled by this class?
When True, error messages handled by this class will be short and to
the point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mass_Transfer:
    &#34;&#34;&#34;
    Class containing functions to facilitate mass transfer and reaction path
    calculations and visualize results.
    
    Parameters
    ----------
    six_o_file : str
        Path name of the &#39;6o&#39; output file generated by EQ6.
    
    thermo : an object of class Thermodata
        The subclass containing thermodynamic data in a Speciation object.
    
    thermodata_csv : str
        Path name of the WORM-styled thermodynamic database CSV used in the EQ6
        calculation.
    
    tab_name : str
        Path name of the TAB file generated by EQ6.
    
    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this class?
        When True, error messages handled by this class will be short and to
        the point.
    
    &#34;&#34;&#34;
    def __init__(self, six_o_file, thermo=None, tab_name=None, hide_traceback=True, verbose=1):
        
        self.err_handler = Error_Handler(clean=hide_traceback)
        
        self.six_o_file = six_o_file
        
        f=open(self.six_o_file, mode=&#39;r&#39;)
        self.six_o_file_lines=f.readlines()
        f.close()
        
        self.thermo=thermo
        self.tab_name = tab_name
        self.verbose = verbose
        
        self.inactive_species = self.__get_inactive_species()
        
        if isinstance(self.thermo.csv_db, pd.DataFrame):

            # these operations require a WORM-style thermodynamic database CSV
            obigt = pyCHNOSZ.thermo().OBIGT
            pyCHNOSZ.thermo(OBIGT = obigt.loc[ obigt.name.isin(FIXED_SPECIES), : ])
            _ = pyCHNOSZ.add_OBIGT(self.thermo.csv_db, force=True, messages=False)
            
            self.df = copy.deepcopy(self.thermo.csv_db)
            
            try:
                self.tab = self.process_tab(tab_name, self.thermo.csv_db)
            except:
                self.tab = None

            # remove species that do not have Gibbs free energy values
            self.df = self.df[~self.df[&#34;G&#34;].isna()]
            
            # remove inactive species from the database to prevent them from
            # showing up as mineral fields or saturation lines
            if len(self.inactive_species) &gt; 0:
                self.df = self.df[~self.df.name.isin(self.inactive_species)]
                
            basis_df = self.df[self.df[&#34;tag&#34;] == &#34;basis&#34;]
            aux_df = self.df[self.df[&#34;tag&#34;] == &#34;aux&#34;]
            
            # remove basis or aux species with no formula ox state col
            aux_df = aux_df[aux_df[&#34;formula_ox&#34;] != &#34;&#34;]
            aux_df = aux_df[~aux_df[&#39;formula_ox&#39;].isnull()]
            
            refstate_df = self.df[self.df[&#34;tag&#34;] == &#34;refstate&#34;]
            self.basis_df = pd.concat([basis_df])
            self.basis_aux_df = pd.concat([basis_df, aux_df, refstate_df])
            self.df_cr = self.df[self.df[&#34;state&#34;] == &#39;cr&#39;]
        else:
            self.df = None
            self.tab = None
            self.basis_df = None
            self.basis_aux_df = None
            self.df_cr = None
        
        self.misc_params = self.__get_misc_params()
        self.dissolved_elements_molal = self.__get_dissolved_elements(unit=&#34;molality&#34;)
        self.dissolved_elements_ppm = self.__get_dissolved_elements(unit=&#34;ppm&#34;)
 
        self.aq_distribution_logact = self.__get_aq_distribution(unit=&#34;log activity&#34;)
        self.aq_distribution_molal = self.__get_aq_distribution(unit=&#34;molality&#34;)
        self.aq_distribution_logmolal = self.__get_aq_distribution(unit=&#34;log molality&#34;)
        self.moles_minerals = self.__get_moles_minerals()

        self.saturation_states_pure_solids_log_Q_over_K = self.__get_saturation_states(unit=&#34;logQ/K&#34;)
        self.saturation_states_pure_solids_affinity = self.__get_saturation_states(unit=&#34;affinity&#34;)
        
        self.saturation_states_solid_solutions_log_Q_over_K = self.__get_ss_saturation_states(unit=&#34;logQ/K&#34;)
        self.saturation_states_solid_solutions_affinity = self.__get_ss_saturation_states(unit=&#34;affinity&#34;)
        self.solid_solution_names = [col for col in list(self.saturation_states_solid_solutions_affinity.columns) if col != &#34;Xi&#34;] # required by a few things below
        
        self.moles_product_minerals_and_solid_solutions = self.__get_moles_product_minerals(include_solid_solutions=True)
        self.moles_product_minerals = self.__get_moles_product_minerals(include_solid_solutions=False) # relies on self.solid_solution_names

        self.solid_solution_x_dict = self.__get_solid_solution_product_phases(unit=&#34;x&#34;) # relies on self.solid_solution_names
        self.moles_solid_solutions = self.moles_product_minerals_and_solid_solutions.loc[:, [&#34;Xi&#34;] + list(self.solid_solution_x_dict.keys())]
        self.solid_solution_log_x_dict = self.__get_solid_solution_product_phases(unit=&#34;log x&#34;) # relies on self.solid_solution_names
        self.solid_solution_log_lambda_dict = self.__get_solid_solution_product_phases(unit=&#34;log lambda&#34;) # relies on self.solid_solution_names
        self.solid_solution_log_lambda_dict = self.__get_solid_solution_product_phases(unit=&#34;log activity&#34;) # relies on self.solid_solution_names
        
        self.basis_molality = self.__get_basis_species(unit=&#34;molality&#34;)
        self.basis_ppm = self.__get_basis_species(unit=&#34;ppm&#34;)
        self.basis_logact = self.__get_basis_species(unit=&#34;logact&#34;) # this one needs to be after __get_aq_distribution()
        
        # format element names in case there are redox-isolated elements
        self.dissolved_elements_molal.columns = [&#34;Xi&#34;]+[_format_pseudoelement_name(e) for e in self.dissolved_elements_molal.columns if e not in [&#34;Xi&#34;, &#34;t(days)&#34;]]
        self.dissolved_elements_ppm.columns = [&#34;Xi&#34;]+[_format_pseudoelement_name(e) for e in self.dissolved_elements_ppm.columns if e not in [&#34;Xi&#34;, &#34;t(days)&#34;]]
        
        if self.moles_minerals.shape[0] == 0 and self.moles_product_minerals.shape[0] &gt; 0:
            # in the case of special reactants, there is no grand summary table in the 6o file
            # that combine reactant and product minerals (because there is no reactant mineral).
            # In this case, just assume these tables are equal.
            self.moles_minerals = self.moles_product_minerals

        self.mass_contribution_dict = self.__get_mass_contribution()
            
            
    def __get_misc_params(self):
        
        recording = False
        xi_vals = []
        t_vals = []
        p_vals = []
        pH_vals = []
        pmH_vals = []
        logfO2_vals = []
        Eh_vals = []
        pe_vals = []
        aw_vals = []
        for line in self.six_o_file_lines:
            if &#34;                    Xi=&#34; in line:
                recording = True
                splitstrings = line.strip().split(&#34; &#34;)
                xi = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#39;Xi=&#39;]][0]
                xi_vals.append(xi)
            elif &#34; Temperature=&#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                t = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#39;Temperature=&#39;, &#39;C&#39;]][0]
                t_vals.append(t)
            elif &#34; Pressure=&#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                p = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#39;Pressure=&#39;, &#39;bars&#39;]][0]
                p_vals.append(p)
            elif &#34;NBS pH scale &#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                multival = [v for v in splitstrings if v not in [&#39;&#39;, &#39;NBS&#39;, &#39;pH&#39;, &#39;scale&#39;]]
                multival = [float(v) if v != &#34;********&#34; else float(&#39;nan&#39;) for v in multival]
                pH_vals.append(multival[0])
                Eh_vals.append(multival[1])
                pe_vals.append(multival[2])
            elif &#34;Mesmer pH (pmH) scale &#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                pmH = [v for v in splitstrings if v not in [&#39;&#39;, &#39;Mesmer&#39;, &#39;pH&#39;, &#39;(pmH)&#39;, &#39;scale&#39;]]
                pmH = [float(v) if v != &#34;********&#34; else float(&#39;nan&#39;) for v in pmH][0]
                pmH_vals.append(pmH)
            elif &#34;  Log oxygen fugacity=&#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                logfO2 = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#34;Log&#34;, &#34;oxygen&#34;, &#34;fugacity=&#34;]][0]
                logfO2_vals.append(logfO2)
            elif &#34;  Activity of water=&#34; in line and recording:
                splitstrings = line.strip().split(&#34; &#34;)
                aw = [float(v) for v in splitstrings if v not in [&#39;&#39;, &#34;Activity&#34;, &#34;of&#34;, &#34;water=&#34;]][0]
                aw_vals.append(aw)
            if &#34;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&#34; in line:
                recording = False

        df = pd.DataFrame({
            &#34;Xi&#34;:xi_vals,
            &#34;t(days)&#34;:[0]*len(xi_vals), # TODO: make this actually reflect days, need an example output file
            &#34;Temp(C)&#34;:t_vals,
            &#34;Press(bars)&#34;:p_vals,
            &#34;pH&#34;:pH_vals,
            &#34;pmH&#34;:pmH_vals,
            &#34;log fO2&#34;:logfO2_vals,
            &#34;Eh(v)&#34;:Eh_vals,
            &#34;pe&#34;:pe_vals,
            &#34;aw&#34;:aw_vals,
        })
        
        return df
            
            
    def __get_saturation_states(self, unit=&#34;logQ/K&#34;):
        
        if unit == &#34;logQ/K&#34;:
            col_index = 1
        elif unit == &#34;affinity&#34;:
            col_index = 2
        else:
            self.err_handler.raise_exception(&#34;Error in get_saturation_states()&#34;
                    &#34;. Unit not recognized.&#34;)
        
        return self.mine_6o_table(table_start=&#34;--- Saturation States of Pure Solids ---&#34;,
                table_stop=&#34;--- Saturation States of Pure Liquids ---&#34;,
                ignore = [&#34;&#34;, &#34;Phases&#34;, &#39;Phase&#39;, &#39;---&#39;, &#39;-&#39;],
                col_index=col_index)
    
    
    def __get_ss_saturation_states(self, unit=&#34;logQ/K&#34;):
        
        if unit == &#34;logQ/K&#34;:
            col_index = 1
        elif unit == &#34;affinity&#34;:
            col_index = 2
        else:
            self.err_handler.raise_exception(&#34;Error in get_ss_saturation_states()&#34;
                    &#34;. Unit not recognized.&#34;)
        
        return self.mine_6o_table(table_start=&#34;--- Saturation States of Solid Solutions ---&#34;,
                table_stop=&#34;--- Summary of Saturated and Supersaturated Phases ---&#34;,
                ignore = [&#34;&#34;, &#34;Phases&#34;, &#39;Phase&#39;, &#39;---&#39;, &#39;-&#39;],
                col_index=col_index)
    
            
    def __get_dissolved_elements(self, unit=&#34;molality&#34;):
        
        if unit == &#34;molality&#34;:
            col_index = -1
        elif unit == &#34;mg/kg.sol&#34; or unit == &#34;ppm&#34;:
            col_index = 1
        else:
            self.err_handler.raise_exception(&#34;Error in get_dissolved_elements()&#34;
                    &#34;. Unit not recognized.&#34;)
        
        return self.mine_6o_table(table_start=&#34;Elemental Composition of the Aqueous Solution&#34;,
                table_stop=&#34;Numerical Composition of the Aqueous Solution&#34;,
                ignore = [&#34;&#34;, &#34;Element&#34;, &#39;---&#39;, &#39;-&#39;],
                col_index=col_index)
            
        
    def __get_basis_species(self, unit=&#34;logact&#34;):
        
        if unit == &#34;molality&#34; or unit == &#34;logact&#34;:
            col_index = -1
        elif unit == &#34;mg/kg.sol&#34; or unit == &#34;ppm&#34;:
            col_index = 1
        else:
            self.err_handler.raise_exception(&#34;Error in get_basis_species()&#34;
                    &#34;. Unit not recognized.&#34;)
        
        basis_df = self.mine_6o_table(table_start=&#34;Numerical Composition of the Aqueous Solution&#34;,
                table_stop=&#34;Sensible Composition of the Aqueous Solution&#34;,
                ignore = [&#34;&#34;, &#34;Some&#34;, &#39;Species&#39;, &#39;---&#39;, &#39;-&#39;],
                col_index=col_index)
        
        if unit in [&#34;molality&#34;, &#34;ppm&#34;, &#39;mg/kg.sol&#39;]:
            return basis_df
        elif unit == &#34;logact&#34;:
            
            cols_to_harvest = [b for b in basis_df.columns if b not in [&#34;O2(g)&#34;, &#34;H2O&#34;]]
            
            return self.aq_distribution_logact[cols_to_harvest]
        
        
        
    def __get_mass_contribution(self):
        
        bases = [b for b in self.basis_logact.columns if b not in [&#39;Xi&#39;, &#39;t(days)&#39;, &#39;H2O&#39;, &#34;O2(g)&#34;, &#34;H+&#34;]]
        
        mass_contribution_dict = {}
        for basis in bases:

            df = self.mine_6o_table(
                            table_start=&#34;Species Accounting for 99% or More of Aqueous &#34;+basis,
                            table_stop=&#34;Subtotal&#34;,
                            ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;, &#39;-&#39;],
                            col_index=-1)


            df[&#39;Xi&#39;] = df[&#39;Xi&#39;].astype(str)
            df[&#39;Other&#39;] = 100 - df.sum(axis=1, numeric_only=True)
            df[&#39;Xi&#39;] = df[&#39;Xi&#39;].astype(float)

            df[df[&#34;Other&#34;] &lt; 0] = 0

            df[&#34;basis&#34;] = basis
            df[&#34;factor&#34;] = None
            df[&#34;molality&#34;] = None
            
            mass_contribution_dict[basis] = df
        
        return mass_contribution_dict
            
        
            
    def mine_6o_table(self,
                      table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                      table_stop=&#34;Species with molalities less than&#34;,
                      ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                      col_index=-1):
        
        &#34;&#34;&#34;
        Mine a table in a &#39;6o&#39; EQ6 output file and consolidate results into a
        dataframe.
        
        Parameters
        ----------
        table_start : str
            A unique string that indicates the start of the table.

        table_stop : str, optional
            A unique string that indicates the end of the table.
        
        ignore : list of str
            A list of strings representing lines to ignore when mining a table.
            For example, it is prudent to ignore blank lines, or lines
            containing the table column headers.
            A line will be skipped if line.strip().split(&#39; &#39;)[0] matches any
            of the strings in the given list.
        
        col_index : int, default -1
            Integer representing the index of the table column to be mined.
            The default is -1, which is the last column in the table.
            
        Returns
        -------
        df : Pandas dataframe
            A dataframe with rows of the extent of reaction (Xi), and columns
            containing the values of chemical species mined from the file.
        &#34;&#34;&#34;
        
        lines = self.six_o_file_lines
        
        species = []
        xi_vals=[]
        collect_values = False
        for i in lines:
            if len(i.strip().split(&#39; &#39;)) &gt; 1 and i.strip().split(&#39; &#39;)[0] == &#34;Xi=&#34;:
                this_xi_val = float(i.split(&#39; &#39;)[-1])
            if table_stop in i:
                collect_values = False
            if table_start in i:
                xi_vals.append(this_xi_val) # appending here prevents mismatch where there can be more Xi vals than tables to mine
                collect_values = True
            if collect_values:
                if i.strip().split(&#39; &#39;)[0] not in ignore:
                    species.append(i.strip().split(&#39; &#39;)[0])

        species = list(set(species))
        
        species_dict = {&#34;Xi&#34;:xi_vals}
        
        if len(species) == 0:
            df = pd.DataFrame(species_dict)
            return df
        
        for s in species:

            vals=[]
            collect_values = False
            for i in lines:
                if collect_values and table_stop in i:
                    # stop collecting
                    collect_values = False
                    if not got_value:
                        vals.append(np.nan)
                if table_start in i:
                    # start collecting
                    collect_values = True
                    got_value = False
                if collect_values:
                    if len(i.strip().split(&#39; &#39;)) &gt; 2 and i.strip().split(&#39; &#39;)[0] == s:
                        split_i = i.strip().split(&#39; &#39;)
                        split_i_clean = [v for v in split_i if v != &#39;&#39;]
                        val = split_i_clean[col_index]
                        try:
                            val = float(val)
                        except:
                            # if a value is not a float, e.g., 3.1450-100
                            if &#34;-&#34; in val:
                                val_list = val.split(&#34;-&#34;)
                                val = &#34;&#34;.join([val_list[0], &#34;E-&#34;, val_list[1]])
                                val = float(val)
                            elif &#34;+&#34; in val:
                                val_list = val.split(&#34;+&#34;)
                                val = &#34;&#34;.join([val_list[0], &#34;E&#34;, val_list[1]])
                                val = float(val)
                            elif &#34;SATD&#34; in val:
                                pass
                            else:
                                self.err_handler.raise_exception((&#34;Error: &#34;
                                    &#34;Encountered a non-numeric value when mining &#34;
                                    &#34;a .6o file: &#34;+val))
                        vals.append(val)
                        got_value = True
            species_dict[s] = vals
        
        df = pd.DataFrame(species_dict)
        
        if &#39;None&#39; in df.columns:
            df = df.drop([&#39;None&#39;], axis=1)
        
        return df

    
    def __get_inactive_species(self):
        
        lines=self.six_o_file_lines

        table_start = &#34;--- Inactive Species ---&#34;
        table_stop = &#34;The activity coefficients of aqueous species&#34;

        vals=[]
        collect_values=False
        for i in lines:
            if collect_values and table_stop in i:
                # stop collecting
                break
            if table_start in i:
                # start collecting
                collect_values = True
                got_value = False
            if collect_values:
                if table_start not in i:
                    split_i = i.strip().split(&#39; &#39;)
                    split_i_clean = [v for v in split_i if v != &#39;&#39; and v != &#34;None&#34;]
                    if len(split_i_clean) &gt; 0:
                        vals.append(split_i_clean[0])
                        got_value = True
        
        return vals
        
        
    def __get_aq_distribution(self, unit=&#34;log activity&#34;):
        
        if unit == &#34;log activity&#34;:
            col_index = -1
        elif unit == &#34;molality&#34;:
            col_index = 1
        elif unit == &#34;log molality&#34;:
            col_index = 2
        
        return self.mine_6o_table(
                      table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                      table_stop=&#34;Species with molalities less than&#34;,
                      ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                      col_index=col_index)

    def __get_moles_minerals(self):
        
        return self.mine_6o_table(
                      table_start=&#34;Grand Summary of Solid Phases&#34;,
                      table_stop=&#34;Mass, grams       Volume, cm3&#34;,
                      ignore = [&#34;&#34;, &#34;Phase/End-member&#34;, &#39;---&#39;],
                      col_index=2)

    
    def __get_moles_product_minerals(self, include_solid_solutions=True):
        
        if &#34;Grand Summary of Solid Phases&#34; in &#34;\n&#34;.join(self.six_o_file_lines):
            table_stop = &#34;Grand Summary of Solid Phases&#34;
        else:
            table_stop = &#34;Mass, grams       Volume, cm3&#34;
        
        df = self.mine_6o_table(
                      table_start=&#34;--- Summary of Solid Phases (ES) ---&#34;,
                      table_stop=table_stop,
                      ignore = [&#34;&#34;, &#34;Phase/End-member&#34;, &#39;---&#39;],
                      col_index=2)
        
        if not include_solid_solutions:
            mineral_names_to_keep = []
            minerals_in_solid_solutions = []
            
            recording = True
            for col in df.columns:
                if col not in self.solid_solution_names:
                    mineral_names_to_keep.append(col)
            df = df[mineral_names_to_keep]
            
        return df
        
        
    def __get_solid_solution_product_phases(self, unit=&#34;x&#34;):
        
        if unit == &#34;x&#34;:
            col_index = 1
        elif unit == &#34;log x&#34;:
            col_index = 2
        elif unit == &#34;log lambda&#34;:
            col_index = 3
        elif unit == &#34;log activity&#34;:
            col_index = 4
        
        ss_dict = {}
        for ss in self.solid_solution_names:
            df = self.mine_6o_table(
                         table_start=&#34;--- &#34;+ss+&#34; ---&#34;,
                         table_stop=&#34;Mineral&#34;,
                         ignore = [&#34;&#34;, &#34;Component&#34;, &#34;Ideal&#34;, &#39;---&#39;],
                         col_index=col_index)
            
            if not df.empty:
                ss_dict[ss] = df
        
        
        return ss_dict
        
        
    def print_tabs(self):
        &#34;&#34;&#34;
        Print the names of tables contained in a tab file processed by the
        the Mass_Transfer class.
        &#34;&#34;&#34;
        if self.tab != None:
            [print(key) for key in self.tab.keys()]
        else:
            print(&#34;A processed TAB file is not associated with this sample.&#34;)

        
    @staticmethod
    def __is_all_same_value(s):
        a = s.to_numpy()
        return (a[0] == a).all()
        
        
    def plot_reaction_paths(self,
                            xyb=None,
                            path_margin=0.25,
                            flip_xy=False,
                            show_annotation=True,
                            annotation_coords=[0,0],
                            show_nonparticipating_mineral_lines=False,
                            minerals_to_show=[],
                            calculate_projected_points=True,
                            path_line_type = &#34;markers+lines&#34;,
                            path_line_color = &#34;red&#34;,
                            path_point_fill_color = &#34;red&#34;,
                            path_point_line_color = &#34;red&#34;,
                            projected_point_fill_color = &#34;white&#34;,
                            projected_point_line_color = &#34;red&#34;,
                            h_line_color=&#34;black&#34;,
                            v_line_color=&#34;black&#34;,
                            d_line_color=&#34;black&#34;,
                            res=300,
                            plot_width=4,
                            plot_height=3,
                            ppi=122,
                            borders=0,
                            save_as=None,
                            save_format=None,
                            save_scale=1,
                            colormap=&#34;bw&#34;):
        
        &#34;&#34;&#34;
        Create interactive plots of reaction paths in geochemical variable
        space.
        
        Parameters
        ----------
        xyb : list of three str, default None
            By default, this function will plot reaction paths in all possible
            dimensions.
            
            Optionally, if you want to produce only a specific plot,
            you can provide a list containing the basis species to be used for
            the x-axis and y-axis, followed by the basis species used for
            balance. For example, [&#34;Fe+2&#34;, &#34;Fe+3&#34;, &#34;Mg+2&#34;] will have the log
            activity of Fe+2 on the x-axis, the log activity of Fe+3 on the
            y-axis, and will be balanced on Mg+2.

        path_margin : float, default 0.25
            Controls the spacing between the reaction path and the plot axes.
            Increasing this value increases the spacing.
        
        flip_xy : bool, default False
            Transpose the plot so the x and y variables switch axes?

        show_annotation : bool, default True
            Show annotation in the bottom left of the figure? The annotation
            includes the species used for balance, the temperature, and
            the pressure.

        annotation_coords : list, default [0,0]
            List of two numeric values representing the X and Y coordinates of
            the annotation, where 0,0 is the bottom left, 0.5,0 is the bottom
            center, 1,0 is the bottom right, 1,1 is the top right, and so on.
            The annotation includes the species used for balance, the
            temperature and the pressure.

        show_nonparticipating_mineral_lines : bool, default False
            Depict lines for minerals even if those minerals do not participate
            in the reaction? This does not affect the mineral field of the
            diagram, only the mineral planes denoted as lines.
        
        path_line_type : str, default &#34;markers+lines&#34;
            Reaction path line type. Can be either &#34;markers+lines&#34;, &#34;lines&#34;, or
            &#34;markers&#34;.
        
        path_line_color, str, default &#34;black&#34;
            Color of reaction path line.
        
        path_point_fill_color : str, default &#34;black&#34;
            Fill color of non-projected points along the reaction path. The
            fill color of projected points is handled by
            `projected_point_fill_color`.
        
        path_point_line_color : str, default &#34;black&#34;
            Color of the outlines of non-projected points along the reaction
            path. The outline color of projected points is handled by
            `projected_point_line_color`.
        
        projected_point_fill_color : str, default &#34;white&#34;
            Fill color of projected points along the reaction path. The
            fill color of non-projected points is handled by
            `path_point_fill_color`.
        
        projected_point_line_color : str, default &#34;black&#34;
            Color of the outlines of projected points along the reaction path.
            The outline color of non-projected points is handled by
            `path_point_line_color`.
            
        h_line_color : str, default &#34;black&#34;
            Color of horizontal lines representing minerals.
        
        v_line_color : str, default &#34;black&#34;
            Color of vertical lines representing minerals.
        
        d_line_color : str, default &#34;black&#34;
            Color of diagonal lines representing minerals.
        
        res : int, default 300
            Resolution, or number of calculations along each axis, for mineral
            stability fields. A lower number will be faster but will make appear
            boundaries blockier. A higher number takes longer to calculate, but
            will result in smoother boundaries.
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches.

        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
        
        borders : float, default 0
            Thickness of black lines forming boundaries between mineral
            stability regions. No lines appear if equal to 0.
        
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
        
        colormap : str, default &#34;bw&#34;
            Name of the colormap to color the scatterpoints. Accepts &#34;bw&#34;
            or names of matplotlib colormaps. If set to &#34;bw&#34;, the plot will be
            set to black and white, except for the reaction path line itself.
            The colors of the reaction path line and its points are controlled
            by `path_line_color`, `path_point_fill_color`,
            `path_point_line_color`, `projected_point_fill_color`,
            and `projected_point_line_color`.
        
        Returns
        -------
        fig_list : a list of Plotly figure objects
            A list of interactive Plotly figures. If xyb equals None
            (the default), then the list will contain figures representing all
            combinations of geochemical variables. Optionally, if xyb is
            specified, fig_list will only contain the single figure of interest.
        &#34;&#34;&#34;

        error_messages = []
        
        # check that there is only one temperature and pressure
        if not self.__is_all_same_value(self.misc_params[&#34;Temp(C)&#34;]):
            error_messages.append(&#34;Reaction paths cannot be plotted when temperature changes with reaction progress.&#34;)
        if not self.__is_all_same_value(self.misc_params[&#34;Press(bars)&#34;]):
            error_messages.append(&#34;Reaction paths cannot be plotted when pressure changes with reaction progress.&#34;)
        
        if isinstance(xyb, list):
            if len(xyb) != 3:
                error_messages.append((&#34;Error in xyb={}&#34;.format(xyb)+&#34;. &#34;
                        &#34;The xyb parameter must either be None or a list of &#34;
                        &#34;three basis species to serve as x, y, and balance variables.&#34;))
        
        if not isinstance(self.df, pd.DataFrame):
            error_messages.append((&#34;The plot_reaction_paths() function requires &#34;
                    &#34;a thermodynamic database in a WORM-style CSV format, e.g., &#34;
                    &#34;&#39;wrm_data.csv&#39;. You may be getting this message because &#34;
                    &#34;a data0 or data1 file was used.&#34;))
        
        if len(error_messages)&gt;0:
            self.err_handler.raise_exception(&#34;\n&#34;.join(error_messages))
        
        self.T = float(self.misc_params[&#34;Temp(C)&#34;][0])
        self.P = float(self.misc_params[&#34;Press(bars)&#34;][0])
        self.path_margin = path_margin
        
        minerals_formed = [m for m in self.moles_minerals.columns if m != &#34;Xi&#34;]
        
        all_elements_of_interest = []
        for mineral in minerals_formed:
            
            if mineral not in list(self.df[&#34;name&#34;]):
                if self.verbose &gt; 0:
                    print(&#34;The mineral&#34;, mineral, &#34;cannot be represented in a&#34;,
                           &#34;reaction path diagram, likely because it is missing&#34;,
                           &#34;a Gibbs free energy value in the thermodynamic&#34;,
                           &#34;database. Continuing anyway, but be aware that&#34;,
                           &#34;this mineral will not be represented in diagrams.&#34;)
                continue
            
            all_elements_of_interest += self.__get_elem_ox_of_interest_in_minerals(mineral)
        all_elements_of_interest_pre = list(set(all_elements_of_interest))
        
        # filter out elements like Fe+0, which has no aqueous species representative
        # for which to create an axis.
        bad_elem = []
        for elem in all_elements_of_interest_pre:
            if len(list(self.thermo.csv_db.loc[self.thermo.csv_db[&#39;name&#39;] == self.__get_basis_from_elem(elem), &#39;state&#39;])) == 0:
                bad_elem.append(elem)
            elif list(self.thermo.csv_db.loc[self.thermo.csv_db[&#39;name&#39;] == self.__get_basis_from_elem(elem), &#39;state&#39;])[0] != &#39;aq&#39;:
                bad_elem.append(elem)
                
        all_elements_of_interest = [elem for elem in all_elements_of_interest_pre if elem not in bad_elem]
        
        all_elements_of_interest = sorted(all_elements_of_interest)
        
        self.all_elements_of_interest = all_elements_of_interest
        
        fig_list = []
        
        # if there are only 2 elements of interest, these become the axes, and there is no
        # need to fuss with real vs projected points.
        if len(all_elements_of_interest) == 2:
            fig, _ , _ = self.__plot_reaction_path_main(
                                                triad = all_elements_of_interest,
                                                T=self.T, P=self.P,
                                                path_margin=self.path_margin,
                                                flip_xy=flip_xy,
                                                show_annotation=show_annotation,
                                                annotation_coords=annotation_coords,
                                                show_nonparticipating_mineral_lines=show_nonparticipating_mineral_lines,
                                                minerals_to_show=minerals_to_show,
                                                path_line_type=path_line_type,
                                                path_line_color=path_line_color,
                                                path_point_fill_color=path_point_fill_color,
                                                path_point_line_color=path_point_line_color,
                                                projected_point_fill_color=projected_point_fill_color,
                                                projected_point_line_color=projected_point_line_color,
                                                h_line_color=h_line_color,
                                                v_line_color=v_line_color,
                                                d_line_color=d_line_color,
                                                res=res,
                                                plot_width=plot_width,
                                                plot_height=plot_height,
                                                ppi=ppi,
                                                colormap=colormap,
                                                borders=borders,
                                                projected_points=[&#34;real&#34;]*self.moles_product_minerals.shape[0],
                                                first_pass=False)
        
            fig_list = [fig]
        
        elif len(all_elements_of_interest) &gt;= 3:

            # get a list of elem pairs for plotting
            alist = self.all_elements_of_interest
            element_plot_pairs = []
            for result in itertools.combinations(alist, 2):
                element_plot_pairs.append(list(result))

            element_plot_triad = []
            for pair in element_plot_pairs:
                elem_not_in_pair = [e for e in self.all_elements_of_interest if e not in pair]
                for e in elem_not_in_pair:
                    triad_to_append = pair + [e]
                    element_plot_triad.append(triad_to_append)

            if colormap == &#34;bw&#34;:
                if borders == 0:
                    borders = 1
                colormap = &#34;none&#34;
                h_line_color = &#34;black&#34;
                v_line_color = &#34;black&#34;
                d_line_color = &#34;black&#34;

            fig_list = []
            pred_minerals_from_fields_list = []
            pred_minerals_from_lines_list = []
            

            if isinstance(xyb, list):
                try:
                    xyb_element_plot_triad = [[self.__get_elem_ox_of_interest_in_minerals(v)[0] for v in xyb]]
                except:
                    err = (&#34;Plot axes cannot accomodate desired variables. &#34;
                           &#34;Available variables include {}&#34;.format([self.__get_basis_from_elem(elem) for elem in alist]))
                    self.err_handler.raise_exception(err)
                xyb_i = None
                # get index of triad that matches xyb:
                for i,triad in enumerate(element_plot_triad):
                    if set(xyb_element_plot_triad[0][0:2]) == set(triad[0:2]) and xyb_element_plot_triad[0][2] == triad[2]:
                        xyb_i = i
                if xyb_i == None:
                    err = (&#34;Plot axes cannot accomodate desired variables. &#34;
                           &#34;Available variables include {}&#34;.format([self.__get_basis_from_elem(elem) for elem in alist]))
                    self.err_handler.raise_exception(err)
            
            if not calculate_projected_points or path_line_type==&#34;lines&#34;:
                projected_points = [&#34;real&#34;]*self.moles_product_minerals.shape[0]
                fig_list_projected_points = [projected_points]*len(element_plot_triad)
                
            else:
                
                if len(element_plot_triad) &gt; 20:
                    if self.verbose &gt; 0:
                        print(&#34;Warning! There are {}&#34;.format(len(element_plot_triad)),
                              &#34;different combinations of variables that must be considered&#34;,
                              &#34;in order to plot markers.&#34;)
                        print(&#34;This might take a very long time or may not finish calculating at all.&#34;)
                        print(&#34;We recommend setting calculate_projected_points=False in&#34;,
                              &#34;plot_reaction_paths() and then restarting the&#34;,
                              &#34;calculation to avoid lengthy calculation times.&#34;)
                
                for triad in element_plot_triad:
                    
                    # do a quick first pass at making figures to see which points are projections.
                    fig, pred_minerals_from_fields, pred_minerals_from_lines = self.__plot_reaction_path_main(
                                                        triad, T=self.T, P=self.P,
                                                        show_nonparticipating_mineral_lines=False, # no need for this in first pass
                                                        minerals_to_show=[], # no need for this in first pass
                                                        path_margin=self.path_margin,
                                                        flip_xy=flip_xy,
                                                        first_pass=True, # flag for skipping certain calculations/plotting
                                                        res=1) # low res first pass

                    if pred_minerals_from_fields == None:
                        pred_minerals_from_fields=[None]*self.moles_product_minerals.shape[0]
                    
                    fig_list.append(fig)
                    pred_minerals_from_fields_list.append(pred_minerals_from_fields)
                    pred_minerals_from_lines_list.append(pred_minerals_from_lines)

                # determine which line segments in the reaction path are projections
                # and which are actually in the plane of the diagram.
                # This is the &#34;first pass&#34;
                fig_list_projected_points = []
                for i,triad in enumerate(element_plot_triad):

                    projected_points = [&#34;projection&#34;]*self.moles_product_minerals.shape[0]
                    for irow in range(0, self.moles_product_minerals.shape[0]):

                        # get names of minerals formed at this xi
                        xirow = list(self.moles_product_minerals.iloc[irow])
                        formed_minerals = [self.moles_product_minerals.columns[1:][ii] for
                                           ii,mineral in enumerate(xirow[1:]) if
                                           mineral&gt;0]
                        
                        available_pred_minerals_from_fields = [l[irow] for l in pred_minerals_from_fields_list]

                        for mineral in formed_minerals:

                            if mineral == pred_minerals_from_fields_list[i][irow]:
                                # if this mineral is in pred_minerals_from_fields_list,
                                # then it is NOT a projection.
                                projected_points[irow] = &#34;real&#34;
                            if mineral in available_pred_minerals_from_fields and mineral in pred_minerals_from_lines_list[i]:
                                # if this mineral is in the irowth location of any of the
                                # lists in pred_minerals_from_lines_list, it is NOT a
                                # projection.
                                projected_points[irow] = &#34;real&#34;

                    fig_list_projected_points.append(projected_points)
                
            if isinstance(xyb, list):
                # if xyb is defined, make element_plot_triad have a length of 1
                element_plot_triad = xyb_element_plot_triad
                # give the list of projected points lists a length of 1
                fig_list_projected_points = [fig_list_projected_points[xyb_i]]
                
            fig_list = []
            for i,triad in enumerate(element_plot_triad):
                # re-run figure generation, passing in a list of which points are projected.
                fig, _ , _ = self.__plot_reaction_path_main(
                                    triad, T=self.T, P=self.P,
                                    path_margin=self.path_margin,
                                    flip_xy=flip_xy,
                                    show_annotation=show_annotation,
                                    annotation_coords=annotation_coords,
                                    show_nonparticipating_mineral_lines=show_nonparticipating_mineral_lines,
                                    minerals_to_show=minerals_to_show,
                                    path_line_type=path_line_type,
                                    path_line_color=path_line_color,
                                    path_point_fill_color=path_point_fill_color,
                                    path_point_line_color=path_point_line_color,
                                    projected_point_fill_color=projected_point_fill_color,
                                    projected_point_line_color=projected_point_line_color,
                                    h_line_color=h_line_color,
                                    v_line_color=v_line_color,
                                    d_line_color=d_line_color,
                                    res=res,
                                    plot_width=plot_width,
                                    plot_height=plot_height,
                                    ppi=ppi,
                                    colormap=colormap,
                                    borders=borders,
                                    projected_points=fig_list_projected_points[i],
                                    first_pass=False)

                fig_list.append(fig)
        
        if not fig_list and self.verbose &gt; 0:
            print(&#34;Warning: a reaction path plot could not be generated for this system.&#34;)
        
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            for i,fig in enumerate(fig_list):
                
                if isinstance(xyb, list):
                    name_append = &#34;&#34;
                else:
                    name_append = &#34;_{}&#34;.format(i+1)
                _, _ = dummy_sp._save_figure(fig,
                        save_as+name_append, save_format, save_scale,
                        plot_width, plot_height, ppi)
        
        return fig_list
        

    
    
    @staticmethod
    def process_tab(tab_name, thermodata_csv):
        
        &#34;&#34;&#34;
        Process a TAB file (from EQ6) into a dictionary of Pandas dataframes.
        
        Parameters
        ----------
        tab_name : str
            Path name of the TAB file generated by EQ6.
        
        thermodata_csv : str or Pandas dataframe
            Path name of the WORM-styled thermodynamic database CSV used in the
            EQ6 calculation. Alternately, the thermodynamic database itself as a
            Pandas dataframe itself.

        Returns
        -------
        tab : a dict of Pandas dataframes
            A dictionary of dataframes representing tables mined from the TAB
            file.
        &#34;&#34;&#34;
        
        if isinstance(thermodata_csv, str):
            thermo_db = pd.read_csv(thermodata_csv)
        else:
            thermo_db = thermodata_csv
        
        
        thermo_db_names = list(thermo_db[&#34;name&#34;])

        with open(tab_name, &#34;r&#34;) as tabfile:
            tab_lines = tabfile.readlines()

        tab = {}

        tables = [&#34;B1&#34;, &#34;B2&#34;, &#34;C1&#34;, &#34;C2&#34;, &#34;C3&#34;, &#34;C4&#34;,
                  &#34;D1&#34;, &#34;D2&#34;, &#34;D3&#34;, &#34;D4&#34;, &#34;E1&#34;, &#34;E2&#34;,
                  &#34;E3&#34;, &#34;J&#34;, &#34;K&#34;, &#34;P&#34;, &#34;Q&#34;, &#34;T&#34;, &#34;W&#34;]

        record_lines = False
        get_header = False
        recorded_lines = []
        for line in tab_lines:
            split_line = line.split(&#34;,&#34;)

            if True in [s in [&#34;Table &#34; + t for t in tables] for s in split_line]:
                get_header = True
                table_name = &#34; &#34;.join(split_line[1:-1])
                continue

            if get_header:
                header = split_line[1:-1]

                # handle instances where the tab file creates extra columns for things like &#34;albite,low&#34;
                if table_name in [&#34;Table P Moles of product minerals&#34;,
                                  &#34;Table Q Saturation indices of potential product phases&#34;,
                                  &#34;Table J Moles of reactants destroyed/created&#34;,
                                  &#34;Table K Affinities of reactants (kcal)&#34;]:
                    
                    if table_name in [&#34;Table P Moles of product minerals&#34;,
                                      &#34;Table J Moles of reactants destroyed/created&#34;]:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;] # table P and J
                    elif table_name == &#34;Table Q Saturation indices of potential product phases&#34;:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;H2O&#34;, &#34;Gas&#34;] # table Q
                    elif table_name == &#34;Table K Affinities of reactants (kcal)&#34;:
                        new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;Total&#34;]

                    for i,h in enumerate(header):

                        if h != &#34;Xi&#34; and h != &#34;t(days)&#34; and h != &#34;H2O&#34; and h != &#34;Gas&#34; and h != &#34;Total&#34;:
                            if h not in thermo_db_names:
                                if header[i-1]+&#34;,&#34;+h in thermo_db_names:
                                    new_header = new_header[:-1]
                                    new_header.append(header[i-1]+&#34;,&#34;+h)
                                else:
                                    new_header.append(h)
                            else:
                                new_header.append(h)

                    header = new_header


                record_lines = True
                get_header = False
                continue

            if &#34;EndTable:&#34; in split_line:
                record_lines = False
                if len(recorded_lines) &gt; 0:
                    df = pd.DataFrame(recorded_lines)
                    recorded_lines = []
                    df.columns = header
                    tab[table_name] = df

            if record_lines:
                recorded_lines.append(split_line[1:-1])

        return tab

    
    def __get_mineral_elem_ox(self, mineral):
        split_list = list(self.df[self.df[&#34;name&#34;]==mineral][&#34;formula_ox&#34;])[0].split()
        split_list_clean = [s.replace(&#34; &#34;, &#34;&#34;) for s in split_list]
        try:
            elem_ox_list = [re.findall(r&#34;^(?:\d+|)([A-Z].*$)&#34;, s)[0] for s in split_list_clean]
        except:
            elem_ox_list = []
        return elem_ox_list

    
    def __get_elem_ox_of_interest_in_minerals(self, mineral_name):
        mineral_elements = self.__get_mineral_elem_ox(mineral_name)
        mineral_elements_of_interest = [e for e in mineral_elements if e not in [&#34;H+&#34;, &#34;O-2&#34;]]
        return mineral_elements_of_interest


    def __get_mineral_elem_ox_dict(self, mineral):
        split_list = list(self.df[self.df[&#34;name&#34;]==mineral][&#34;formula_ox&#34;])[0].split()
        split_list_clean = [s.replace(&#34; &#34;, &#34;&#34;) for s in split_list]
        elem_ox_names = self.__get_mineral_elem_ox(mineral)

        elem_ox_list = []
        for s in split_list:
            coeff = re.findall(r&#34;(\d+)[A-Z]&#34;, s)
            if len(coeff) == 0:
                coeff = 1
            else:
                coeff = float(coeff[0])
            elem_ox_list.append(coeff)

        return {key:val for key,val in zip(elem_ox_names, elem_ox_list)}

    
    def __get_mineral_elem_ox_dict_interest(self, mineral):
        mineral_dict = self.__get_mineral_elem_ox_dict(mineral)
        return {key:value for key,value in zip(mineral_dict.keys(), mineral_dict.values()) if key not in [&#34;H+&#34;, &#34;O-2&#34;]}


    def __get_basis_from_elem(self, elem):

        basis_species_x = None

        for s in list(self.basis_df[&#34;name&#34;]):
            if elem in self.__get_elem_ox_of_interest_in_minerals(s):
                basis_species_x = s

        if basis_species_x == None:
            for s in list(self.basis_aux_df[&#34;name&#34;]):
                if elem in self.__get_elem_ox_of_interest_in_minerals(s):
                    basis_species_x = s

        return basis_species_x

    
    def __get_reaction_path(self, plot_basis_x, plot_basis_y, div_var_name):

        xi_vals=self.aq_distribution_logact[&#34;Xi&#34;]
        proton_vals=self.aq_distribution_logact[&#34;H+&#34;]
        x_vals=self.aq_distribution_logact[plot_basis_x]
        y_vals=self.aq_distribution_logact[plot_basis_y]

        assert len(proton_vals) == len(x_vals), f&#34;number of proton values ({proton_vals}) should equal number of x values ({x_vals})&#34;
        assert len(proton_vals) == len(y_vals), f&#34;number of proton values ({proton_vals}) should equal number of y values ({y_vals})&#34;

        x_vals = [log10((10**float(x))/(10**float(d))**_get_ion_ratio_exponent(plot_basis_x, &#34;H+&#34;)) for x,d in zip(x_vals,proton_vals)]
        y_vals = [log10((10**float(y))/(10**float(d))**_get_ion_ratio_exponent(plot_basis_y, &#34;H+&#34;)) for y,d in zip(y_vals,proton_vals)]
        
        return xi_vals, x_vals, y_vals

    
    def __get_plot_range(self, x_vals, y_vals):
        min_x_val = min(x_vals)
        min_y_val = min(y_vals)
        max_x_val = max(x_vals)
        max_y_val = max(y_vals)

        path_x_range = max_x_val - min_x_val
        path_y_range = max_y_val - min_y_val

        if len(list(set(x_vals))) == 1:
            # x values form a vertical line
            plot_x_range = [min_x_val-self.path_margin*(path_x_range+1), max_x_val+self.path_margin*(path_x_range+1)]
        else:
            plot_x_range = [min_x_val-self.path_margin*path_x_range, max_x_val+self.path_margin*path_x_range]
        
        if len(list(set(y_vals))) == 1:
            # y values form a horizontal line
            plot_y_range = [min_y_val-self.path_margin*(path_y_range+1), max_y_val+self.path_margin*(path_y_range+1)]
        else:
            plot_y_range = [min_y_val-self.path_margin*path_y_range, max_y_val+self.path_margin*path_y_range]

        return plot_x_range, plot_y_range

    
    @staticmethod
    def __get_xy_labs(plot_basis_x, plot_basis_y):
        try:
            xlab = ratlab(plot_basis_x)
        except:
            xlab = &#34;log a&#34;+chemlabel(plot_basis_x)
        try:
            ylab = ratlab(plot_basis_y)
        except:
            ylab = &#34;log a&#34;+chemlabel(plot_basis_y)

        return xlab, ylab


    def __plot_reaction_path_background(self, plot_basis_x, plot_basis_y,
                                        div_var_name, x_vals, y_vals,
                                        colormap=&#34;viridis&#34;, borders=0,
                                        field_minerals_exist=True, path_margin=0.25,
                                        plot_width=4, plot_height=3, ppi=122, res=300,
                                        annotation=None, annotation_coords=[0, 0],
                                        messages=False):
        
        plot_x_range, plot_y_range = self.__get_plot_range(x_vals, y_vals)

        xlab,ylab = self.__get_xy_labs(plot_basis_x, plot_basis_y)
        
        args = {plot_basis_x:plot_x_range+[res],
                plot_basis_y:plot_y_range+[res],
                &#34;T&#34;:self.T, &#34;P&#34;:self.P, &#34;messages&#34;:messages}
        
        if field_minerals_exist:
            
            # check each value of Xi to see which mineral is most predominant
            pred_minerals_from_fields = []
            for i,val in enumerate(x_vals):
                
                args_temp = {plot_basis_x:[x_vals[i], x_vals[i], 1],
                             plot_basis_y:[y_vals[i], y_vals[i], 1],
                             &#34;T&#34;:self.T, &#34;P&#34;:self.P, &#34;messages&#34;:messages}
                
                a = pyCHNOSZ.affinity(**args_temp)
                e = pyCHNOSZ.equilibrate(a, balance=self.__get_basis_from_elem(div_var_name), messages=messages)
                table = pyCHNOSZ.diagram(e, balance=self.__get_basis_from_elem(div_var_name), interactive=True, fig_out=False, plot_it=False, messages=messages)
                
                pred_minerals_from_fields.append(table[&#34;prednames&#34;][0])
            
            a = pyCHNOSZ.affinity(**args)
            e = pyCHNOSZ.equilibrate(a, balance=self.__get_basis_from_elem(div_var_name), messages=messages)
            
            table,fig = pyCHNOSZ.diagram_interactive(e,
                                colormap=colormap, borders=borders,
                                balance=self.__get_basis_from_elem(div_var_name),
                                width=plot_width*ppi, height=plot_height*ppi,
                                xlab=xlab, ylab=ylab, annotation=annotation,
                                annotation_coords=annotation_coords,
                                plot_it=False, messages=messages)
            
            return table, fig, pred_minerals_from_fields
        
        else:
            # empty plot upon
            fig = go.Figure(go.Scatter(x=pd.Series(dtype=object),
                                       y=pd.Series(dtype=object),
                                       mode=&#34;markers&#34;,
                                       ),
                           layout_xaxis_range=plot_x_range,
                           layout_yaxis_range=plot_y_range,
                           )

            fig.add_annotation(x=annotation_coords[0],
                               y=annotation_coords[1],
                               xref=&#34;paper&#34;,
                               yref=&#34;paper&#34;,
                               align=&#39;left&#39;,
                               text=annotation,
                               bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;,
                               showarrow=False)

            fig.update_layout(
                width=plot_width*ppi, height=plot_height*ppi,
                xaxis={&#34;title&#34;: xlab},
                yaxis={&#34;title&#34;: ylab},
                template=&#34;simple_white&#34;,
            )

            fig.update_yaxes(autorange=True)

            return None,fig,None # a table, diagram without regions, and a list of predicted minerals at each Xi


    @staticmethod
    def __calc_dissrxn_logK(mineral, T, P):

        logK = pyCHNOSZ.subcrt([mineral], coeff=[-1], property=&#39;logK&#39;, T=T, P=P,
                      show=False, messages=False)[&#34;out&#34;][&#34;logK&#34;].item()
        
        return logK

    
    def __add_reaction_path_to_plot(self, x_vals, y_vals, xi_vals, fig,
                                    basis_species_x, basis_species_y,
                                    path_margin=0.25, projected_points=[],
                                    path_line_type = &#34;markers+lines&#34;,
                                    path_line_color = &#34;black&#34;,
                                    path_point_fill_color = &#34;black&#34;,
                                    path_point_line_color = &#34;black&#34;,
                                    projected_point_fill_color = &#34;white&#34;,
                                    projected_point_line_color = &#34;black&#34;):

        min_x_val = min(x_vals)
        min_y_val = min(y_vals)
        max_x_val = max(x_vals)
        max_y_val = max(y_vals)

        path_x_range = max_x_val - min_x_val
        path_y_range = max_y_val - min_y_val

        xlab,ylab = self.__get_xy_labs(basis_species_x, basis_species_y)
        
        with np.errstate(divide=&#39;ignore&#39;):
            log_xi_vals = [round(np.log10(val), 4) for val in xi_vals]
            log_xi_vals = [&#34;N/A&#34; if np.isinf(val) else val for val in log_xi_vals]
        
        
        if path_line_type in [&#34;markers+lines&#34;, &#34;lines&#34;]:
            fig.add_trace(
                go.Scatter(
                    x=x_vals,
                    y=y_vals,
                    line=go.scatter.Line(color=path_line_color),
                    mode=&#39;lines&#39;,
                    showlegend=True,
                    name=&#39;reaction path&#39;,
                    customdata = np.stack((xi_vals, log_xi_vals), axis=-1),
                    hovertemplate = &#39;Xi: %{customdata[0]}&lt;br&gt;log Xi: %{customdata[1]}&lt;br&gt;&#39;+xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab+&#39;: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    legendgroup=&#39;reaction path&#39;,
                )
            )
        
        
        if len(projected_points) &gt; 0 and path_line_type in [&#34;markers+lines&#34;, &#34;markers&#34;]:
            
            x_vals_real = []
            x_vals_projected = []
            y_vals_real = []
            y_vals_projected = []
            xi_vals_real = []
            xi_vals_projected = []
            for i,p in enumerate(projected_points):
                if p == &#34;real&#34;:
                    x_vals_real.append(x_vals[i])
                    y_vals_real.append(y_vals[i])
                    xi_vals_real.append(xi_vals[i])
                else:
                    x_vals_projected.append(x_vals[i])
                    y_vals_projected.append(y_vals[i])
                    xi_vals_projected.append(xi_vals[i])
                    
            np.seterr(divide=&#39;ignore&#39;) # todo: reset np warnings
            log_xi_vals_real = [round(np.log10(val), 4) for val in xi_vals_real]
            log_xi_vals_real = [&#34;N/A&#34; if np.isinf(val) else val for val in log_xi_vals_real]
            log_xi_vals_projected = [round(np.log10(val), 4) for val in xi_vals_projected]
            log_xi_vals_projected = [&#34;N/A&#34; if np.isinf(val) else val for val in log_xi_vals_projected]
                    
            if len(x_vals_real) &gt; 0:
                fig.add_trace(
                    go.Scatter(
                        x=x_vals_real,
                        y=y_vals_real,
                        marker=dict(
                            color=path_point_fill_color,
                            line=dict(
                                color=path_point_line_color,
                                width=2
                            )
                        ),
                        mode=&#39;markers&#39;,
                        showlegend=False,
                        name=&#39;reaction path&#39;,
                        customdata = np.stack((xi_vals_real, log_xi_vals_real), axis=-1),
                        hovertemplate = &#39;Xi: %{customdata[0]}&lt;br&gt;log Xi: %{customdata[1]}&lt;br&gt;&#39;+xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab+&#39;: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                        legendgroup=&#39;reaction path&#39;,
                    )
                )
            if len(x_vals_projected) &gt; 0:
                
                fig.add_trace(
                    go.Scatter(
                        x=x_vals_projected,
                        y=y_vals_projected,
                        marker=dict(
                            color=projected_point_fill_color,
                            line=dict(
                                color=projected_point_line_color,
                                width=2
                            )
                        ),
                        mode=&#39;markers&#39;,
                        showlegend=False,
                        name=&#39;reaction path&#39;,
                        customdata = np.stack((xi_vals_projected, log_xi_vals_projected), axis=-1),
                        hovertemplate = &#39;Xi: %{customdata[0]}&lt;br&gt;log Xi: %{customdata[1]}&lt;br&gt;&#39;+xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab+&#39;: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                        legendgroup=&#39;reaction path&#39;,
                    )
                )
            

        fig.update_xaxes(range=self.__get_plot_range(x_vals, y_vals)[0], autorange=False)
        fig.update_yaxes(range=self.__get_plot_range(x_vals, y_vals)[1], autorange=False)

        return fig

    
    def __plot_reaction_path_main(self,
                                  triad, T=25, P=1, path_margin=0.25,
                                  flip_xy=False,
                                  show_annotation=False,
                                  annotation_coords=[0,0],
                                  show_nonparticipating_mineral_lines = False,
                                  minerals_to_show=[],
                                  path_line_type = &#34;markers+lines&#34;,
                                  path_line_color = &#34;black&#34;,
                                  path_point_fill_color = &#34;black&#34;,
                                  path_point_line_color = &#34;black&#34;,
                                  projected_point_color = &#34;white&#34;,
                                  projected_point_fill_color= &#34;white&#34;,
                                  projected_point_line_color = &#34;black&#34;,
                                  h_line_color=&#34;red&#34;,
                                  v_line_color=&#34;blue&#34;,
                                  d_line_color=&#34;orange&#34;,
                                  res=300,
                                  plot_width=4,
                                  plot_height=3,
                                  ppi=122,
                                  colormap=&#34;viridis&#34;,
                                  borders=0,
                                  projected_points=[],
                                  first_pass=False):

        e_pair = triad[0:2]
        
        if len(triad) == 3:
            div_var_name = triad[2]
        elif len(triad) == 2:
            div_var_name = &#34;None&#34;

        if flip_xy:
            e_pair.reverse()
            
        basis_species_x = self.__get_basis_from_elem(e_pair[0])
        basis_species_y = self.__get_basis_from_elem(e_pair[1])

        basis_sp_list = list(set([self.__get_basis_from_elem(e) for e in triad] + [&#34;H+&#34;,&#34;H2O&#34;]))
    
        try:
            pyCHNOSZ.basis(basis_sp_list)
        except:
            pyCHNOSZ.basis(basis_sp_list + [&#34;H2&#34;])
        
        elems = []
        for elem in triad:
            elems.append(elem.split(&#34;+&#34;)[0].split(&#34;-&#34;)[0])
        
        mineral_names = []
        for elem in triad:
            elem = elem.split(&#34;+&#34;)[0].split(&#34;-&#34;)[0]
            m_idx = pyCHNOSZ.retrieve((elem), list(set([&#34;O&#34;, &#34;H&#34;]+elems)), state=[&#34;cr&#34;], messages=False)
            if len(m_idx) &gt; 0:
                mineral_names += list(pyCHNOSZ.info(m_idx, messages=False)[&#34;name&#34;])
        
        # exclude inactive minerals
        mineral_names_active = [m for m in mineral_names if m in list(self.df[&#34;name&#34;])]
        mineral_names = list(set(mineral_names_active))
        
        mineral_formula_ox = [self.__get_elem_ox_of_interest_in_minerals(m) for m in mineral_names]
        mineral_formula_ox_singles = [e if len(e)==1 else [] for e in mineral_formula_ox]
        mineral_formula_ox_doubles = [e if len(e)==2 else [] for e in mineral_formula_ox]
        mineral_formula_ox_triples = [e if len(e)==3 else [] for e in mineral_formula_ox]
        
        retrieved_minerals = []
        for i,s in enumerate(mineral_formula_ox_singles):
            if [e_pair[0]] == s:
                retrieved_minerals.append(mineral_names[i])
        x_minerals_to_plot = retrieved_minerals

        retrieved_minerals = []
        for i,s in enumerate(mineral_formula_ox_singles):
            if [e_pair[1]] == s:
                retrieved_minerals.append(mineral_names[i])
        y_minerals_to_plot = retrieved_minerals

        xy_minerals_to_plot = []
        for i,s in enumerate(mineral_formula_ox_doubles):
            if e_pair[0] in s and e_pair[1] in s:
                xy_minerals_to_plot.append(mineral_names[i])

        if len(x_minerals_to_plot) &gt; 1:
            pyCHNOSZ.species(x_minerals_to_plot, add=True)
        if len(y_minerals_to_plot) &gt; 1:
            pyCHNOSZ.species(y_minerals_to_plot, add=True)
        if len(xy_minerals_to_plot) &gt; 1:
            pyCHNOSZ.species(xy_minerals_to_plot, add=True)

#         print(&#34;x, y, xy&#34;)
#         print(x_minerals_to_plot)
#         print(y_minerals_to_plot)
#         print(xy_minerals_to_plot)
            
        field_minerals_to_plot = []
        for i,s in enumerate(mineral_formula_ox_triples):
            if e_pair[0] in s and e_pair[1] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
        for i,s in enumerate(mineral_formula_ox_doubles):
            if e_pair[0] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
            elif e_pair[1] in s and div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
        for i,s in enumerate(mineral_formula_ox_singles):
            if div_var_name in s:
                field_minerals_to_plot.append(mineral_names[i])
                
        field_minerals_exist = True
        try:
            # get minerals relevant to plotted element pair
            pyCHNOSZ.species(field_minerals_to_plot)#, add=True)
        except:
            field_minerals_exist = False
        
#         print(&#34;field minerals&#34;)
#         print(field_minerals_to_plot)
    
        xi_vals, x_vals, y_vals = self.__get_reaction_path(basis_species_x, basis_species_y, div_var_name)
            
        
        if self.P &lt;= 1:
            bar_bars = &#34;bar&#34;
        else:
            bar_bars = &#34;bars&#34;
        
        if show_annotation and div_var_name != &#34;None&#34;:
            annotation = &#34;Balanced on: &#34;+chemlabel(self.__get_basis_from_elem(div_var_name))+&#34;&lt;br&gt;&#34;+&#39;%g&#39;%(self.T)+&#34; C, &#34;+&#39;%g&#39;%(self.P)+&#34; &#34;+bar_bars
        elif show_annotation:
            annotation = &#39;%g&#39;%(self.T)+&#34; C, &#34;+&#39;%g&#39;%(self.P)+&#34; &#34;+bar_bars
        else:
            annotation = None
        
        table,fig,pred_minerals_from_fields = self.__plot_reaction_path_background(
            basis_species_x, basis_species_y, div_var_name, x_vals, y_vals,
            plot_width=plot_width, plot_height=plot_height, ppi=ppi, res=res,
            colormap=colormap, borders=borders,
            annotation_coords=annotation_coords,
            field_minerals_exist=field_minerals_exist, path_margin=self.path_margin,
            annotation=annotation, messages=False)

        # plot minerals with a single element of interest as a line
        plot_x_range, plot_y_range = self.__get_plot_range(x_vals, y_vals)
        
        line_styles = [&#39;dot&#39;, &#39;dash&#39;, &#39;dashdot&#39;, &#39;longdash&#39;, &#39;longdashdot&#39;]
        line_i = 0
        line_width = 1
        
        if first_pass:
            fig = None
        else:
            for mineral in x_minerals_to_plot + y_minerals_to_plot + xy_minerals_to_plot:
                
                if not show_nonparticipating_mineral_lines and mineral not in list(self.moles_product_minerals.columns) and mineral not in minerals_to_show:
                    continue
                
                # deal with mineral line style (dot, dashed, etc.)
                if line_i % 5 == 0:
                    if line_i != 0:
                        line_width += 0.5
                    line_i = 0

                    
                line_style = line_styles[line_i]
                    
                eoi = self.__get_elem_ox_of_interest_in_minerals(mineral)

                logK = self.__calc_dissrxn_logK(mineral, T, P)
                mineral_formula_dict = self.__get_mineral_elem_ox_dict_interest(mineral)

                xlab,ylab = self.__get_xy_labs(basis_species_x, basis_species_y)
                
                if len(eoi) == 1:

                    # if the element of interest is not in the current element pair, move on
                    if eoi[0] not in e_pair:
                        continue

                    if self.__get_elem_ox_of_interest_in_minerals(mineral)[0] == e_pair[0]:
                        # vertical line
                        x0, x1 = (1/mineral_formula_dict[e_pair[0]])*logK, (1/mineral_formula_dict[e_pair[0]])*logK
                        y0 = min(plot_y_range)
                        y1 = max(plot_y_range)
                        color = v_line_color
                        hovertemplate=mineral+&#39;&lt;br&gt;&#39;+xlab+&#39; = &#39;+str(round(x0, 3))
                    elif self.__get_elem_ox_of_interest_in_minerals(mineral)[0] == e_pair[1]:
                        # horizontal line
                        y0, y1 = (1/mineral_formula_dict[e_pair[1]])*logK, (1/mineral_formula_dict[e_pair[1]])*logK
                        x0 = min(plot_x_range)
                        x1 = max(plot_x_range)
                        color=h_line_color
                        hovertemplate=mineral+&#39;&lt;br&gt;&#39;+ylab+&#39; = &#39;+str(round(y0))

                if len(eoi) == 2:
                    
                    line_slope = mineral_formula_dict[e_pair[0]]/mineral_formula_dict[e_pair[1]]
                    
                    x0 = min(plot_x_range)
                    x1 = max(plot_x_range)
                    y0 = (1/mineral_formula_dict[e_pair[1]])*logK - line_slope*x0
                    y1 = (1/mineral_formula_dict[e_pair[1]])*logK - line_slope*x1
                    
                    intercept = (1/mineral_formula_dict[e_pair[1]])*logK
                    
                    color = d_line_color
                    
                    hovertemplate = mineral+&#39;&lt;br&gt;slope = &#39;+str(round(line_slope))+&#39;&lt;br&gt;intercept = &#39;+str(round(intercept))+&#39;&lt;extra&gt;&lt;/extra&gt;&#39;

                fig.add_trace(
                    go.Scatter(x=[x0, x1], y=[y0, y1], mode=&#34;lines&#34;,
                               name=mineral,
                               line=dict(color=color, width=line_width, dash=line_style),
                               hovertemplate=hovertemplate,
                              ),
                )
                
                line_i += 1
        
            fig = self.__add_reaction_path_to_plot(x_vals, y_vals, xi_vals, fig,
                                                   basis_species_x, basis_species_y,
                                                   path_margin=self.path_margin,
                                                   projected_points=projected_points,
                                                   path_line_type=path_line_type,
                                                   path_line_color=path_line_color,
                                                   path_point_fill_color=path_point_fill_color,
                                                   path_point_line_color=path_point_line_color,
                                                   projected_point_fill_color=projected_point_fill_color,
                                                   projected_point_line_color=projected_point_line_color)
        
        pred_minerals_from_lines = x_minerals_to_plot+y_minerals_to_plot+xy_minerals_to_plot
        return fig, pred_minerals_from_fields, pred_minerals_from_lines

    
    def __get_xlab_xvar(self, x_type):
    
        x_type_dict = {
            &#34;logxi&#34; : [&#34;log Xi&#34;, &#34;log Xi&#34;],
            &#34;xi&#34; : [&#34;Xi&#34;, &#34;Xi&#34;],
            &#34;temperature&#34; : [&#34;Temp(C)&#34;, &#34;Temperature, C&#34;],
            &#34;pressure&#34; : [&#34;Press(bars)&#34;, &#34;Pressure, bars&#34;],
            &#34;pH&#34; : [&#34;pH&#34;, &#34;pH&#34;],
            &#34;pmH&#34; : [&#34;pmH&#34;, &#34;pmH&#34;],
            &#34;logfO2&#34; : [&#34;log fO2&#34;, &#34;log &lt;i&gt;f&lt;/i&gt;O&lt;sub&gt;2&lt;/sub&gt;&#34;],
            &#34;Eh&#34; : [&#34;Eh(v)&#34;, &#34;Eh, volts&#34;],
            &#34;pe&#34; : [&#34;pe&#34;, &#34;pe&#34;],
            &#34;aw&#34; : [&#34;aw&#34;, &#34;aw&#34;],
        }
        
        if x_type not in x_type_dict.keys():
            self.err_handler.raise_exception((&#34;x_type must be set to either &#34;
                &#34;&#39;logxi&#39;, &#39;xi&#39;, &#39;temperature&#39;, &#39;pressure&#39;, &#39;pH&#39;, &#39;pmH&#39;,&#34;
                &#34;&#39;log fO2&#39;, &#39;Eh(v)&#39;, &#39;pe&#39;, or &#39;aw&#39;.&#34;))
        
        xvar = x_type_dict[x_type][0]
        xlab = x_type_dict[x_type][1]
            
        return xlab, xvar
    
    
    def plot_elements(self, plot_elements=None, units=&#34;molality&#34;, log=True,
                      x_type=&#34;logxi&#34;, plot_width=4, plot_height=3, ppi=122,
                      ylim=None, show_legend=True, charge_sign_at_end=False,
                      save_as=None, save_format=None, save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of the log activities of aqueous species as a
        function of the log of the extent of reaction (log Xi).
        
        Parameters
        ----------
        plot_elements : list of str, optional
            A list of elements to plot. If undefined, every element will be
            plotted at once.
        
        units : str, default &#34;molality&#34;
            Units of elemental abundance to plot. Can be &#34;molality&#34; or &#34;ppm&#34;.
        
        log : bool, default True
            Display elemental abundances in log scale?
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        ylim : list of two numeric values, optional
            Minimum and maximum value of the y-axis.
            
        show_legend : bool, default True
            Show the legend?
            
        charge_sign_at_end : bool, default False
            Display charge with sign after the number (e.g. SO4 2-)?
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        title = &#34;Concentrations of dissolved elements&#34;
        if units == &#34;molality&#34;:
            df = pd.concat([self.dissolved_elements_molal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;{}molality&#34;
        elif units == &#34;ppm&#34;:
            df = pd.concat([self.dissolved_elements_ppm, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;{}ppm&#34;
#             elif units == &#34;molarity&#34;:

        plot_columns = [col for col in df.columns]
        if isinstance(plot_elements, list):
            plot_columns_temp = [col for col in plot_columns if col in plot_elements]
            plot_columns = plot_columns_temp
            
        df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
        df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
        df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel, charge_sign_at_end=charge_sign_at_end)

        df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
            if log:
                df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
                ylab = ylab.format(&#34;log &#34;)
        if not log:
            ylab = ylab.format(&#34;&#34;)
        
        xlab, xvar = self.__get_xlab_xvar(x_type)

        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None,
                          showlegend=show_legend,
                          yaxis={&#39;showexponent&#39;: &#39;all&#39;,
                                 &#39;exponentformat&#39;: &#39;power&#39;},
                         )

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})
            
        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)

        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        return fig
    
    
    def plot_pH(self, x_type=&#34;logxi&#34;, show_neutrality=True, title=None,
                plot_width=4, plot_height=3, ppi=122, ylim=None, save_as=None,
                save_format=None, save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of pH as a function of the log of the extent of
        reaction (log Xi) or some other variable.
        
        Parameters
        ----------
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
        
        show_neutrality : bool, default True,
            Display a reference line representing neutral pH? Setting this
            option to True requires a thermodynamic database in a WORM-style CSV
            format, e.g., &#39;wrm_data.csv&#39;.
        
        title : str
            Title of the plot to display.
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        ylim : list of two numeric values, optional
            Minimum and maximum value of the y-axis.
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;

        df = copy.deepcopy(self.misc_params)
        
        xlab, xvar = self.__get_xlab_xvar(x_type)
        
        if x_type == &#34;logxi&#34;:
            with np.errstate(divide=&#39;ignore&#39;):
                df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])

        fig = px.line(df, x=xvar, y=&#34;pH&#34;, template=&#34;simple_white&#34;,
                      width=plot_width*ppi,  height=plot_height*ppi,
                      labels=dict(value=&#34;pH&#34;, x=xlab), render_mode=&#39;svg&#39;,
                      )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=&#34;pH&#34;,
                          showlegend=False)
        
        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
        
        if show_neutrality and isinstance(self.thermo.csv_db, pd.DataFrame):
            _, df_pH = self.plot_energy(species=[&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;],
                                        stoich=[-1, 1, 1],
                                        divisor=-2,
                                        x_type=x_type,
                                        y_type=&#34;logK&#34;,
                                        df_out=True,
                                        )
            
            fig.add_trace(go.Scatter(x=df_pH[xvar],
                                     y=df_pH[&#34;logK&#34;],
                                     mode=&#39;lines&#39;,
                                     name=&#39;neutral pH&#39;,
                                     showlegend=True,
                                     hovertemplate = xlab+&#39;: %{x}&lt;br&gt;pH: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                                     line=dict(color=&#39;silver&#39;,
                                               width=3,
                                               dash=&#39;dot&#39;)
                                    ))

            fig[&#39;data&#39;][0][&#39;showlegend&#39;]=True
            fig[&#39;data&#39;][0][&#39;name&#39;]=&#39;pH&#39;
            fig[&#39;data&#39;][1][&#39;showlegend&#39;]=True
            fig[&#39;data&#39;][1][&#39;name&#39;]=&#39;neutral pH&#39;
            fig.update_layout(showlegend=True)

            
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        return fig
    
    
    def plot_product_minerals(self, show_reactant_minerals=False,
                              plot_minerals=None, x_type=&#34;logxi&#34;, y_type=&#34;mole&#34;,
                              log_y=True, df_out=False, markers=False,
                              plot_width=4, plot_height=3, ppi=122, ylim=None,
                              show_legend=True, save_as=None, save_format=None,
                              save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of the log moles of product minerals as a
        function of the log of the extent of reaction (log Xi) or some other
        variable.
        
        Parameters
        ----------
        show_reactant_minerals : bool, default False
            Include log moles of reactant minerals?
            
        plot_minerals : list, optional
            List of minerals to plot. Useful for isolating one or more
            minerals.
            
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
            
        y_type : str, default &#39;mole&#39;
            The variable to plot on the y-axis. Can be either &#39;mole&#39; (for moles
            of minerals), &#39;mass&#39; (for masses of minerals), or &#39;volume&#39; (for
            volumes of minerals).
        
        log_y : bool, default True
            Should the y-axis be logarithmic?
            
        df_out : bool, default False
            Should a dataframe of values also be returned? For example, if
            `y_type` is set to &#39;volume&#39;, should a table of mineral volumes be
            returned?
            
        markers : bool, default True
            Add circular markers to lines to indicate calculation steps?
            
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        ylim : list of two numeric values, optional
            Minimum and maximum value of the y-axis.
            
        show_legend : bool, default True
            Show the legend?
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
            
        df : a Pandas dataframe
            A dataframe is only returned if `df_out` is set to True (it is
            set to False by default).
        
        &#34;&#34;&#34;
        
        xlab, xvar = self.__get_xlab_xvar(x_type)
        
        if show_reactant_minerals:
            df = pd.concat([self.moles_minerals, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            title = &#34;{} of reactant and product minerals&#34;
        else:
            df = pd.concat([self.moles_product_minerals, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            title = &#34;{} of product minerals&#34;
            
        if log_y:
            log_text = &#34;log &#34;
        else:
            log_text = &#34;&#34;

        # sort in order of appearance along Xi
        sort_order = list(self.moles_minerals.columns)
        
        sort_order = [v for v in sort_order if v not in self.misc_params.columns]
            
        if y_type == &#34;mole&#34;:
            ylab = &#34;{}moles&#34;.format(log_text)
            title = title.format(log_text, &#34;Moles&#34;)
        elif y_type == &#34;mass&#34;: # not yet supported
            y_lab = &#34;{}grams&#34;.format(log_text)
            title = title.format(log_text, &#34;Masses&#34;)
            self.err_handler.raise_exception(&#34;Plotting mineral masses is not yet &#34;
                    &#34;supported.&#34;)
        elif y_type == &#34;volume&#34;:
            ylab = &#34;{}cm&lt;sup&gt;3&lt;/sup&gt;&#34;.format(log_text)
            title = title.format(&#34;Volumes&#34;)
            temps = df[&#34;Temp(C)&#34;]
            
            minerals = [col for col in df.columns if col not in list(self.misc_params.columns)]

            for i,T in enumerate(temps):
                for ii,mineral in enumerate(minerals):
                    mineral_df = copy.deepcopy(self.df[self.df[&#34;name&#34;]==mineral])
                    polymorph_idxs = []
                    for iii in range(0, mineral_df.shape[0]): # loop through mineral polymorphs

                        if float(T) &lt; float(list(mineral_df[&#34;z.T&#34;])[0]):
                            polymorph_idxs.append(iii)
                    if len(polymorph_idxs)==0:
                        polymorph_idx = iii
                    else:
                        polymorph_idx = polymorph_idxs[0]


                    partial_molal_volume = list(mineral_df[&#34;V&#34;])[polymorph_idx]

                    df.at[i, mineral] = df[mineral][i]*partial_molal_volume
        else:
            self.err_handler.raise_exception(&#34;y_type must be either &#39;mole&#39;, &#34;
                        &#34;&#39;mass&#39;, or &#39;volume&#39;.&#34;)
            
        
        plot_columns = [col for col in df.columns if col not in list(self.misc_params.columns)]

        if isinstance(plot_minerals, list):
            plot_columns_temp = [col for col in plot_columns if col in plot_minerals]
            plot_columns = plot_columns_temp
            
        plot_columns = sorted(plot_columns, key=sort_order.index)
        
        df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
        df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
        
        df = df[df[&#34;variable&#34;] != &#34;None&#34;]

        df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
            if log_y:
                df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)
                df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])

        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                      width=plot_width*ppi,  height=plot_height*ppi, markers=markers,
                      labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                      )
        
        df_to_return = copy.deepcopy(df)
        
        # add lines that go to -9999 (representing -Inf) in log y plots
        if log_y:
            if not isinstance(ylim, list):
                # grab the automatic y-axis range from the plot, above
                full_fig = fig.full_figure_for_development(warn=False)
                ylim = list(full_fig.layout.yaxis.range)
                
            # add new rows
            for irow in range(0, df.shape[0]):
                if not isnan(df[&#34;value&#34;].iloc[irow]) and irow != 0 and irow != df.shape[0]-1:
                    if isnan(df[&#34;value&#34;].iloc[irow-1]):
                        
                        df_dict = {}
                        for col in list(self.misc_params.columns)+[&#34;log Xi&#34;]:
                            df_dict[col] = df.loc[irow-1, col]
                        df_dict[&#34;variable&#34;] = df.loc[irow-1, &#34;variable&#34;]
                        df_dict[&#34;value&#34;] = df.loc[irow-1, &#34;value&#34;]
                            
                        new_row = pd.DataFrame(df_dict, index=[irow-1])
                        df = pd.concat([df.iloc[:irow], new_row, df.iloc[irow:]]).reset_index(drop=True)
                        irow=0
                        
                    if isnan(df[&#34;value&#34;].iloc[irow+1]):
                        
                        df_dict = {}
                        for col in list(self.misc_params.columns)+[&#34;log Xi&#34;]:
                            df_dict[col] = df.loc[irow+1, col]
                        df_dict[&#34;variable&#34;] = df.loc[irow+1, &#34;variable&#34;]
                        df_dict[&#34;value&#34;] = df.loc[irow+1, &#34;value&#34;]
                        
                        new_row = pd.DataFrame(df_dict, index=[irow+1])
                        df = pd.concat([df.iloc[:irow], new_row, df.iloc[irow:]]).reset_index(drop=True)
                        irow=0
            
            # fill new rows with -9999 value
            for irow in range(0, df.shape[0]):
                if not isnan(df[&#34;value&#34;].iloc[irow]) and irow != 0 and irow != df.shape[0]-1:
                    if isnan(df[&#34;value&#34;].iloc[irow-1]):
                        df.loc[irow-1, &#34;value&#34;] = -9999
                    if isnan(df[&#34;value&#34;].iloc[irow+1]):
                        df.loc[irow+1, &#34;value&#34;] = -9999
                        
            # re-create the plot with log values down to -9999. This will screw up the
            # automatic y-axis range, but we grabbed it from the first generated plot.
            # We will reset the range in update_layout(yaxis_range) a little later.
            fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                          width=plot_width*ppi,  height=plot_height*ppi, markers=markers,
                          labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                          )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None,
                          showlegend=show_legend)
        
        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})
        
        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
        
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
        
        if df_out:
            df_to_return = pd.pivot_table(df_to_return, index=&#39;log Xi&#39;, columns=&#39;variable&#39;, values=&#39;value&#39;).reset_index()
            df_to_return.columns = [col for col in df_to_return.columns[:]] # make index column name blank
            return df_to_return, fig
        else:
            return fig

    
    def plot_aqueous_species(self, plot_basis=False, plot_species=None,
                             x_type=&#34;logxi&#34;, y_type=&#34;log activity&#34;,
                             initially_visible=None, show_legend=True,
                             charge_sign_at_end=False,
                             plot_width=4, plot_height=3, ppi=122, xlim=None,
                             ylim=None, save_as=None, save_format=None,
                             save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of the log activities of aqueous species as a
        function of the log of the extent of reaction (log Xi) or some other
        variable.
        
        Parameters
        ----------
        plot_basis : bool, default False
            Plot basis species only?
        
        plot_species : list of str, optional
            A list of aqueous species to plot. If undefined, every species at
            will be plotted at once.
        
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
        
        y_type : str, default &#39;log activity&#39;
            The variable to plot on the y-axis. Can be either &#39;log activity&#39;,
            &#39;molality&#39;, or &#39;log molality&#39;.
        
        initially_visible : list of str, optional
            A list of aqueous species that will be visible on the plot
            initially. All other species will be hidden, but can still be
            toggled back on in the legend.
        
        show_legend : bool, default True
            Show the legend?
        
        charge_sign_at_end : bool, default False
            Display charge with sign after the number (e.g. SO4 2-)?
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        xlim, ylim : list of two numeric values, optional
            Minimum and maximum value of the x-axis and y-axis, respectively.
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        if plot_basis:

            df = pd.concat([self.basis_logact, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            title = &#34;Solute basis species&#34;
            ylab = &#34;log activity&#34;

        else:
            if y_type == &#34;log activity&#34;:
                df = pd.concat([self.aq_distribution_logact, self.misc_params[self.misc_params.columns[1:]]], axis=1)
                ylab = &#34;log activity&#34;
            elif y_type == &#34;molality&#34;:
                df = pd.concat([self.aq_distribution_molal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
                ylab = &#34;molality&#34;
            elif y_type == &#34;log molality&#34;:
                df = pd.concat([self.aq_distribution_logmolal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
                ylab = &#34;log molality&#34;
            title = &#34;Solute species&#34;
            
        plot_columns = [col for col in df.columns]
        if isinstance(plot_species, list):
            plot_columns_temp = [col for col in plot_columns if col in plot_species]
            plot_columns = plot_columns_temp
            
        df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
        df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
        
        df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel, charge_sign_at_end=charge_sign_at_end)

        df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
        
        xlab, xvar = self.__get_xlab_xvar(x_type)
        
        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        if isinstance(initially_visible, list):
            initially_visible_html = [chemlabel(sp, charge_sign_at_end=charge_sign_at_end) for sp in initially_visible]
            for trace in fig[&#39;data&#39;]: 
                if (not trace[&#39;name&#39;] in initially_visible_html):
                    trace[&#39;showlegend&#39;] = True
                    trace[&#39;visible&#39;] = &#39;legendonly&#39;
        
        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None,
                          showlegend=show_legend)

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
            
        if isinstance(xlim, list):
            fig.update_layout(xaxis_range=xlim)
            
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        return fig

    
    def plot_energy(self, species, stoich,
                    divisor=1, x_type=&#34;logxi&#34;, y_type=&#34;A&#34;, y_units=&#34;kcal&#34;, 
                    show_zero_line=False, limiting=None, xlab=None, ylab=None,
                    title=None, charge_sign_at_end=False, log_y=False,
                    plot_width=4, plot_height=3, ppi=122,
                    xlim=None, ylim=None, df_out=False,
                    save_as=None, save_format=None,
                    save_scale=1, print_logK_messages=False):
        
        &#34;&#34;&#34;
        Generate a line plot of the energy profile for a reaction as a
        function of the log of the extent of reaction (log Xi) or some other
        variable.
        
        Parameters
        ----------
        species : list of str
            A list of species that match the order of the stoichiometric
            reaction coefficients in the `stoich` parameter.

        stoich : list of numeric
            A list of stoichiometric reaction coefficients that match the order
            of the species in the `species` parameter.
        
        divisor : float, default 1
            Divide all values in the energy profile by this number. Useful for
            calculating energy per electron transferred or similar.
        
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
        
        y_type : str, default &#39;A&#39;
            The variable to plot on the y-axis. Can be either &#39;A&#39; (for chemical
            affinity), &#39;G&#39; (for Gibbs free energy, G), &#39;logK&#39; (for the log
            of the equilibrium constant), &#39;logQ&#39; (for the log of the reaction
            quotient), or &#39;E&#39; for energy supply.
        
        y_units : str, default &#39;kcal&#39;
            The unit that energy will be reported in (per mol for G and A, or
            per kg fluid for energy supply, or unitless for logK and logQ).
            Can be &#39;kcal&#39;, &#39;cal&#39;, &#39;J&#39;, or &#39;kJ&#39;.
        
        show_zero_line : bool, default False
            If True, displays a dotted line where affinity or G equals 0 (at
            equilibrium).
        
        limiting : str, optional
            Name of the species to act as the limiting reactant when calculating
            energy supply. If this parameter is left undefined, then a
            limiting reactant will be chosen automatically based on
            concentration and stoichiometry. This parameter is ignored unless
            `y_type` is set to &#39;E&#39; (energy supply).
        
        xlab, ylab : str, optional
            Custom x and y axis labels.
        
        title : str, optional
            Title of the plot to display.
        
        charge_sign_at_end : bool, default False
            Display charge with sign after the number (e.g. SO4 2- instead of
            SO4-2) in species names when the reaction is displayed in the plot
            title?
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        xlim, ylim : list of two numeric values, optional
            Minimum and maximum value of the x-axis and y-axis, respectively.
            
        df_out = bool, default False
            Return a pandas dataframe in addition to a figure?
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        print_logK_messages : bool, default False
            Print pyCHNOSZ messages while the logK of the reaction is
            calculated?
            
        Returns
        -------
        fig : Plotly figure object, optionally a Pandas Dataframe
            A line plot. If `df_out` is True, also returns a dataframe.
        &#34;&#34;&#34;
        # check that a thermodynamic CSV is being used
        if not isinstance(self.thermo.csv_db, pd.DataFrame):
            self.err_handler.raise_exception(&#34;The plot_energy() function requires &#34;
                    &#34;a thermodynamic database in a WORM-style CSV format, e.g., &#34;
                    &#34;&#39;wrm_data.csv&#39;. You may be getting this message because &#34;
                    &#34;a data0 or data1 file was used.&#34;)
        
        # check that the divisor is valid
        if isinstance(divisor, list) or isinstance(divisor, pd.Series):
            if len(divisor) != len(self.misc_params[&#34;Temp(C)&#34;]):
                self.err_handler.raise_exception(&#34;The length of the divisor is &#34;
                    &#34;not equal to the number of reported xi steps.&#34;)

        # check that the reaction is balanced
        formulas = []
        for s in species:
            if s == &#34;H+&#34;:
                formulas.append(&#34;H+&#34;)
            elif s == &#34;H2O&#34;:
                formulas.append(&#34;H2O&#34;)
            else:
                if s in list(self.thermo.csv_db[&#34;name&#34;]):
                    formulas.append(list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;formula&#34;])[0])
                else:
                    self.err_handler.raise_exception(&#34;Valid thermodynamic data &#34;
                            &#34;was not found for species &#34;+str(s)+&#34;&#34;)
                    
        missing_composition = check_balance(formulas, stoich)
        
        
        # check that there are valid limiting reactants when calculating energy
        # e.g., prevent issue when the only reactant is a mineral, etc.
        reactant_idx = [1 if i&lt;0 else 0 for i in stoich]
        reactants = [species[i] for i,idx in enumerate(reactant_idx) if idx == 1]
        invalid_limiting_reactants = []
        for r in reactants:
            if r not in [&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;]:
                if list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==r][&#34;state&#34;])[0] != &#34;aq&#34;:
                    invalid_limiting_reactants.append(r)
            else:
                invalid_limiting_reactants.append(r)
        if reactants == invalid_limiting_reactants and y_type == &#34;E&#34;:
            self.err_handler.raise_exception(&#34;Energy supply for this reaction &#34;
                &#34;cannot be calculated because none of the reactants are &#34;
                &#34;limiting. A limiting reactant must be aqueous and cannot be H+ &#34;
                &#34;or OH-.&#34;)
        
        if limiting != None:
            # check that the limiting reactant is in the thermodynamic database
            if limiting not in list(self.thermo.csv_db[&#34;name&#34;]):
                self.err_handler.raise_exception(&#34;Valid thermodynamic data was &#34;
                        &#34;not found for limiting reactant &#34;+str(limiting)+&#34;&#34;)
            
            # check that the limiting reactant is aqueous or gaseous
            if list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==limiting][&#34;state&#34;])[0] != &#34;aq&#34;:
                self.err_handler.raise_exception(&#34;The limiting reactant must &#34;
                        &#34;be an aqueous species.&#34;)
            
            # check that the limiting reactant is a reactant in the `species` parameter
            if limiting not in reactants:
                self.err_handler.raise_exception(&#34;The species specified as a &#34;
                        &#34;limiting reactant, &#39;&#34;+str(limiting)+&#34;&#39;, is not a &#34;
                        &#34;reactant in this reaction.&#34;)
                
        # format reaction equation
        equation_to_display = format_equation(
                                      species,
                                      stoich,
                                      charge_sign_at_end=charge_sign_at_end,
                                      )
        
        # create a dictionary of species logacts across xi
        s_logact_dict = {}
        s_molal_dict = {}
        for s in species:
            if s == &#34;H+&#34;:
                s_logact_dict[s] = [-pH for pH in list(self.misc_params[&#34;pH&#34;])]
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;pH&#34;])
            elif s == &#34;H2O&#34;:
                s_logact_dict[s] = [0]*len(self.misc_params[&#34;Temp(C)&#34;])
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;Temp(C)&#34;])
            elif list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;state&#34;])[0] not in [&#34;cr&#34;, &#34;liq&#34;]:
                if s in self.aq_distribution_logact.columns:
                    # aqueous species
                    s_logact_dict[s] = list(self.aq_distribution_logact[s])
                    s_molal_dict[s] = list(self.aq_distribution_molal[s])
                else:
                    self.err_handler.raise_exception(&#34;The species &#34;+str(s)+&#34; is &#34;
                            &#34;not among the distribution of aqueous species in &#34;
                            &#34;this calculation.&#34;)
            else:
                # liq and cr species
                s_logact_dict[s] = [0]*len(self.misc_params[&#34;Temp(C)&#34;])
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;Temp(C)&#34;])
                
            
        xlab, xvar = self.__get_xlab_xvar(x_type)
            
        if y_type not in [&#34;logK&#34;, &#34;logQ&#34;]:
            if y_units in [&#34;cal&#34;, &#34;kcal&#34;]:
                r_div = 4.184
            elif y_units in [&#34;J&#34;, &#34;kJ&#34;]:
                r_div = 1
            R = 8.314/r_div  # gas constant, unit = [cal/mol/K]

        if &#34;k&#34; in y_units:
            k_div = 1000
        else:
            k_div = 1
            
        y_list = []
        lr_name_list = []
        for i,T in enumerate(list(self.misc_params[&#34;Temp(C)&#34;])):
            
            if isinstance(divisor, list):
                divisor_i = divisor[i]
            else:
                divisor_i = divisor
            
            if y_type != &#34;logQ&#34;:
                logK = pyCHNOSZ.subcrt(
                              species,
                              stoich,
                              T=T,
                              P=list(self.misc_params[&#34;Press(bars)&#34;])[i],
                              show=False,
                              messages=print_logK_messages).out[&#34;logK&#34;]

                logK = float(logK.iloc[0])

            if y_type == &#34;logK&#34;:
                ylab_out = &#34;log K&#34;
                if title == None:
                    title = &#34;Equilibrium constant for the reaction&lt;br&gt;&#34;+equation_to_display
                y_list.append(round(logK/divisor_i, 4))
                df_y_name = &#34;logK&#34;
                continue
                

            logQ = sum([st*s_logact_dict[sp][i] for st,sp in zip(stoich,species)])

            if y_type == &#34;logQ&#34;:
                ylab_out = &#34;log Q&#34;
                if title == None:
                    title = &#34;Reaction quotient for the reaction&lt;br&gt;&#34;+equation_to_display
                y_list.append(round(logQ/divisor_i, 4))
                df_y_name = &#34;logQ&#34;
                continue
            
            else:
                A = 2.303 * R * (273.15+T) * (logK - logQ)  # affinity, unit = [cal/mol]
                A = A/k_div
                
                if title == None:
                    title = &#34;Energy profile for the reaction&lt;br&gt;&#34;+equation_to_display
                
                if y_type==&#34;G&#34;:
                    G = -A # gibbs free energy, unit = [cal/mol]
                    y_list.append(G/divisor_i)
                    ylab_out=&#34;G, {}/mol&#34;.format(y_units)
                    y_units_out = y_units+&#34;/mol&#34;
                elif y_type==&#34;A&#34;:
                    y_list.append(round(A/divisor_i, 4))
                    ylab_out=&#34;A, {}/mol&#34;.format(y_units)
                    y_units_out = y_units+&#34;/mol&#34;
                elif y_type==&#34;E&#34;:
                    
                    if not isinstance(limiting, str):
                        lrc_dict = {}
                        for i_s,s in enumerate(species):
                            # identify valid limiting reactants and record concentrations
                            # 1. negative coefficient (reactant)
                            # 2. can&#39;t be OH-, H+, H2O
                            # 3. can&#39;t be cr or liq
                            if stoich[i_s] &lt; 0 and s not in [&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;] and list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;state&#34;])[0] not in [&#34;cr&#34;, &#34;liq&#34;]:
                                lrc_dict[s] = s_molal_dict[s][i]/abs(stoich[i_s])
                    
                    if not isinstance(limiting, str):
                        lr_name = min(lrc_dict, key=lrc_dict.get)
                        lr_val = lrc_dict[lr_name]
                        
                        # handle situations where there might be multiple limiting reactants
                        lr_list = []
                        for k,v in zip(lrc_dict.keys(), lrc_dict.values()):
                            if v == lr_val:
                                lr_list.append(str(k))
            
                    else:
                        lr_list = [limiting]
                        
                    lr_list_formatted = [chemlabel(lr_name, charge_sign_at_end=charge_sign_at_end) for lr_name in lr_list]
                    if len(lr_list_formatted) &gt; 1:
                        lr_reported = &#34;, &#34;.join(lr_list_formatted)
                    else:
                        lr_reported = lr_list[0]
                        
                    lr_name = lr_list[0] # doesn&#39;t matter which lr is used to calculate
                    lr_concentration = s_molal_dict[lr_name][i]
                    lr_name_list.append(lr_reported)
                    lr_stoich = -stoich[species.index(lr_name)]
                    E = A * (lr_concentration/lr_stoich)

                    y_list.append(round(E/divisor_i, 4))
                    y_units_out = y_units+&#34;/kg fluid&#34;
                    ylab_out=&#34;Energy Supply, {}&#34;.format(y_units+&#34;/kg fluid&#34;)
#                     else:
#                         lr_name_list.append(&#34;NA&#34;)
#                         y_list.append(float(&#39;NaN&#39;))
#                         y_units_out = y_units+&#34;/kg fluid&#34;
#                         ylab_out=&#34;Energy Supply, {}&#34;.format(y_units+&#34;/kg fluid&#34;)

                df_y_name = y_type+&#34;, &#34;+y_units_out

            
        if xlab != None:
            xlab_out = xlab
        if ylab != None:
            ylab_out = ylab

        df = copy.deepcopy(self.misc_params)
        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
            
        df[df_y_name] = y_list

        
        fig = px.line(df, x=xvar, y=df_y_name, log_y=log_y,
                      width=plot_width*ppi, height=plot_height*ppi,
                      template=&#34;simple_white&#34;)
        
        if y_type==&#34;E&#34;:
            fig.add_trace(
                go.Scatter(
                    x=df[xvar],
                    y=df[df_y_name],
                    mode=&#39;lines&#39;,
                    customdata = lr_name_list,
                    hovertemplate = xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab_out+&#39;: %{y}&lt;br&gt;Limiting : %{customdata}&lt;extra&gt;&lt;/extra&gt;&#39;,
                )
            )
            fig.data[0].visible=False
        
        fig.update_layout(xaxis_title=xlab_out,
                          yaxis_title=ylab_out)
        
        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
            
        if isinstance(xlim, list):
            fig.update_layout(xaxis_range=xlim)
            
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        if show_zero_line:
            fig.add_hline(y=0, line_width=3, line_dash=&#34;dash&#34;, line_color=&#34;black&#34;)
            
        if df_out:
            return fig, df
        else:
            return fig
    
    
    def plot_mass_contribution(self, *args, x_type=&#34;xi&#34;, x_decimals=3,
                                     track_steps=True, keep_xi_order=False,
                                     **kwargs):
        
        &#34;&#34;&#34;
        Generate a bar plot of mass contributions (in mole percent) of aqueous
        species formed as a function of reaction progress Xi or some other
        variable.
        
        Parameters
        ----------
        *args : iterable
            Arguments to be passed to `Speciation.plot_mass_contribution`.

        x_type : str, default &#34;xi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.

        x_decimals : int
            Number of decimals to display in the numeric values of the x-axis
            variable defined by `x_type`.

        track_steps : bool, default True
            Show reported xi steps on x-axis ticks? Useful for plotting as a
            function of an x-axis variable that can be out-of-order, like
            Eh or temperature. This parameter will become True automatically
            if it will prevent column stacking (which happens if there are
            duplicate x-axis values).

        **kargs : dict
            Keyword arguments to be passed to `Speciation.plot_mass_contribution`.
            
        Returns
        -------
        fig : Plotly figure object
            A mass contribution bar plot.
        &#34;&#34;&#34;
        
        basis = args[0]
        
        xlab, kwargs[&#34;sample_label&#34;] = self.__get_xlab_xvar(x_type)
        
        df_sp = pd.concat([self.mass_contribution_dict.get(basis, &#34;error&#34;),
                           self.misc_params[self.misc_params.columns[1:]]], axis=1)
        
        with np.errstate(divide=&#39;ignore&#39;):
            df_sp[&#39;log Xi&#39;] = np.log10(df_sp[&#39;Xi&#39;])
        
        # handle display of the x axis variable
        # if number of decimals to display is too low, columns will stack
        # check to see if this happens, then increment x_decimals until the stacking problem is solved
        if x_decimals &lt; 0:
            msg = &#34;The parameter x_decimals must be greater than or equal to 0.&#34;
            self.err_handler.raise_exception(msg)
        original_x_decimals = copy.copy(x_decimals)
        
        len_unique_labels_rounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x)))
        len_unique_labels_unrounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]]))
        
        if len_unique_labels_rounded &lt; len_unique_labels_unrounded:
            x_decimals += 1
            solved_decimals = False
            for i in range(x_decimals, x_decimals+10):
                len_unique_labels_rounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x)))
                if len_unique_labels_rounded == len_unique_labels_unrounded:
                    if self.verbose &gt; 0:
                        print(&#34;Number of decimals to display for x-axis variable&#34;,
                              &#34;increased to&#34;, x_decimals, &#34;to prevent column stacking.&#34;)
                    solved_decimals = True
                    break
                else:
                    x_decimals += 1
            if not solved_decimals:
                msg = (&#34;X-axis value decimal formatting is resulting in column &#34;
                       &#34;stacking even after attempting 10 increments of x_decimals.&#34;)
                self.err_handler.raise_exception(msg)

        if isinstance(df_sp, str):
            msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
                   &#34;among available basis species: &#34;
                   &#34;{}&#34;.format(str(list(self.mass_contribution_dict.keys()))))
            self.err_handler.raise_exception(msg)
        
        df_sp[&#34;position&#34;] = list(range(0, df_sp.shape[0]))
        
        df_sp_melt = df_sp.melt(
                id_vars=list(self.misc_params.columns)+[&#34;log Xi&#34;, &#34;basis&#34;, &#34;factor&#34;, &#34;molality&#34;, &#34;position&#34;])
        
        df_sp_melt.rename(columns={kwargs[&#34;sample_label&#34;] : &#34;sample&#34;,
                                   df_sp_melt.columns[-2] : &#34;species&#34;,
                                   df_sp_melt.columns[-1] : &#34;percent&#34;,
                                   }, inplace=True)
                                      
        df_sp_melt = df_sp_melt[df_sp_melt[&#39;percent&#39;].notna()]
        
        if keep_xi_order:
            sample_order = [&#34;position&#34;, &#34;species&#34;, &#34;percent&#34;]
        else:
            sample_order = [&#34;sample&#34;, &#34;position&#34;, &#34;species&#34;, &#34;percent&#34;]
            
        df_sp_melt.sort_values(sample_order, axis=0, ascending=True, inplace=True)

        if df_sp_melt.dtypes[&#34;sample&#34;] != &#34;O&#34;: # if the column isn&#39;t formatted as a string
            if any([&#34;e&#34; in v2 for v2 in [str(v1) for v1 in df_sp_melt[&#39;sample&#39;]]]): # if value is in scientific notation
                df_sp_melt[&#39;sample&#39;] = df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x) # converts numeric to string
            else:
                df_sp_melt[&#39;sample&#39;] = [(&#39;{0:.&#39;+str(x_decimals)+&#39;f}&#39;).format(v) for v in df_sp_melt[&#39;sample&#39;]]
            
            
        if len(list(set(df_sp_melt[&#34;sample&#34;]))) != len(list(set(df_sp_melt[&#34;position&#34;]))) or track_steps:
            # handle duplicate x-axis values to prevent stacking
            temp_col = []
            for i,v in enumerate(df_sp_melt[&#34;sample&#34;]):
                temp_col.append(&#34; (step &#34;+str(list(df_sp_melt[&#34;position&#34;])[i])+&#34;)&#34;)
            df_sp_melt[&#34;sample&#34;] = [str(v)+a for v,a in zip(df_sp_melt[&#34;sample&#34;], temp_col)]
            if not track_steps and self.verbose &gt; 0:
                print(&#34;Reported Xi step tracking has been added to x-axis ticks to prevent column stacking.&#34;)
            
        sp = Speciation(args={})
        sp.mass_contribution = df_sp_melt

        if not kwargs.get(&#34;plot_out&#34;, False):
            plot_out = False
        else:
            plot_out = True
        kwargs[&#34;plot_out&#34;] = True
        
        fig = sp.plot_mass_contribution(*args, **kwargs)
        
        fig.update_layout(
            xaxis_title=xlab, # add an x axis title
        )
        
        if plot_out:
            return fig
        else:
            fig.show()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="AqEquil.MassTransfer.Mass_Transfer.process_tab"><code class="name flex">
<span>def <span class="ident">process_tab</span></span>(<span>tab_name, thermodata_csv)</span>
</code></dt>
<dd>
<div class="desc"><p>Process a TAB file (from EQ6) into a dictionary of Pandas dataframes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tab_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Path name of the TAB file generated by EQ6.</dd>
<dt><strong><code>thermodata_csv</code></strong> :&ensp;<code>str</code> or <code>Pandas dataframe</code></dt>
<dd>Path name of the WORM-styled thermodynamic database CSV used in the
EQ6 calculation. Alternately, the thermodynamic database itself as a
Pandas dataframe itself.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tab</code></strong> :&ensp;<code>a dict</code> of <code>Pandas dataframes</code></dt>
<dd>A dictionary of dataframes representing tables mined from the TAB
file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def process_tab(tab_name, thermodata_csv):
    
    &#34;&#34;&#34;
    Process a TAB file (from EQ6) into a dictionary of Pandas dataframes.
    
    Parameters
    ----------
    tab_name : str
        Path name of the TAB file generated by EQ6.
    
    thermodata_csv : str or Pandas dataframe
        Path name of the WORM-styled thermodynamic database CSV used in the
        EQ6 calculation. Alternately, the thermodynamic database itself as a
        Pandas dataframe itself.

    Returns
    -------
    tab : a dict of Pandas dataframes
        A dictionary of dataframes representing tables mined from the TAB
        file.
    &#34;&#34;&#34;
    
    if isinstance(thermodata_csv, str):
        thermo_db = pd.read_csv(thermodata_csv)
    else:
        thermo_db = thermodata_csv
    
    
    thermo_db_names = list(thermo_db[&#34;name&#34;])

    with open(tab_name, &#34;r&#34;) as tabfile:
        tab_lines = tabfile.readlines()

    tab = {}

    tables = [&#34;B1&#34;, &#34;B2&#34;, &#34;C1&#34;, &#34;C2&#34;, &#34;C3&#34;, &#34;C4&#34;,
              &#34;D1&#34;, &#34;D2&#34;, &#34;D3&#34;, &#34;D4&#34;, &#34;E1&#34;, &#34;E2&#34;,
              &#34;E3&#34;, &#34;J&#34;, &#34;K&#34;, &#34;P&#34;, &#34;Q&#34;, &#34;T&#34;, &#34;W&#34;]

    record_lines = False
    get_header = False
    recorded_lines = []
    for line in tab_lines:
        split_line = line.split(&#34;,&#34;)

        if True in [s in [&#34;Table &#34; + t for t in tables] for s in split_line]:
            get_header = True
            table_name = &#34; &#34;.join(split_line[1:-1])
            continue

        if get_header:
            header = split_line[1:-1]

            # handle instances where the tab file creates extra columns for things like &#34;albite,low&#34;
            if table_name in [&#34;Table P Moles of product minerals&#34;,
                              &#34;Table Q Saturation indices of potential product phases&#34;,
                              &#34;Table J Moles of reactants destroyed/created&#34;,
                              &#34;Table K Affinities of reactants (kcal)&#34;]:
                
                if table_name in [&#34;Table P Moles of product minerals&#34;,
                                  &#34;Table J Moles of reactants destroyed/created&#34;]:
                    new_header = [&#34;Xi&#34;, &#34;t(days)&#34;] # table P and J
                elif table_name == &#34;Table Q Saturation indices of potential product phases&#34;:
                    new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;H2O&#34;, &#34;Gas&#34;] # table Q
                elif table_name == &#34;Table K Affinities of reactants (kcal)&#34;:
                    new_header = [&#34;Xi&#34;, &#34;t(days)&#34;, &#34;Total&#34;]

                for i,h in enumerate(header):

                    if h != &#34;Xi&#34; and h != &#34;t(days)&#34; and h != &#34;H2O&#34; and h != &#34;Gas&#34; and h != &#34;Total&#34;:
                        if h not in thermo_db_names:
                            if header[i-1]+&#34;,&#34;+h in thermo_db_names:
                                new_header = new_header[:-1]
                                new_header.append(header[i-1]+&#34;,&#34;+h)
                            else:
                                new_header.append(h)
                        else:
                            new_header.append(h)

                header = new_header


            record_lines = True
            get_header = False
            continue

        if &#34;EndTable:&#34; in split_line:
            record_lines = False
            if len(recorded_lines) &gt; 0:
                df = pd.DataFrame(recorded_lines)
                recorded_lines = []
                df.columns = header
                tab[table_name] = df

        if record_lines:
            recorded_lines.append(split_line[1:-1])

    return tab</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="AqEquil.MassTransfer.Mass_Transfer.mine_6o_table"><code class="name flex">
<span>def <span class="ident">mine_6o_table</span></span>(<span>self, table_start='--- Distribution of Aqueous Solute Species ---', table_stop='Species with molalities less than', ignore=['', 'Species', '---'], col_index=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Mine a table in a '6o' EQ6 output file and consolidate results into a
dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table_start</code></strong> :&ensp;<code>str</code></dt>
<dd>A unique string that indicates the start of the table.</dd>
<dt><strong><code>table_stop</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A unique string that indicates the end of the table.</dd>
<dt><strong><code>ignore</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of strings representing lines to ignore when mining a table.
For example, it is prudent to ignore blank lines, or lines
containing the table column headers.
A line will be skipped if line.strip().split(' ')[0] matches any
of the strings in the given list.</dd>
<dt><strong><code>col_index</code></strong> :&ensp;<code>int</code>, default <code>-1</code></dt>
<dd>Integer representing the index of the table column to be mined.
The default is -1, which is the last column in the table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>Pandas dataframe</code></dt>
<dd>A dataframe with rows of the extent of reaction (Xi), and columns
containing the values of chemical species mined from the file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mine_6o_table(self,
                  table_start=&#34;--- Distribution of Aqueous Solute Species ---&#34;,
                  table_stop=&#34;Species with molalities less than&#34;,
                  ignore = [&#34;&#34;, &#34;Species&#34;, &#39;---&#39;],
                  col_index=-1):
    
    &#34;&#34;&#34;
    Mine a table in a &#39;6o&#39; EQ6 output file and consolidate results into a
    dataframe.
    
    Parameters
    ----------
    table_start : str
        A unique string that indicates the start of the table.

    table_stop : str, optional
        A unique string that indicates the end of the table.
    
    ignore : list of str
        A list of strings representing lines to ignore when mining a table.
        For example, it is prudent to ignore blank lines, or lines
        containing the table column headers.
        A line will be skipped if line.strip().split(&#39; &#39;)[0] matches any
        of the strings in the given list.
    
    col_index : int, default -1
        Integer representing the index of the table column to be mined.
        The default is -1, which is the last column in the table.
        
    Returns
    -------
    df : Pandas dataframe
        A dataframe with rows of the extent of reaction (Xi), and columns
        containing the values of chemical species mined from the file.
    &#34;&#34;&#34;
    
    lines = self.six_o_file_lines
    
    species = []
    xi_vals=[]
    collect_values = False
    for i in lines:
        if len(i.strip().split(&#39; &#39;)) &gt; 1 and i.strip().split(&#39; &#39;)[0] == &#34;Xi=&#34;:
            this_xi_val = float(i.split(&#39; &#39;)[-1])
        if table_stop in i:
            collect_values = False
        if table_start in i:
            xi_vals.append(this_xi_val) # appending here prevents mismatch where there can be more Xi vals than tables to mine
            collect_values = True
        if collect_values:
            if i.strip().split(&#39; &#39;)[0] not in ignore:
                species.append(i.strip().split(&#39; &#39;)[0])

    species = list(set(species))
    
    species_dict = {&#34;Xi&#34;:xi_vals}
    
    if len(species) == 0:
        df = pd.DataFrame(species_dict)
        return df
    
    for s in species:

        vals=[]
        collect_values = False
        for i in lines:
            if collect_values and table_stop in i:
                # stop collecting
                collect_values = False
                if not got_value:
                    vals.append(np.nan)
            if table_start in i:
                # start collecting
                collect_values = True
                got_value = False
            if collect_values:
                if len(i.strip().split(&#39; &#39;)) &gt; 2 and i.strip().split(&#39; &#39;)[0] == s:
                    split_i = i.strip().split(&#39; &#39;)
                    split_i_clean = [v for v in split_i if v != &#39;&#39;]
                    val = split_i_clean[col_index]
                    try:
                        val = float(val)
                    except:
                        # if a value is not a float, e.g., 3.1450-100
                        if &#34;-&#34; in val:
                            val_list = val.split(&#34;-&#34;)
                            val = &#34;&#34;.join([val_list[0], &#34;E-&#34;, val_list[1]])
                            val = float(val)
                        elif &#34;+&#34; in val:
                            val_list = val.split(&#34;+&#34;)
                            val = &#34;&#34;.join([val_list[0], &#34;E&#34;, val_list[1]])
                            val = float(val)
                        elif &#34;SATD&#34; in val:
                            pass
                        else:
                            self.err_handler.raise_exception((&#34;Error: &#34;
                                &#34;Encountered a non-numeric value when mining &#34;
                                &#34;a .6o file: &#34;+val))
                    vals.append(val)
                    got_value = True
        species_dict[s] = vals
    
    df = pd.DataFrame(species_dict)
    
    if &#39;None&#39; in df.columns:
        df = df.drop([&#39;None&#39;], axis=1)
    
    return df</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_aqueous_species"><code class="name flex">
<span>def <span class="ident">plot_aqueous_species</span></span>(<span>self, plot_basis=False, plot_species=None, x_type='logxi', y_type='log activity', initially_visible=None, show_legend=True, charge_sign_at_end=False, plot_width=4, plot_height=3, ppi=122, xlim=None, ylim=None, save_as=None, save_format=None, save_scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a line plot of the log activities of aqueous species as a
function of the log of the extent of reaction (log Xi) or some other
variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_basis</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Plot basis species only?</dd>
<dt><strong><code>plot_species</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of aqueous species to plot. If undefined, every species at
will be plotted at once.</dd>
<dt><strong><code>x_type</code></strong> :&ensp;<code>str</code>, default <code>"logxi"</code></dt>
<dd>Variable to appear on the x-axis. Can be "logxi", "xi",
"temperature", "pressure", "pH", "pmH", "logfO2", "Eh", "pe", or
"aw".</dd>
<dt><strong><code>y_type</code></strong> :&ensp;<code>str</code>, default <code>'log activity'</code></dt>
<dd>The variable to plot on the y-axis. Can be either 'log activity',
'molality', or 'log molality'.</dd>
<dt><strong><code>initially_visible</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of aqueous species that will be visible on the plot
initially. All other species will be hidden, but can still be
toggled back on in the legend.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show the legend?</dd>
<dt><strong><code>charge_sign_at_end</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Display charge with sign after the number (e.g. SO4 2-)?</dd>
<dt><strong><code>plot_width</code></strong>, <strong><code>plot_height</code></strong> :&ensp;<code>numeric</code>, default <code>4 by 3</code></dt>
<dd>Width and height of the plot, in inches. Size of interactive plots
is also determined by pixels per inch, set by the parameter <code>ppi</code>.</dd>
<dt><strong><code>ppi</code></strong> :&ensp;<code>numeric</code>, default <code>122</code></dt>
<dd>Pixels per inch. Along with <code>plot_width</code> and <code>plot_height</code>,
determines the size of interactive plots.</dd>
<dt><strong><code>xlim</code></strong>, <strong><code>ylim</code></strong> :&ensp;<code>list</code> of <code>two numeric values</code>, optional</dt>
<dd>Minimum and maximum value of the x-axis and y-axis, respectively.</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure. Filetype of saved figure is
determined by <code>save_format</code>.
Note: interactive plots can be saved by clicking the 'Download plot'
button in the plot's toolbar.</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Desired format of saved or downloaded figure. Can be 'png', 'jpg',
'jpeg', 'webp', 'svg', 'pdf', 'eps', 'json', or 'html'. If 'html',
an interactive plot will be saved. Only 'png', 'svg', 'jpeg',
and 'webp' can be downloaded with the 'download as' button in the
toolbar of an interactive plot.</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>numeric</code>, default <code>1</code></dt>
<dd>Multiply title/legend/axis/canvas sizes by this factor when saving
the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object</code></dt>
<dd>A line plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_aqueous_species(self, plot_basis=False, plot_species=None,
                         x_type=&#34;logxi&#34;, y_type=&#34;log activity&#34;,
                         initially_visible=None, show_legend=True,
                         charge_sign_at_end=False,
                         plot_width=4, plot_height=3, ppi=122, xlim=None,
                         ylim=None, save_as=None, save_format=None,
                         save_scale=1):
    
    &#34;&#34;&#34;
    Generate a line plot of the log activities of aqueous species as a
    function of the log of the extent of reaction (log Xi) or some other
    variable.
    
    Parameters
    ----------
    plot_basis : bool, default False
        Plot basis species only?
    
    plot_species : list of str, optional
        A list of aqueous species to plot. If undefined, every species at
        will be plotted at once.
    
    x_type : str, default &#34;logxi&#34;
        Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
        &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
        &#34;aw&#34;.
    
    y_type : str, default &#39;log activity&#39;
        The variable to plot on the y-axis. Can be either &#39;log activity&#39;,
        &#39;molality&#39;, or &#39;log molality&#39;.
    
    initially_visible : list of str, optional
        A list of aqueous species that will be visible on the plot
        initially. All other species will be hidden, but can still be
        toggled back on in the legend.
    
    show_legend : bool, default True
        Show the legend?
    
    charge_sign_at_end : bool, default False
        Display charge with sign after the number (e.g. SO4 2-)?
    
    plot_width, plot_height : numeric, default 4 by 3
        Width and height of the plot, in inches. Size of interactive plots
        is also determined by pixels per inch, set by the parameter `ppi`.
        
    ppi : numeric, default 122
        Pixels per inch. Along with `plot_width` and `plot_height`,
        determines the size of interactive plots.
        
    xlim, ylim : list of two numeric values, optional
        Minimum and maximum value of the x-axis and y-axis, respectively.
        
    save_as : str, optional
        Provide a filename to save this figure. Filetype of saved figure is
        determined by `save_format`.
        Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
        button in the plot&#39;s toolbar.

    save_format : str, default &#34;png&#34;
        Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
        &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
        an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
        and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
        toolbar of an interactive plot.

    save_scale : numeric, default 1
        Multiply title/legend/axis/canvas sizes by this factor when saving
        the figure.
        
    Returns
    -------
    fig : Plotly figure object
        A line plot.
    &#34;&#34;&#34;
    
    if plot_basis:

        df = pd.concat([self.basis_logact, self.misc_params[self.misc_params.columns[1:]]], axis=1)
        title = &#34;Solute basis species&#34;
        ylab = &#34;log activity&#34;

    else:
        if y_type == &#34;log activity&#34;:
            df = pd.concat([self.aq_distribution_logact, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;log activity&#34;
        elif y_type == &#34;molality&#34;:
            df = pd.concat([self.aq_distribution_molal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;molality&#34;
        elif y_type == &#34;log molality&#34;:
            df = pd.concat([self.aq_distribution_logmolal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;log molality&#34;
        title = &#34;Solute species&#34;
        
    plot_columns = [col for col in df.columns]
    if isinstance(plot_species, list):
        plot_columns_temp = [col for col in plot_columns if col in plot_species]
        plot_columns = plot_columns_temp
        
    df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
    df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
    
    df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel, charge_sign_at_end=charge_sign_at_end)

    df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

    df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
    df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
    df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

    with np.errstate(divide=&#39;ignore&#39;):
        df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
    
    xlab, xvar = self.__get_xlab_xvar(x_type)
    
    fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                          width=plot_width*ppi,  height=plot_height*ppi,
                          labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                         )

    if isinstance(initially_visible, list):
        initially_visible_html = [chemlabel(sp, charge_sign_at_end=charge_sign_at_end) for sp in initially_visible]
        for trace in fig[&#39;data&#39;]: 
            if (not trace[&#39;name&#39;] in initially_visible_html):
                trace[&#39;showlegend&#39;] = True
                trace[&#39;visible&#39;] = &#39;legendonly&#39;
    
    fig.update_layout(xaxis_title=xlab,
                      yaxis_title=ylab,
                      legend_title=None,
                      showlegend=show_legend)

    if isinstance(title, str):
        fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

    if isinstance(ylim, list):
        fig.update_layout(yaxis_range=ylim)
        
    if isinstance(xlim, list):
        fig.update_layout(xaxis_range=xlim)
        
    if isinstance(save_as, str):
        dummy_sp = Speciation({})
        save_as, save_format = dummy_sp._save_figure(fig,
                save_as, save_format, save_scale,
                plot_width, plot_height, ppi)
        
    return fig</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_elements"><code class="name flex">
<span>def <span class="ident">plot_elements</span></span>(<span>self, plot_elements=None, units='molality', log=True, x_type='logxi', plot_width=4, plot_height=3, ppi=122, ylim=None, show_legend=True, charge_sign_at_end=False, save_as=None, save_format=None, save_scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a line plot of the log activities of aqueous species as a
function of the log of the extent of reaction (log Xi).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_elements</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>A list of elements to plot. If undefined, every element will be
plotted at once.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>str</code>, default <code>"molality"</code></dt>
<dd>Units of elemental abundance to plot. Can be "molality" or "ppm".</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display elemental abundances in log scale?</dd>
<dt><strong><code>plot_width</code></strong>, <strong><code>plot_height</code></strong> :&ensp;<code>numeric</code>, default <code>4 by 3</code></dt>
<dd>Width and height of the plot, in inches. Size of interactive plots
is also determined by pixels per inch, set by the parameter <code>ppi</code>.</dd>
<dt><strong><code>ppi</code></strong> :&ensp;<code>numeric</code>, default <code>122</code></dt>
<dd>Pixels per inch. Along with <code>plot_width</code> and <code>plot_height</code>,
determines the size of interactive plots.</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> of <code>two numeric values</code>, optional</dt>
<dd>Minimum and maximum value of the y-axis.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show the legend?</dd>
<dt><strong><code>charge_sign_at_end</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Display charge with sign after the number (e.g. SO4 2-)?</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure. Filetype of saved figure is
determined by <code>save_format</code>.
Note: interactive plots can be saved by clicking the 'Download plot'
button in the plot's toolbar.</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Desired format of saved or downloaded figure. Can be 'png', 'jpg',
'jpeg', 'webp', 'svg', 'pdf', 'eps', 'json', or 'html'. If 'html',
an interactive plot will be saved. Only 'png', 'svg', 'jpeg',
and 'webp' can be downloaded with the 'download as' button in the
toolbar of an interactive plot.</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>numeric</code>, default <code>1</code></dt>
<dd>Multiply title/legend/axis/canvas sizes by this factor when saving
the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object</code></dt>
<dd>A line plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def plot_elements(self, plot_elements=None, units=&#34;molality&#34;, log=True,
                      x_type=&#34;logxi&#34;, plot_width=4, plot_height=3, ppi=122,
                      ylim=None, show_legend=True, charge_sign_at_end=False,
                      save_as=None, save_format=None, save_scale=1):
        
        &#34;&#34;&#34;
        Generate a line plot of the log activities of aqueous species as a
        function of the log of the extent of reaction (log Xi).
        
        Parameters
        ----------
        plot_elements : list of str, optional
            A list of elements to plot. If undefined, every element will be
            plotted at once.
        
        units : str, default &#34;molality&#34;
            Units of elemental abundance to plot. Can be &#34;molality&#34; or &#34;ppm&#34;.
        
        log : bool, default True
            Display elemental abundances in log scale?
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        ylim : list of two numeric values, optional
            Minimum and maximum value of the y-axis.
            
        show_legend : bool, default True
            Show the legend?
            
        charge_sign_at_end : bool, default False
            Display charge with sign after the number (e.g. SO4 2-)?
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        Returns
        -------
        fig : Plotly figure object
            A line plot.
        &#34;&#34;&#34;
        
        title = &#34;Concentrations of dissolved elements&#34;
        if units == &#34;molality&#34;:
            df = pd.concat([self.dissolved_elements_molal, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;{}molality&#34;
        elif units == &#34;ppm&#34;:
            df = pd.concat([self.dissolved_elements_ppm, self.misc_params[self.misc_params.columns[1:]]], axis=1)
            ylab = &#34;{}ppm&#34;
#             elif units == &#34;molarity&#34;:

        plot_columns = [col for col in df.columns]
        if isinstance(plot_elements, list):
            plot_columns_temp = [col for col in plot_columns if col in plot_elements]
            plot_columns = plot_columns_temp
            
        df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
        df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
        df[&#34;variable&#34;] = df[&#34;variable&#34;].apply(chemlabel, charge_sign_at_end=charge_sign_at_end)

        df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

        df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
        df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)
        df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)

        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
            if log:
                df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])
                ylab = ylab.format(&#34;log &#34;)
        if not log:
            ylab = ylab.format(&#34;&#34;)
        
        xlab, xvar = self.__get_xlab_xvar(x_type)

        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                              width=plot_width*ppi,  height=plot_height*ppi,
                              labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                             )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None,
                          showlegend=show_legend,
                          yaxis={&#39;showexponent&#39;: &#39;all&#39;,
                                 &#39;exponentformat&#39;: &#39;power&#39;},
                         )

        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})
            
        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)

        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        return fig</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_energy"><code class="name flex">
<span>def <span class="ident">plot_energy</span></span>(<span>self, species, stoich, divisor=1, x_type='logxi', y_type='A', y_units='kcal', show_zero_line=False, limiting=None, xlab=None, ylab=None, title=None, charge_sign_at_end=False, log_y=False, plot_width=4, plot_height=3, ppi=122, xlim=None, ylim=None, df_out=False, save_as=None, save_format=None, save_scale=1, print_logK_messages=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a line plot of the energy profile for a reaction as a
function of the log of the extent of reaction (log Xi) or some other
variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>species</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of species that match the order of the stoichiometric
reaction coefficients in the <code>stoich</code> parameter.</dd>
<dt><strong><code>stoich</code></strong> :&ensp;<code>list</code> of <code>numeric</code></dt>
<dd>A list of stoichiometric reaction coefficients that match the order
of the species in the <code>species</code> parameter.</dd>
<dt><strong><code>divisor</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Divide all values in the energy profile by this number. Useful for
calculating energy per electron transferred or similar.</dd>
<dt><strong><code>x_type</code></strong> :&ensp;<code>str</code>, default <code>"logxi"</code></dt>
<dd>Variable to appear on the x-axis. Can be "logxi", "xi",
"temperature", "pressure", "pH", "pmH", "logfO2", "Eh", "pe", or
"aw".</dd>
<dt><strong><code>y_type</code></strong> :&ensp;<code>str</code>, default <code>'A'</code></dt>
<dd>The variable to plot on the y-axis. Can be either 'A' (for chemical
affinity), 'G' (for Gibbs free energy, G), 'logK' (for the log
of the equilibrium constant), 'logQ' (for the log of the reaction
quotient), or 'E' for energy supply.</dd>
<dt><strong><code>y_units</code></strong> :&ensp;<code>str</code>, default <code>'kcal'</code></dt>
<dd>The unit that energy will be reported in (per mol for G and A, or
per kg fluid for energy supply, or unitless for logK and logQ).
Can be 'kcal', 'cal', 'J', or 'kJ'.</dd>
<dt><strong><code>show_zero_line</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, displays a dotted line where affinity or G equals 0 (at
equilibrium).</dd>
<dt><strong><code>limiting</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the species to act as the limiting reactant when calculating
energy supply. If this parameter is left undefined, then a
limiting reactant will be chosen automatically based on
concentration and stoichiometry. This parameter is ignored unless
<code>y_type</code> is set to 'E' (energy supply).</dd>
<dt><strong><code>xlab</code></strong>, <strong><code>ylab</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Custom x and y axis labels.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Title of the plot to display.</dd>
<dt><strong><code>charge_sign_at_end</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Display charge with sign after the number (e.g. SO4 2- instead of
SO4-2) in species names when the reaction is displayed in the plot
title?</dd>
<dt><strong><code>plot_width</code></strong>, <strong><code>plot_height</code></strong> :&ensp;<code>numeric</code>, default <code>4 by 3</code></dt>
<dd>Width and height of the plot, in inches. Size of interactive plots
is also determined by pixels per inch, set by the parameter <code>ppi</code>.</dd>
<dt><strong><code>ppi</code></strong> :&ensp;<code>numeric</code>, default <code>122</code></dt>
<dd>Pixels per inch. Along with <code>plot_width</code> and <code>plot_height</code>,
determines the size of interactive plots.</dd>
<dt><strong><code>xlim</code></strong>, <strong><code>ylim</code></strong> :&ensp;<code>list</code> of <code>two numeric values</code>, optional</dt>
<dd>Minimum and maximum value of the x-axis and y-axis, respectively.</dd>
</dl>
<p>df_out = bool, default False
Return a pandas dataframe in addition to a figure?</p>
<dl>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure. Filetype of saved figure is
determined by <code>save_format</code>.
Note: interactive plots can be saved by clicking the 'Download plot'
button in the plot's toolbar.</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Desired format of saved or downloaded figure. Can be 'png', 'jpg',
'jpeg', 'webp', 'svg', 'pdf', 'eps', 'json', or 'html'. If 'html',
an interactive plot will be saved. Only 'png', 'svg', 'jpeg',
and 'webp' can be downloaded with the 'download as' button in the
toolbar of an interactive plot.</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>numeric</code>, default <code>1</code></dt>
<dd>Multiply title/legend/axis/canvas sizes by this factor when saving
the figure.</dd>
<dt><strong><code>print_logK_messages</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Print pyCHNOSZ messages while the logK of the reaction is
calculated?</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object, optionally a Pandas Dataframe</code></dt>
<dd>A line plot. If <code>df_out</code> is True, also returns a dataframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def plot_energy(self, species, stoich,
                    divisor=1, x_type=&#34;logxi&#34;, y_type=&#34;A&#34;, y_units=&#34;kcal&#34;, 
                    show_zero_line=False, limiting=None, xlab=None, ylab=None,
                    title=None, charge_sign_at_end=False, log_y=False,
                    plot_width=4, plot_height=3, ppi=122,
                    xlim=None, ylim=None, df_out=False,
                    save_as=None, save_format=None,
                    save_scale=1, print_logK_messages=False):
        
        &#34;&#34;&#34;
        Generate a line plot of the energy profile for a reaction as a
        function of the log of the extent of reaction (log Xi) or some other
        variable.
        
        Parameters
        ----------
        species : list of str
            A list of species that match the order of the stoichiometric
            reaction coefficients in the `stoich` parameter.

        stoich : list of numeric
            A list of stoichiometric reaction coefficients that match the order
            of the species in the `species` parameter.
        
        divisor : float, default 1
            Divide all values in the energy profile by this number. Useful for
            calculating energy per electron transferred or similar.
        
        x_type : str, default &#34;logxi&#34;
            Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
            &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
            &#34;aw&#34;.
        
        y_type : str, default &#39;A&#39;
            The variable to plot on the y-axis. Can be either &#39;A&#39; (for chemical
            affinity), &#39;G&#39; (for Gibbs free energy, G), &#39;logK&#39; (for the log
            of the equilibrium constant), &#39;logQ&#39; (for the log of the reaction
            quotient), or &#39;E&#39; for energy supply.
        
        y_units : str, default &#39;kcal&#39;
            The unit that energy will be reported in (per mol for G and A, or
            per kg fluid for energy supply, or unitless for logK and logQ).
            Can be &#39;kcal&#39;, &#39;cal&#39;, &#39;J&#39;, or &#39;kJ&#39;.
        
        show_zero_line : bool, default False
            If True, displays a dotted line where affinity or G equals 0 (at
            equilibrium).
        
        limiting : str, optional
            Name of the species to act as the limiting reactant when calculating
            energy supply. If this parameter is left undefined, then a
            limiting reactant will be chosen automatically based on
            concentration and stoichiometry. This parameter is ignored unless
            `y_type` is set to &#39;E&#39; (energy supply).
        
        xlab, ylab : str, optional
            Custom x and y axis labels.
        
        title : str, optional
            Title of the plot to display.
        
        charge_sign_at_end : bool, default False
            Display charge with sign after the number (e.g. SO4 2- instead of
            SO4-2) in species names when the reaction is displayed in the plot
            title?
        
        plot_width, plot_height : numeric, default 4 by 3
            Width and height of the plot, in inches. Size of interactive plots
            is also determined by pixels per inch, set by the parameter `ppi`.
            
        ppi : numeric, default 122
            Pixels per inch. Along with `plot_width` and `plot_height`,
            determines the size of interactive plots.
            
        xlim, ylim : list of two numeric values, optional
            Minimum and maximum value of the x-axis and y-axis, respectively.
            
        df_out = bool, default False
            Return a pandas dataframe in addition to a figure?
            
        save_as : str, optional
            Provide a filename to save this figure. Filetype of saved figure is
            determined by `save_format`.
            Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
            button in the plot&#39;s toolbar.

        save_format : str, default &#34;png&#34;
            Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
            &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
            an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
            and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
            toolbar of an interactive plot.

        save_scale : numeric, default 1
            Multiply title/legend/axis/canvas sizes by this factor when saving
            the figure.
            
        print_logK_messages : bool, default False
            Print pyCHNOSZ messages while the logK of the reaction is
            calculated?
            
        Returns
        -------
        fig : Plotly figure object, optionally a Pandas Dataframe
            A line plot. If `df_out` is True, also returns a dataframe.
        &#34;&#34;&#34;
        # check that a thermodynamic CSV is being used
        if not isinstance(self.thermo.csv_db, pd.DataFrame):
            self.err_handler.raise_exception(&#34;The plot_energy() function requires &#34;
                    &#34;a thermodynamic database in a WORM-style CSV format, e.g., &#34;
                    &#34;&#39;wrm_data.csv&#39;. You may be getting this message because &#34;
                    &#34;a data0 or data1 file was used.&#34;)
        
        # check that the divisor is valid
        if isinstance(divisor, list) or isinstance(divisor, pd.Series):
            if len(divisor) != len(self.misc_params[&#34;Temp(C)&#34;]):
                self.err_handler.raise_exception(&#34;The length of the divisor is &#34;
                    &#34;not equal to the number of reported xi steps.&#34;)

        # check that the reaction is balanced
        formulas = []
        for s in species:
            if s == &#34;H+&#34;:
                formulas.append(&#34;H+&#34;)
            elif s == &#34;H2O&#34;:
                formulas.append(&#34;H2O&#34;)
            else:
                if s in list(self.thermo.csv_db[&#34;name&#34;]):
                    formulas.append(list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;formula&#34;])[0])
                else:
                    self.err_handler.raise_exception(&#34;Valid thermodynamic data &#34;
                            &#34;was not found for species &#34;+str(s)+&#34;&#34;)
                    
        missing_composition = check_balance(formulas, stoich)
        
        
        # check that there are valid limiting reactants when calculating energy
        # e.g., prevent issue when the only reactant is a mineral, etc.
        reactant_idx = [1 if i&lt;0 else 0 for i in stoich]
        reactants = [species[i] for i,idx in enumerate(reactant_idx) if idx == 1]
        invalid_limiting_reactants = []
        for r in reactants:
            if r not in [&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;]:
                if list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==r][&#34;state&#34;])[0] != &#34;aq&#34;:
                    invalid_limiting_reactants.append(r)
            else:
                invalid_limiting_reactants.append(r)
        if reactants == invalid_limiting_reactants and y_type == &#34;E&#34;:
            self.err_handler.raise_exception(&#34;Energy supply for this reaction &#34;
                &#34;cannot be calculated because none of the reactants are &#34;
                &#34;limiting. A limiting reactant must be aqueous and cannot be H+ &#34;
                &#34;or OH-.&#34;)
        
        if limiting != None:
            # check that the limiting reactant is in the thermodynamic database
            if limiting not in list(self.thermo.csv_db[&#34;name&#34;]):
                self.err_handler.raise_exception(&#34;Valid thermodynamic data was &#34;
                        &#34;not found for limiting reactant &#34;+str(limiting)+&#34;&#34;)
            
            # check that the limiting reactant is aqueous or gaseous
            if list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==limiting][&#34;state&#34;])[0] != &#34;aq&#34;:
                self.err_handler.raise_exception(&#34;The limiting reactant must &#34;
                        &#34;be an aqueous species.&#34;)
            
            # check that the limiting reactant is a reactant in the `species` parameter
            if limiting not in reactants:
                self.err_handler.raise_exception(&#34;The species specified as a &#34;
                        &#34;limiting reactant, &#39;&#34;+str(limiting)+&#34;&#39;, is not a &#34;
                        &#34;reactant in this reaction.&#34;)
                
        # format reaction equation
        equation_to_display = format_equation(
                                      species,
                                      stoich,
                                      charge_sign_at_end=charge_sign_at_end,
                                      )
        
        # create a dictionary of species logacts across xi
        s_logact_dict = {}
        s_molal_dict = {}
        for s in species:
            if s == &#34;H+&#34;:
                s_logact_dict[s] = [-pH for pH in list(self.misc_params[&#34;pH&#34;])]
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;pH&#34;])
            elif s == &#34;H2O&#34;:
                s_logact_dict[s] = [0]*len(self.misc_params[&#34;Temp(C)&#34;])
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;Temp(C)&#34;])
            elif list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;state&#34;])[0] not in [&#34;cr&#34;, &#34;liq&#34;]:
                if s in self.aq_distribution_logact.columns:
                    # aqueous species
                    s_logact_dict[s] = list(self.aq_distribution_logact[s])
                    s_molal_dict[s] = list(self.aq_distribution_molal[s])
                else:
                    self.err_handler.raise_exception(&#34;The species &#34;+str(s)+&#34; is &#34;
                            &#34;not among the distribution of aqueous species in &#34;
                            &#34;this calculation.&#34;)
            else:
                # liq and cr species
                s_logact_dict[s] = [0]*len(self.misc_params[&#34;Temp(C)&#34;])
                s_molal_dict[s] = [float(&#34;NaN&#34;)]*len(self.misc_params[&#34;Temp(C)&#34;])
                
            
        xlab, xvar = self.__get_xlab_xvar(x_type)
            
        if y_type not in [&#34;logK&#34;, &#34;logQ&#34;]:
            if y_units in [&#34;cal&#34;, &#34;kcal&#34;]:
                r_div = 4.184
            elif y_units in [&#34;J&#34;, &#34;kJ&#34;]:
                r_div = 1
            R = 8.314/r_div  # gas constant, unit = [cal/mol/K]

        if &#34;k&#34; in y_units:
            k_div = 1000
        else:
            k_div = 1
            
        y_list = []
        lr_name_list = []
        for i,T in enumerate(list(self.misc_params[&#34;Temp(C)&#34;])):
            
            if isinstance(divisor, list):
                divisor_i = divisor[i]
            else:
                divisor_i = divisor
            
            if y_type != &#34;logQ&#34;:
                logK = pyCHNOSZ.subcrt(
                              species,
                              stoich,
                              T=T,
                              P=list(self.misc_params[&#34;Press(bars)&#34;])[i],
                              show=False,
                              messages=print_logK_messages).out[&#34;logK&#34;]

                logK = float(logK.iloc[0])

            if y_type == &#34;logK&#34;:
                ylab_out = &#34;log K&#34;
                if title == None:
                    title = &#34;Equilibrium constant for the reaction&lt;br&gt;&#34;+equation_to_display
                y_list.append(round(logK/divisor_i, 4))
                df_y_name = &#34;logK&#34;
                continue
                

            logQ = sum([st*s_logact_dict[sp][i] for st,sp in zip(stoich,species)])

            if y_type == &#34;logQ&#34;:
                ylab_out = &#34;log Q&#34;
                if title == None:
                    title = &#34;Reaction quotient for the reaction&lt;br&gt;&#34;+equation_to_display
                y_list.append(round(logQ/divisor_i, 4))
                df_y_name = &#34;logQ&#34;
                continue
            
            else:
                A = 2.303 * R * (273.15+T) * (logK - logQ)  # affinity, unit = [cal/mol]
                A = A/k_div
                
                if title == None:
                    title = &#34;Energy profile for the reaction&lt;br&gt;&#34;+equation_to_display
                
                if y_type==&#34;G&#34;:
                    G = -A # gibbs free energy, unit = [cal/mol]
                    y_list.append(G/divisor_i)
                    ylab_out=&#34;G, {}/mol&#34;.format(y_units)
                    y_units_out = y_units+&#34;/mol&#34;
                elif y_type==&#34;A&#34;:
                    y_list.append(round(A/divisor_i, 4))
                    ylab_out=&#34;A, {}/mol&#34;.format(y_units)
                    y_units_out = y_units+&#34;/mol&#34;
                elif y_type==&#34;E&#34;:
                    
                    if not isinstance(limiting, str):
                        lrc_dict = {}
                        for i_s,s in enumerate(species):
                            # identify valid limiting reactants and record concentrations
                            # 1. negative coefficient (reactant)
                            # 2. can&#39;t be OH-, H+, H2O
                            # 3. can&#39;t be cr or liq
                            if stoich[i_s] &lt; 0 and s not in [&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;] and list(self.thermo.csv_db[self.thermo.csv_db[&#34;name&#34;]==s][&#34;state&#34;])[0] not in [&#34;cr&#34;, &#34;liq&#34;]:
                                lrc_dict[s] = s_molal_dict[s][i]/abs(stoich[i_s])
                    
                    if not isinstance(limiting, str):
                        lr_name = min(lrc_dict, key=lrc_dict.get)
                        lr_val = lrc_dict[lr_name]
                        
                        # handle situations where there might be multiple limiting reactants
                        lr_list = []
                        for k,v in zip(lrc_dict.keys(), lrc_dict.values()):
                            if v == lr_val:
                                lr_list.append(str(k))
            
                    else:
                        lr_list = [limiting]
                        
                    lr_list_formatted = [chemlabel(lr_name, charge_sign_at_end=charge_sign_at_end) for lr_name in lr_list]
                    if len(lr_list_formatted) &gt; 1:
                        lr_reported = &#34;, &#34;.join(lr_list_formatted)
                    else:
                        lr_reported = lr_list[0]
                        
                    lr_name = lr_list[0] # doesn&#39;t matter which lr is used to calculate
                    lr_concentration = s_molal_dict[lr_name][i]
                    lr_name_list.append(lr_reported)
                    lr_stoich = -stoich[species.index(lr_name)]
                    E = A * (lr_concentration/lr_stoich)

                    y_list.append(round(E/divisor_i, 4))
                    y_units_out = y_units+&#34;/kg fluid&#34;
                    ylab_out=&#34;Energy Supply, {}&#34;.format(y_units+&#34;/kg fluid&#34;)
#                     else:
#                         lr_name_list.append(&#34;NA&#34;)
#                         y_list.append(float(&#39;NaN&#39;))
#                         y_units_out = y_units+&#34;/kg fluid&#34;
#                         ylab_out=&#34;Energy Supply, {}&#34;.format(y_units+&#34;/kg fluid&#34;)

                df_y_name = y_type+&#34;, &#34;+y_units_out

            
        if xlab != None:
            xlab_out = xlab
        if ylab != None:
            ylab_out = ylab

        df = copy.deepcopy(self.misc_params)
        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
            
        df[df_y_name] = y_list

        
        fig = px.line(df, x=xvar, y=df_y_name, log_y=log_y,
                      width=plot_width*ppi, height=plot_height*ppi,
                      template=&#34;simple_white&#34;)
        
        if y_type==&#34;E&#34;:
            fig.add_trace(
                go.Scatter(
                    x=df[xvar],
                    y=df[df_y_name],
                    mode=&#39;lines&#39;,
                    customdata = lr_name_list,
                    hovertemplate = xlab+&#39;: %{x}&lt;br&gt;&#39;+ylab_out+&#39;: %{y}&lt;br&gt;Limiting : %{customdata}&lt;extra&gt;&lt;/extra&gt;&#39;,
                )
            )
            fig.data[0].visible=False
        
        fig.update_layout(xaxis_title=xlab_out,
                          yaxis_title=ylab_out)
        
        if isinstance(title, str):
            fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        if isinstance(ylim, list):
            fig.update_layout(yaxis_range=ylim)
            
        if isinstance(xlim, list):
            fig.update_layout(xaxis_range=xlim)
            
        if isinstance(save_as, str):
            dummy_sp = Speciation({})
            save_as, save_format = dummy_sp._save_figure(fig,
                    save_as, save_format, save_scale,
                    plot_width, plot_height, ppi)
            
        if show_zero_line:
            fig.add_hline(y=0, line_width=3, line_dash=&#34;dash&#34;, line_color=&#34;black&#34;)
            
        if df_out:
            return fig, df
        else:
            return fig</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_mass_contribution"><code class="name flex">
<span>def <span class="ident">plot_mass_contribution</span></span>(<span>self, *args, x_type='xi', x_decimals=3, track_steps=True, keep_xi_order=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a bar plot of mass contributions (in mole percent) of aqueous
species formed as a function of reaction progress Xi or some other
variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Arguments to be passed to <code>Speciation.plot_mass_contribution</code>.</dd>
<dt><strong><code>x_type</code></strong> :&ensp;<code>str</code>, default <code>"xi"</code></dt>
<dd>Variable to appear on the x-axis. Can be "logxi", "xi",
"temperature", "pressure", "pH", "pmH", "logfO2", "Eh", "pe", or
"aw".</dd>
<dt><strong><code>x_decimals</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of decimals to display in the numeric values of the x-axis
variable defined by <code>x_type</code>.</dd>
<dt><strong><code>track_steps</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show reported xi steps on x-axis ticks? Useful for plotting as a
function of an x-axis variable that can be out-of-order, like
Eh or temperature. This parameter will become True automatically
if it will prevent column stacking (which happens if there are
duplicate x-axis values).</dd>
<dt><strong><code>**kargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments to be passed to <code>Speciation.plot_mass_contribution</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object</code></dt>
<dd>A mass contribution bar plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mass_contribution(self, *args, x_type=&#34;xi&#34;, x_decimals=3,
                                 track_steps=True, keep_xi_order=False,
                                 **kwargs):
    
    &#34;&#34;&#34;
    Generate a bar plot of mass contributions (in mole percent) of aqueous
    species formed as a function of reaction progress Xi or some other
    variable.
    
    Parameters
    ----------
    *args : iterable
        Arguments to be passed to `Speciation.plot_mass_contribution`.

    x_type : str, default &#34;xi&#34;
        Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
        &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
        &#34;aw&#34;.

    x_decimals : int
        Number of decimals to display in the numeric values of the x-axis
        variable defined by `x_type`.

    track_steps : bool, default True
        Show reported xi steps on x-axis ticks? Useful for plotting as a
        function of an x-axis variable that can be out-of-order, like
        Eh or temperature. This parameter will become True automatically
        if it will prevent column stacking (which happens if there are
        duplicate x-axis values).

    **kargs : dict
        Keyword arguments to be passed to `Speciation.plot_mass_contribution`.
        
    Returns
    -------
    fig : Plotly figure object
        A mass contribution bar plot.
    &#34;&#34;&#34;
    
    basis = args[0]
    
    xlab, kwargs[&#34;sample_label&#34;] = self.__get_xlab_xvar(x_type)
    
    df_sp = pd.concat([self.mass_contribution_dict.get(basis, &#34;error&#34;),
                       self.misc_params[self.misc_params.columns[1:]]], axis=1)
    
    with np.errstate(divide=&#39;ignore&#39;):
        df_sp[&#39;log Xi&#39;] = np.log10(df_sp[&#39;Xi&#39;])
    
    # handle display of the x axis variable
    # if number of decimals to display is too low, columns will stack
    # check to see if this happens, then increment x_decimals until the stacking problem is solved
    if x_decimals &lt; 0:
        msg = &#34;The parameter x_decimals must be greater than or equal to 0.&#34;
        self.err_handler.raise_exception(msg)
    original_x_decimals = copy.copy(x_decimals)
    
    len_unique_labels_rounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x)))
    len_unique_labels_unrounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]]))
    
    if len_unique_labels_rounded &lt; len_unique_labels_unrounded:
        x_decimals += 1
        solved_decimals = False
        for i in range(x_decimals, x_decimals+10):
            len_unique_labels_rounded = len(set(df_sp[kwargs[&#34;sample_label&#34;]].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x)))
            if len_unique_labels_rounded == len_unique_labels_unrounded:
                if self.verbose &gt; 0:
                    print(&#34;Number of decimals to display for x-axis variable&#34;,
                          &#34;increased to&#34;, x_decimals, &#34;to prevent column stacking.&#34;)
                solved_decimals = True
                break
            else:
                x_decimals += 1
        if not solved_decimals:
            msg = (&#34;X-axis value decimal formatting is resulting in column &#34;
                   &#34;stacking even after attempting 10 increments of x_decimals.&#34;)
            self.err_handler.raise_exception(msg)

    if isinstance(df_sp, str):
        msg = (&#34;The basis species {} &#34;.format(basis)+&#34;could not be found &#34;
               &#34;among available basis species: &#34;
               &#34;{}&#34;.format(str(list(self.mass_contribution_dict.keys()))))
        self.err_handler.raise_exception(msg)
    
    df_sp[&#34;position&#34;] = list(range(0, df_sp.shape[0]))
    
    df_sp_melt = df_sp.melt(
            id_vars=list(self.misc_params.columns)+[&#34;log Xi&#34;, &#34;basis&#34;, &#34;factor&#34;, &#34;molality&#34;, &#34;position&#34;])
    
    df_sp_melt.rename(columns={kwargs[&#34;sample_label&#34;] : &#34;sample&#34;,
                               df_sp_melt.columns[-2] : &#34;species&#34;,
                               df_sp_melt.columns[-1] : &#34;percent&#34;,
                               }, inplace=True)
                                  
    df_sp_melt = df_sp_melt[df_sp_melt[&#39;percent&#39;].notna()]
    
    if keep_xi_order:
        sample_order = [&#34;position&#34;, &#34;species&#34;, &#34;percent&#34;]
    else:
        sample_order = [&#34;sample&#34;, &#34;position&#34;, &#34;species&#34;, &#34;percent&#34;]
        
    df_sp_melt.sort_values(sample_order, axis=0, ascending=True, inplace=True)

    if df_sp_melt.dtypes[&#34;sample&#34;] != &#34;O&#34;: # if the column isn&#39;t formatted as a string
        if any([&#34;e&#34; in v2 for v2 in [str(v1) for v1 in df_sp_melt[&#39;sample&#39;]]]): # if value is in scientific notation
            df_sp_melt[&#39;sample&#39;] = df_sp_melt[&#39;sample&#39;].apply(lambda x: (&#39;%.&#39;+str(x_decimals)+&#39;e&#39;) % x) # converts numeric to string
        else:
            df_sp_melt[&#39;sample&#39;] = [(&#39;{0:.&#39;+str(x_decimals)+&#39;f}&#39;).format(v) for v in df_sp_melt[&#39;sample&#39;]]
        
        
    if len(list(set(df_sp_melt[&#34;sample&#34;]))) != len(list(set(df_sp_melt[&#34;position&#34;]))) or track_steps:
        # handle duplicate x-axis values to prevent stacking
        temp_col = []
        for i,v in enumerate(df_sp_melt[&#34;sample&#34;]):
            temp_col.append(&#34; (step &#34;+str(list(df_sp_melt[&#34;position&#34;])[i])+&#34;)&#34;)
        df_sp_melt[&#34;sample&#34;] = [str(v)+a for v,a in zip(df_sp_melt[&#34;sample&#34;], temp_col)]
        if not track_steps and self.verbose &gt; 0:
            print(&#34;Reported Xi step tracking has been added to x-axis ticks to prevent column stacking.&#34;)
        
    sp = Speciation(args={})
    sp.mass_contribution = df_sp_melt

    if not kwargs.get(&#34;plot_out&#34;, False):
        plot_out = False
    else:
        plot_out = True
    kwargs[&#34;plot_out&#34;] = True
    
    fig = sp.plot_mass_contribution(*args, **kwargs)
    
    fig.update_layout(
        xaxis_title=xlab, # add an x axis title
    )
    
    if plot_out:
        return fig
    else:
        fig.show()</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_pH"><code class="name flex">
<span>def <span class="ident">plot_pH</span></span>(<span>self, x_type='logxi', show_neutrality=True, title=None, plot_width=4, plot_height=3, ppi=122, ylim=None, save_as=None, save_format=None, save_scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a line plot of pH as a function of the log of the extent of
reaction (log Xi) or some other variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_type</code></strong> :&ensp;<code>str</code>, default <code>"logxi"</code></dt>
<dd>Variable to appear on the x-axis. Can be "logxi", "xi",
"temperature", "pressure", "pH", "pmH", "logfO2", "Eh", "pe", or
"aw".</dd>
<dt><strong><code>show_neutrality</code></strong> :&ensp;<code>bool</code>, default <code>True,</code></dt>
<dd>Display a reference line representing neutral pH? Setting this
option to True requires a thermodynamic database in a WORM-style CSV
format, e.g., 'wrm_data.csv'.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>Title of the plot to display.</dd>
<dt><strong><code>plot_width</code></strong>, <strong><code>plot_height</code></strong> :&ensp;<code>numeric</code>, default <code>4 by 3</code></dt>
<dd>Width and height of the plot, in inches. Size of interactive plots
is also determined by pixels per inch, set by the parameter <code>ppi</code>.</dd>
<dt><strong><code>ppi</code></strong> :&ensp;<code>numeric</code>, default <code>122</code></dt>
<dd>Pixels per inch. Along with <code>plot_width</code> and <code>plot_height</code>,
determines the size of interactive plots.</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> of <code>two numeric values</code>, optional</dt>
<dd>Minimum and maximum value of the y-axis.</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure. Filetype of saved figure is
determined by <code>save_format</code>.
Note: interactive plots can be saved by clicking the 'Download plot'
button in the plot's toolbar.</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Desired format of saved or downloaded figure. Can be 'png', 'jpg',
'jpeg', 'webp', 'svg', 'pdf', 'eps', 'json', or 'html'. If 'html',
an interactive plot will be saved. Only 'png', 'svg', 'jpeg',
and 'webp' can be downloaded with the 'download as' button in the
toolbar of an interactive plot.</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>numeric</code>, default <code>1</code></dt>
<dd>Multiply title/legend/axis/canvas sizes by this factor when saving
the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object</code></dt>
<dd>A line plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pH(self, x_type=&#34;logxi&#34;, show_neutrality=True, title=None,
            plot_width=4, plot_height=3, ppi=122, ylim=None, save_as=None,
            save_format=None, save_scale=1):
    
    &#34;&#34;&#34;
    Generate a line plot of pH as a function of the log of the extent of
    reaction (log Xi) or some other variable.
    
    Parameters
    ----------
    x_type : str, default &#34;logxi&#34;
        Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
        &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
        &#34;aw&#34;.
    
    show_neutrality : bool, default True,
        Display a reference line representing neutral pH? Setting this
        option to True requires a thermodynamic database in a WORM-style CSV
        format, e.g., &#39;wrm_data.csv&#39;.
    
    title : str
        Title of the plot to display.
    
    plot_width, plot_height : numeric, default 4 by 3
        Width and height of the plot, in inches. Size of interactive plots
        is also determined by pixels per inch, set by the parameter `ppi`.
        
    ppi : numeric, default 122
        Pixels per inch. Along with `plot_width` and `plot_height`,
        determines the size of interactive plots.
        
    ylim : list of two numeric values, optional
        Minimum and maximum value of the y-axis.
        
    save_as : str, optional
        Provide a filename to save this figure. Filetype of saved figure is
        determined by `save_format`.
        Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
        button in the plot&#39;s toolbar.

    save_format : str, default &#34;png&#34;
        Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
        &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
        an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
        and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
        toolbar of an interactive plot.

    save_scale : numeric, default 1
        Multiply title/legend/axis/canvas sizes by this factor when saving
        the figure.
        
    Returns
    -------
    fig : Plotly figure object
        A line plot.
    &#34;&#34;&#34;

    df = copy.deepcopy(self.misc_params)
    
    xlab, xvar = self.__get_xlab_xvar(x_type)
    
    if x_type == &#34;logxi&#34;:
        with np.errstate(divide=&#39;ignore&#39;):
            df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])

    fig = px.line(df, x=xvar, y=&#34;pH&#34;, template=&#34;simple_white&#34;,
                  width=plot_width*ppi,  height=plot_height*ppi,
                  labels=dict(value=&#34;pH&#34;, x=xlab), render_mode=&#39;svg&#39;,
                  )

    fig.update_layout(xaxis_title=xlab,
                      yaxis_title=&#34;pH&#34;,
                      showlegend=False)
    
    if isinstance(title, str):
        fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

    if isinstance(ylim, list):
        fig.update_layout(yaxis_range=ylim)
    
    if show_neutrality and isinstance(self.thermo.csv_db, pd.DataFrame):
        _, df_pH = self.plot_energy(species=[&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;],
                                    stoich=[-1, 1, 1],
                                    divisor=-2,
                                    x_type=x_type,
                                    y_type=&#34;logK&#34;,
                                    df_out=True,
                                    )
        
        fig.add_trace(go.Scatter(x=df_pH[xvar],
                                 y=df_pH[&#34;logK&#34;],
                                 mode=&#39;lines&#39;,
                                 name=&#39;neutral pH&#39;,
                                 showlegend=True,
                                 hovertemplate = xlab+&#39;: %{x}&lt;br&gt;pH: %{y}&lt;extra&gt;&lt;/extra&gt;&#39;,
                                 line=dict(color=&#39;silver&#39;,
                                           width=3,
                                           dash=&#39;dot&#39;)
                                ))

        fig[&#39;data&#39;][0][&#39;showlegend&#39;]=True
        fig[&#39;data&#39;][0][&#39;name&#39;]=&#39;pH&#39;
        fig[&#39;data&#39;][1][&#39;showlegend&#39;]=True
        fig[&#39;data&#39;][1][&#39;name&#39;]=&#39;neutral pH&#39;
        fig.update_layout(showlegend=True)

        
    if isinstance(save_as, str):
        dummy_sp = Speciation({})
        save_as, save_format = dummy_sp._save_figure(fig,
                save_as, save_format, save_scale,
                plot_width, plot_height, ppi)
        
    return fig</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_product_minerals"><code class="name flex">
<span>def <span class="ident">plot_product_minerals</span></span>(<span>self, show_reactant_minerals=False, plot_minerals=None, x_type='logxi', y_type='mole', log_y=True, df_out=False, markers=False, plot_width=4, plot_height=3, ppi=122, ylim=None, show_legend=True, save_as=None, save_format=None, save_scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a line plot of the log moles of product minerals as a
function of the log of the extent of reaction (log Xi) or some other
variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>show_reactant_minerals</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Include log moles of reactant minerals?</dd>
<dt><strong><code>plot_minerals</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of minerals to plot. Useful for isolating one or more
minerals.</dd>
<dt><strong><code>x_type</code></strong> :&ensp;<code>str</code>, default <code>"logxi"</code></dt>
<dd>Variable to appear on the x-axis. Can be "logxi", "xi",
"temperature", "pressure", "pH", "pmH", "logfO2", "Eh", "pe", or
"aw".</dd>
<dt><strong><code>y_type</code></strong> :&ensp;<code>str</code>, default <code>'mole'</code></dt>
<dd>The variable to plot on the y-axis. Can be either 'mole' (for moles
of minerals), 'mass' (for masses of minerals), or 'volume' (for
volumes of minerals).</dd>
<dt><strong><code>log_y</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Should the y-axis be logarithmic?</dd>
<dt><strong><code>df_out</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Should a dataframe of values also be returned? For example, if
<code>y_type</code> is set to 'volume', should a table of mineral volumes be
returned?</dd>
<dt><strong><code>markers</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Add circular markers to lines to indicate calculation steps?</dd>
<dt><strong><code>plot_width</code></strong>, <strong><code>plot_height</code></strong> :&ensp;<code>numeric</code>, default <code>4 by 3</code></dt>
<dd>Width and height of the plot, in inches. Size of interactive plots
is also determined by pixels per inch, set by the parameter <code>ppi</code>.</dd>
<dt><strong><code>ppi</code></strong> :&ensp;<code>numeric</code>, default <code>122</code></dt>
<dd>Pixels per inch. Along with <code>plot_width</code> and <code>plot_height</code>,
determines the size of interactive plots.</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> of <code>two numeric values</code>, optional</dt>
<dd>Minimum and maximum value of the y-axis.</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show the legend?</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure. Filetype of saved figure is
determined by <code>save_format</code>.
Note: interactive plots can be saved by clicking the 'Download plot'
button in the plot's toolbar.</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Desired format of saved or downloaded figure. Can be 'png', 'jpg',
'jpeg', 'webp', 'svg', 'pdf', 'eps', 'json', or 'html'. If 'html',
an interactive plot will be saved. Only 'png', 'svg', 'jpeg',
and 'webp' can be downloaded with the 'download as' button in the
toolbar of an interactive plot.</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>numeric</code>, default <code>1</code></dt>
<dd>Multiply title/legend/axis/canvas sizes by this factor when saving
the figure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Plotly figure object</code></dt>
<dd>A line plot.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>a Pandas dataframe</code></dt>
<dd>A dataframe is only returned if <code>df_out</code> is set to True (it is
set to False by default).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_product_minerals(self, show_reactant_minerals=False,
                          plot_minerals=None, x_type=&#34;logxi&#34;, y_type=&#34;mole&#34;,
                          log_y=True, df_out=False, markers=False,
                          plot_width=4, plot_height=3, ppi=122, ylim=None,
                          show_legend=True, save_as=None, save_format=None,
                          save_scale=1):
    
    &#34;&#34;&#34;
    Generate a line plot of the log moles of product minerals as a
    function of the log of the extent of reaction (log Xi) or some other
    variable.
    
    Parameters
    ----------
    show_reactant_minerals : bool, default False
        Include log moles of reactant minerals?
        
    plot_minerals : list, optional
        List of minerals to plot. Useful for isolating one or more
        minerals.
        
    x_type : str, default &#34;logxi&#34;
        Variable to appear on the x-axis. Can be &#34;logxi&#34;, &#34;xi&#34;,
        &#34;temperature&#34;, &#34;pressure&#34;, &#34;pH&#34;, &#34;pmH&#34;, &#34;logfO2&#34;, &#34;Eh&#34;, &#34;pe&#34;, or
        &#34;aw&#34;.
        
    y_type : str, default &#39;mole&#39;
        The variable to plot on the y-axis. Can be either &#39;mole&#39; (for moles
        of minerals), &#39;mass&#39; (for masses of minerals), or &#39;volume&#39; (for
        volumes of minerals).
    
    log_y : bool, default True
        Should the y-axis be logarithmic?
        
    df_out : bool, default False
        Should a dataframe of values also be returned? For example, if
        `y_type` is set to &#39;volume&#39;, should a table of mineral volumes be
        returned?
        
    markers : bool, default True
        Add circular markers to lines to indicate calculation steps?
        
    plot_width, plot_height : numeric, default 4 by 3
        Width and height of the plot, in inches. Size of interactive plots
        is also determined by pixels per inch, set by the parameter `ppi`.
        
    ppi : numeric, default 122
        Pixels per inch. Along with `plot_width` and `plot_height`,
        determines the size of interactive plots.
        
    ylim : list of two numeric values, optional
        Minimum and maximum value of the y-axis.
        
    show_legend : bool, default True
        Show the legend?
        
    save_as : str, optional
        Provide a filename to save this figure. Filetype of saved figure is
        determined by `save_format`.
        Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
        button in the plot&#39;s toolbar.

    save_format : str, default &#34;png&#34;
        Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
        &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
        an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
        and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
        toolbar of an interactive plot.

    save_scale : numeric, default 1
        Multiply title/legend/axis/canvas sizes by this factor when saving
        the figure.
        
    Returns
    -------
    fig : Plotly figure object
        A line plot.
        
    df : a Pandas dataframe
        A dataframe is only returned if `df_out` is set to True (it is
        set to False by default).
    
    &#34;&#34;&#34;
    
    xlab, xvar = self.__get_xlab_xvar(x_type)
    
    if show_reactant_minerals:
        df = pd.concat([self.moles_minerals, self.misc_params[self.misc_params.columns[1:]]], axis=1)
        title = &#34;{} of reactant and product minerals&#34;
    else:
        df = pd.concat([self.moles_product_minerals, self.misc_params[self.misc_params.columns[1:]]], axis=1)
        title = &#34;{} of product minerals&#34;
        
    if log_y:
        log_text = &#34;log &#34;
    else:
        log_text = &#34;&#34;

    # sort in order of appearance along Xi
    sort_order = list(self.moles_minerals.columns)
    
    sort_order = [v for v in sort_order if v not in self.misc_params.columns]
        
    if y_type == &#34;mole&#34;:
        ylab = &#34;{}moles&#34;.format(log_text)
        title = title.format(log_text, &#34;Moles&#34;)
    elif y_type == &#34;mass&#34;: # not yet supported
        y_lab = &#34;{}grams&#34;.format(log_text)
        title = title.format(log_text, &#34;Masses&#34;)
        self.err_handler.raise_exception(&#34;Plotting mineral masses is not yet &#34;
                &#34;supported.&#34;)
    elif y_type == &#34;volume&#34;:
        ylab = &#34;{}cm&lt;sup&gt;3&lt;/sup&gt;&#34;.format(log_text)
        title = title.format(&#34;Volumes&#34;)
        temps = df[&#34;Temp(C)&#34;]
        
        minerals = [col for col in df.columns if col not in list(self.misc_params.columns)]

        for i,T in enumerate(temps):
            for ii,mineral in enumerate(minerals):
                mineral_df = copy.deepcopy(self.df[self.df[&#34;name&#34;]==mineral])
                polymorph_idxs = []
                for iii in range(0, mineral_df.shape[0]): # loop through mineral polymorphs

                    if float(T) &lt; float(list(mineral_df[&#34;z.T&#34;])[0]):
                        polymorph_idxs.append(iii)
                if len(polymorph_idxs)==0:
                    polymorph_idx = iii
                else:
                    polymorph_idx = polymorph_idxs[0]


                partial_molal_volume = list(mineral_df[&#34;V&#34;])[polymorph_idx]

                df.at[i, mineral] = df[mineral][i]*partial_molal_volume
    else:
        self.err_handler.raise_exception(&#34;y_type must be either &#39;mole&#39;, &#34;
                    &#34;&#39;mass&#39;, or &#39;volume&#39;.&#34;)
        
    
    plot_columns = [col for col in df.columns if col not in list(self.misc_params.columns)]

    if isinstance(plot_minerals, list):
        plot_columns_temp = [col for col in plot_columns if col in plot_minerals]
        plot_columns = plot_columns_temp
        
    plot_columns = sorted(plot_columns, key=sort_order.index)
    
    df = pd.melt(df, id_vars=list(self.misc_params.columns), value_vars=plot_columns)
    df.columns = list(self.misc_params.columns)+[&#34;variable&#34;, &#34;value&#34;]
    
    df = df[df[&#34;variable&#34;] != &#34;None&#34;]

    df[&#34;Xi&#34;] = pd.to_numeric(df[&#34;Xi&#34;])

    df[&#34;value&#34;] = pd.to_numeric(df[&#34;value&#34;])
    df[&#34;value&#34;] = df[&#34;value&#34;].fillna(0)

    with np.errstate(divide=&#39;ignore&#39;):
        df[&#39;log Xi&#39;] = np.log10(df[&#39;Xi&#39;])
        if log_y:
            df[&#34;value&#34;] = df[&#34;value&#34;].replace(0, np.nan)
            df[&#39;value&#39;] = np.log10(df[&#39;value&#39;])

    fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                  width=plot_width*ppi,  height=plot_height*ppi, markers=markers,
                  labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                  )
    
    df_to_return = copy.deepcopy(df)
    
    # add lines that go to -9999 (representing -Inf) in log y plots
    if log_y:
        if not isinstance(ylim, list):
            # grab the automatic y-axis range from the plot, above
            full_fig = fig.full_figure_for_development(warn=False)
            ylim = list(full_fig.layout.yaxis.range)
            
        # add new rows
        for irow in range(0, df.shape[0]):
            if not isnan(df[&#34;value&#34;].iloc[irow]) and irow != 0 and irow != df.shape[0]-1:
                if isnan(df[&#34;value&#34;].iloc[irow-1]):
                    
                    df_dict = {}
                    for col in list(self.misc_params.columns)+[&#34;log Xi&#34;]:
                        df_dict[col] = df.loc[irow-1, col]
                    df_dict[&#34;variable&#34;] = df.loc[irow-1, &#34;variable&#34;]
                    df_dict[&#34;value&#34;] = df.loc[irow-1, &#34;value&#34;]
                        
                    new_row = pd.DataFrame(df_dict, index=[irow-1])
                    df = pd.concat([df.iloc[:irow], new_row, df.iloc[irow:]]).reset_index(drop=True)
                    irow=0
                    
                if isnan(df[&#34;value&#34;].iloc[irow+1]):
                    
                    df_dict = {}
                    for col in list(self.misc_params.columns)+[&#34;log Xi&#34;]:
                        df_dict[col] = df.loc[irow+1, col]
                    df_dict[&#34;variable&#34;] = df.loc[irow+1, &#34;variable&#34;]
                    df_dict[&#34;value&#34;] = df.loc[irow+1, &#34;value&#34;]
                    
                    new_row = pd.DataFrame(df_dict, index=[irow+1])
                    df = pd.concat([df.iloc[:irow], new_row, df.iloc[irow:]]).reset_index(drop=True)
                    irow=0
        
        # fill new rows with -9999 value
        for irow in range(0, df.shape[0]):
            if not isnan(df[&#34;value&#34;].iloc[irow]) and irow != 0 and irow != df.shape[0]-1:
                if isnan(df[&#34;value&#34;].iloc[irow-1]):
                    df.loc[irow-1, &#34;value&#34;] = -9999
                if isnan(df[&#34;value&#34;].iloc[irow+1]):
                    df.loc[irow+1, &#34;value&#34;] = -9999
                    
        # re-create the plot with log values down to -9999. This will screw up the
        # automatic y-axis range, but we grabbed it from the first generated plot.
        # We will reset the range in update_layout(yaxis_range) a little later.
        fig = px.line(df, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                      width=plot_width*ppi,  height=plot_height*ppi, markers=markers,
                      labels=dict(value=ylab, x=xlab), render_mode=&#39;svg&#39;,
                      )

    fig.update_layout(xaxis_title=xlab,
                      yaxis_title=ylab,
                      legend_title=None,
                      showlegend=show_legend)
    
    if isinstance(title, str):
        fig.update_layout(title={&#39;text&#39;:title, &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})
    
    if isinstance(ylim, list):
        fig.update_layout(yaxis_range=ylim)
    
    if isinstance(save_as, str):
        dummy_sp = Speciation({})
        save_as, save_format = dummy_sp._save_figure(fig,
                save_as, save_format, save_scale,
                plot_width, plot_height, ppi)
    
    if df_out:
        df_to_return = pd.pivot_table(df_to_return, index=&#39;log Xi&#39;, columns=&#39;variable&#39;, values=&#39;value&#39;).reset_index()
        df_to_return.columns = [col for col in df_to_return.columns[:]] # make index column name blank
        return df_to_return, fig
    else:
        return fig</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.plot_reaction_paths"><code class="name flex">
<span>def <span class="ident">plot_reaction_paths</span></span>(<span>self, xyb=None, path_margin=0.25, flip_xy=False, show_annotation=True, annotation_coords=[0, 0], show_nonparticipating_mineral_lines=False, minerals_to_show=[], calculate_projected_points=True, path_line_type='markers+lines', path_line_color='red', path_point_fill_color='red', path_point_line_color='red', projected_point_fill_color='white', projected_point_line_color='red', h_line_color='black', v_line_color='black', d_line_color='black', res=300, plot_width=4, plot_height=3, ppi=122, borders=0, save_as=None, save_format=None, save_scale=1, colormap='bw')</span>
</code></dt>
<dd>
<div class="desc"><p>Create interactive plots of reaction paths in geochemical variable
space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xyb</code></strong> :&ensp;<code>list</code> of <code>three str</code>, default <code>None</code></dt>
<dd>
<p>By default, this function will plot reaction paths in all possible
dimensions.</p>
<p>Optionally, if you want to produce only a specific plot,
you can provide a list containing the basis species to be used for
the x-axis and y-axis, followed by the basis species used for
balance. For example, ["Fe+2", "Fe+3", "Mg+2"] will have the log
activity of Fe+2 on the x-axis, the log activity of Fe+3 on the
y-axis, and will be balanced on Mg+2.</p>
</dd>
<dt><strong><code>path_margin</code></strong> :&ensp;<code>float</code>, default <code>0.25</code></dt>
<dd>Controls the spacing between the reaction path and the plot axes.
Increasing this value increases the spacing.</dd>
<dt><strong><code>flip_xy</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Transpose the plot so the x and y variables switch axes?</dd>
<dt><strong><code>show_annotation</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show annotation in the bottom left of the figure? The annotation
includes the species used for balance, the temperature, and
the pressure.</dd>
<dt><strong><code>annotation_coords</code></strong> :&ensp;<code>list</code>, default <code>[0,0]</code></dt>
<dd>List of two numeric values representing the X and Y coordinates of
the annotation, where 0,0 is the bottom left, 0.5,0 is the bottom
center, 1,0 is the bottom right, 1,1 is the top right, and so on.
The annotation includes the species used for balance, the
temperature and the pressure.</dd>
<dt><strong><code>show_nonparticipating_mineral_lines</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Depict lines for minerals even if those minerals do not participate
in the reaction? This does not affect the mineral field of the
diagram, only the mineral planes denoted as lines.</dd>
<dt><strong><code>path_line_type</code></strong> :&ensp;<code>str</code>, default <code>"markers+lines"</code></dt>
<dd>Reaction path line type. Can be either "markers+lines", "lines", or
"markers".</dd>
</dl>
<p>path_line_color, str, default "black"
Color of reaction path line.</p>
<dl>
<dt><strong><code>path_point_fill_color</code></strong> :&ensp;<code>str</code>, default <code>"black"</code></dt>
<dd>Fill color of non-projected points along the reaction path. The
fill color of projected points is handled by
<code>projected_point_fill_color</code>.</dd>
<dt><strong><code>path_point_line_color</code></strong> :&ensp;<code>str</code>, default <code>"black"</code></dt>
<dd>Color of the outlines of non-projected points along the reaction
path. The outline color of projected points is handled by
<code>projected_point_line_color</code>.</dd>
<dt><strong><code>projected_point_fill_color</code></strong> :&ensp;<code>str</code>, default <code>"white"</code></dt>
<dd>Fill color of projected points along the reaction path. The
fill color of non-projected points is handled by
<code>path_point_fill_color</code>.</dd>
<dt><strong><code>projected_point_line_color</code></strong> :&ensp;<code>str</code>, default <code>"black"</code></dt>
<dd>Color of the outlines of projected points along the reaction path.
The outline color of non-projected points is handled by
<code>path_point_line_color</code>.</dd>
<dt><strong><code>h_line_color</code></strong> :&ensp;<code>str</code>, default <code>"black"</code></dt>
<dd>Color of horizontal lines representing minerals.</dd>
<dt><strong><code>v_line_color</code></strong> :&ensp;<code>str</code>, default <code>"black"</code></dt>
<dd>Color of vertical lines representing minerals.</dd>
<dt><strong><code>d_line_color</code></strong> :&ensp;<code>str</code>, default <code>"black"</code></dt>
<dd>Color of diagonal lines representing minerals.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>int</code>, default <code>300</code></dt>
<dd>Resolution, or number of calculations along each axis, for mineral
stability fields. A lower number will be faster but will make appear
boundaries blockier. A higher number takes longer to calculate, but
will result in smoother boundaries.</dd>
<dt><strong><code>plot_width</code></strong>, <strong><code>plot_height</code></strong> :&ensp;<code>numeric</code>, default <code>4 by 3</code></dt>
<dd>Width and height of the plot, in inches.</dd>
<dt><strong><code>ppi</code></strong> :&ensp;<code>numeric</code>, default <code>122</code></dt>
<dd>Pixels per inch. Along with <code>plot_width</code> and <code>plot_height</code>,
determines the size of interactive plots.</dd>
<dt><strong><code>borders</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Thickness of black lines forming boundaries between mineral
stability regions. No lines appear if equal to 0.</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure. Filetype of saved figure is
determined by <code>save_format</code>.
Note: interactive plots can be saved by clicking the 'Download plot'
button in the plot's toolbar.</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Desired format of saved or downloaded figure. Can be 'png', 'jpg',
'jpeg', 'webp', 'svg', 'pdf', 'eps', 'json', or 'html'. If 'html',
an interactive plot will be saved. Only 'png', 'svg', 'jpeg',
and 'webp' can be downloaded with the 'download as' button in the
toolbar of an interactive plot.</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>numeric</code>, default <code>1</code></dt>
<dd>Multiply title/legend/axis/canvas sizes by this factor when saving
the figure.</dd>
<dt><strong><code>colormap</code></strong> :&ensp;<code>str</code>, default <code>"bw"</code></dt>
<dd>Name of the colormap to color the scatterpoints. Accepts "bw"
or names of matplotlib colormaps. If set to "bw", the plot will be
set to black and white, except for the reaction path line itself.
The colors of the reaction path line and its points are controlled
by <code>path_line_color</code>, <code>path_point_fill_color</code>,
<code>path_point_line_color</code>, <code>projected_point_fill_color</code>,
and <code>projected_point_line_color</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig_list</code></strong> :&ensp;<code>a list</code> of <code>Plotly figure objects</code></dt>
<dd>A list of interactive Plotly figures. If xyb equals None
(the default), then the list will contain figures representing all
combinations of geochemical variables. Optionally, if xyb is
specified, fig_list will only contain the single figure of interest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_reaction_paths(self,
                        xyb=None,
                        path_margin=0.25,
                        flip_xy=False,
                        show_annotation=True,
                        annotation_coords=[0,0],
                        show_nonparticipating_mineral_lines=False,
                        minerals_to_show=[],
                        calculate_projected_points=True,
                        path_line_type = &#34;markers+lines&#34;,
                        path_line_color = &#34;red&#34;,
                        path_point_fill_color = &#34;red&#34;,
                        path_point_line_color = &#34;red&#34;,
                        projected_point_fill_color = &#34;white&#34;,
                        projected_point_line_color = &#34;red&#34;,
                        h_line_color=&#34;black&#34;,
                        v_line_color=&#34;black&#34;,
                        d_line_color=&#34;black&#34;,
                        res=300,
                        plot_width=4,
                        plot_height=3,
                        ppi=122,
                        borders=0,
                        save_as=None,
                        save_format=None,
                        save_scale=1,
                        colormap=&#34;bw&#34;):
    
    &#34;&#34;&#34;
    Create interactive plots of reaction paths in geochemical variable
    space.
    
    Parameters
    ----------
    xyb : list of three str, default None
        By default, this function will plot reaction paths in all possible
        dimensions.
        
        Optionally, if you want to produce only a specific plot,
        you can provide a list containing the basis species to be used for
        the x-axis and y-axis, followed by the basis species used for
        balance. For example, [&#34;Fe+2&#34;, &#34;Fe+3&#34;, &#34;Mg+2&#34;] will have the log
        activity of Fe+2 on the x-axis, the log activity of Fe+3 on the
        y-axis, and will be balanced on Mg+2.

    path_margin : float, default 0.25
        Controls the spacing between the reaction path and the plot axes.
        Increasing this value increases the spacing.
    
    flip_xy : bool, default False
        Transpose the plot so the x and y variables switch axes?

    show_annotation : bool, default True
        Show annotation in the bottom left of the figure? The annotation
        includes the species used for balance, the temperature, and
        the pressure.

    annotation_coords : list, default [0,0]
        List of two numeric values representing the X and Y coordinates of
        the annotation, where 0,0 is the bottom left, 0.5,0 is the bottom
        center, 1,0 is the bottom right, 1,1 is the top right, and so on.
        The annotation includes the species used for balance, the
        temperature and the pressure.

    show_nonparticipating_mineral_lines : bool, default False
        Depict lines for minerals even if those minerals do not participate
        in the reaction? This does not affect the mineral field of the
        diagram, only the mineral planes denoted as lines.
    
    path_line_type : str, default &#34;markers+lines&#34;
        Reaction path line type. Can be either &#34;markers+lines&#34;, &#34;lines&#34;, or
        &#34;markers&#34;.
    
    path_line_color, str, default &#34;black&#34;
        Color of reaction path line.
    
    path_point_fill_color : str, default &#34;black&#34;
        Fill color of non-projected points along the reaction path. The
        fill color of projected points is handled by
        `projected_point_fill_color`.
    
    path_point_line_color : str, default &#34;black&#34;
        Color of the outlines of non-projected points along the reaction
        path. The outline color of projected points is handled by
        `projected_point_line_color`.
    
    projected_point_fill_color : str, default &#34;white&#34;
        Fill color of projected points along the reaction path. The
        fill color of non-projected points is handled by
        `path_point_fill_color`.
    
    projected_point_line_color : str, default &#34;black&#34;
        Color of the outlines of projected points along the reaction path.
        The outline color of non-projected points is handled by
        `path_point_line_color`.
        
    h_line_color : str, default &#34;black&#34;
        Color of horizontal lines representing minerals.
    
    v_line_color : str, default &#34;black&#34;
        Color of vertical lines representing minerals.
    
    d_line_color : str, default &#34;black&#34;
        Color of diagonal lines representing minerals.
    
    res : int, default 300
        Resolution, or number of calculations along each axis, for mineral
        stability fields. A lower number will be faster but will make appear
        boundaries blockier. A higher number takes longer to calculate, but
        will result in smoother boundaries.
    
    plot_width, plot_height : numeric, default 4 by 3
        Width and height of the plot, in inches.

    ppi : numeric, default 122
        Pixels per inch. Along with `plot_width` and `plot_height`,
        determines the size of interactive plots.
    
    borders : float, default 0
        Thickness of black lines forming boundaries between mineral
        stability regions. No lines appear if equal to 0.
    
    save_as : str, optional
        Provide a filename to save this figure. Filetype of saved figure is
        determined by `save_format`.
        Note: interactive plots can be saved by clicking the &#39;Download plot&#39;
        button in the plot&#39;s toolbar.

    save_format : str, default &#34;png&#34;
        Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;,
        &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;,
        an interactive plot will be saved. Only &#39;png&#39;, &#39;svg&#39;, &#39;jpeg&#39;,
        and &#39;webp&#39; can be downloaded with the &#39;download as&#39; button in the
        toolbar of an interactive plot.

    save_scale : numeric, default 1
        Multiply title/legend/axis/canvas sizes by this factor when saving
        the figure.
    
    colormap : str, default &#34;bw&#34;
        Name of the colormap to color the scatterpoints. Accepts &#34;bw&#34;
        or names of matplotlib colormaps. If set to &#34;bw&#34;, the plot will be
        set to black and white, except for the reaction path line itself.
        The colors of the reaction path line and its points are controlled
        by `path_line_color`, `path_point_fill_color`,
        `path_point_line_color`, `projected_point_fill_color`,
        and `projected_point_line_color`.
    
    Returns
    -------
    fig_list : a list of Plotly figure objects
        A list of interactive Plotly figures. If xyb equals None
        (the default), then the list will contain figures representing all
        combinations of geochemical variables. Optionally, if xyb is
        specified, fig_list will only contain the single figure of interest.
    &#34;&#34;&#34;

    error_messages = []
    
    # check that there is only one temperature and pressure
    if not self.__is_all_same_value(self.misc_params[&#34;Temp(C)&#34;]):
        error_messages.append(&#34;Reaction paths cannot be plotted when temperature changes with reaction progress.&#34;)
    if not self.__is_all_same_value(self.misc_params[&#34;Press(bars)&#34;]):
        error_messages.append(&#34;Reaction paths cannot be plotted when pressure changes with reaction progress.&#34;)
    
    if isinstance(xyb, list):
        if len(xyb) != 3:
            error_messages.append((&#34;Error in xyb={}&#34;.format(xyb)+&#34;. &#34;
                    &#34;The xyb parameter must either be None or a list of &#34;
                    &#34;three basis species to serve as x, y, and balance variables.&#34;))
    
    if not isinstance(self.df, pd.DataFrame):
        error_messages.append((&#34;The plot_reaction_paths() function requires &#34;
                &#34;a thermodynamic database in a WORM-style CSV format, e.g., &#34;
                &#34;&#39;wrm_data.csv&#39;. You may be getting this message because &#34;
                &#34;a data0 or data1 file was used.&#34;))
    
    if len(error_messages)&gt;0:
        self.err_handler.raise_exception(&#34;\n&#34;.join(error_messages))
    
    self.T = float(self.misc_params[&#34;Temp(C)&#34;][0])
    self.P = float(self.misc_params[&#34;Press(bars)&#34;][0])
    self.path_margin = path_margin
    
    minerals_formed = [m for m in self.moles_minerals.columns if m != &#34;Xi&#34;]
    
    all_elements_of_interest = []
    for mineral in minerals_formed:
        
        if mineral not in list(self.df[&#34;name&#34;]):
            if self.verbose &gt; 0:
                print(&#34;The mineral&#34;, mineral, &#34;cannot be represented in a&#34;,
                       &#34;reaction path diagram, likely because it is missing&#34;,
                       &#34;a Gibbs free energy value in the thermodynamic&#34;,
                       &#34;database. Continuing anyway, but be aware that&#34;,
                       &#34;this mineral will not be represented in diagrams.&#34;)
            continue
        
        all_elements_of_interest += self.__get_elem_ox_of_interest_in_minerals(mineral)
    all_elements_of_interest_pre = list(set(all_elements_of_interest))
    
    # filter out elements like Fe+0, which has no aqueous species representative
    # for which to create an axis.
    bad_elem = []
    for elem in all_elements_of_interest_pre:
        if len(list(self.thermo.csv_db.loc[self.thermo.csv_db[&#39;name&#39;] == self.__get_basis_from_elem(elem), &#39;state&#39;])) == 0:
            bad_elem.append(elem)
        elif list(self.thermo.csv_db.loc[self.thermo.csv_db[&#39;name&#39;] == self.__get_basis_from_elem(elem), &#39;state&#39;])[0] != &#39;aq&#39;:
            bad_elem.append(elem)
            
    all_elements_of_interest = [elem for elem in all_elements_of_interest_pre if elem not in bad_elem]
    
    all_elements_of_interest = sorted(all_elements_of_interest)
    
    self.all_elements_of_interest = all_elements_of_interest
    
    fig_list = []
    
    # if there are only 2 elements of interest, these become the axes, and there is no
    # need to fuss with real vs projected points.
    if len(all_elements_of_interest) == 2:
        fig, _ , _ = self.__plot_reaction_path_main(
                                            triad = all_elements_of_interest,
                                            T=self.T, P=self.P,
                                            path_margin=self.path_margin,
                                            flip_xy=flip_xy,
                                            show_annotation=show_annotation,
                                            annotation_coords=annotation_coords,
                                            show_nonparticipating_mineral_lines=show_nonparticipating_mineral_lines,
                                            minerals_to_show=minerals_to_show,
                                            path_line_type=path_line_type,
                                            path_line_color=path_line_color,
                                            path_point_fill_color=path_point_fill_color,
                                            path_point_line_color=path_point_line_color,
                                            projected_point_fill_color=projected_point_fill_color,
                                            projected_point_line_color=projected_point_line_color,
                                            h_line_color=h_line_color,
                                            v_line_color=v_line_color,
                                            d_line_color=d_line_color,
                                            res=res,
                                            plot_width=plot_width,
                                            plot_height=plot_height,
                                            ppi=ppi,
                                            colormap=colormap,
                                            borders=borders,
                                            projected_points=[&#34;real&#34;]*self.moles_product_minerals.shape[0],
                                            first_pass=False)
    
        fig_list = [fig]
    
    elif len(all_elements_of_interest) &gt;= 3:

        # get a list of elem pairs for plotting
        alist = self.all_elements_of_interest
        element_plot_pairs = []
        for result in itertools.combinations(alist, 2):
            element_plot_pairs.append(list(result))

        element_plot_triad = []
        for pair in element_plot_pairs:
            elem_not_in_pair = [e for e in self.all_elements_of_interest if e not in pair]
            for e in elem_not_in_pair:
                triad_to_append = pair + [e]
                element_plot_triad.append(triad_to_append)

        if colormap == &#34;bw&#34;:
            if borders == 0:
                borders = 1
            colormap = &#34;none&#34;
            h_line_color = &#34;black&#34;
            v_line_color = &#34;black&#34;
            d_line_color = &#34;black&#34;

        fig_list = []
        pred_minerals_from_fields_list = []
        pred_minerals_from_lines_list = []
        

        if isinstance(xyb, list):
            try:
                xyb_element_plot_triad = [[self.__get_elem_ox_of_interest_in_minerals(v)[0] for v in xyb]]
            except:
                err = (&#34;Plot axes cannot accomodate desired variables. &#34;
                       &#34;Available variables include {}&#34;.format([self.__get_basis_from_elem(elem) for elem in alist]))
                self.err_handler.raise_exception(err)
            xyb_i = None
            # get index of triad that matches xyb:
            for i,triad in enumerate(element_plot_triad):
                if set(xyb_element_plot_triad[0][0:2]) == set(triad[0:2]) and xyb_element_plot_triad[0][2] == triad[2]:
                    xyb_i = i
            if xyb_i == None:
                err = (&#34;Plot axes cannot accomodate desired variables. &#34;
                       &#34;Available variables include {}&#34;.format([self.__get_basis_from_elem(elem) for elem in alist]))
                self.err_handler.raise_exception(err)
        
        if not calculate_projected_points or path_line_type==&#34;lines&#34;:
            projected_points = [&#34;real&#34;]*self.moles_product_minerals.shape[0]
            fig_list_projected_points = [projected_points]*len(element_plot_triad)
            
        else:
            
            if len(element_plot_triad) &gt; 20:
                if self.verbose &gt; 0:
                    print(&#34;Warning! There are {}&#34;.format(len(element_plot_triad)),
                          &#34;different combinations of variables that must be considered&#34;,
                          &#34;in order to plot markers.&#34;)
                    print(&#34;This might take a very long time or may not finish calculating at all.&#34;)
                    print(&#34;We recommend setting calculate_projected_points=False in&#34;,
                          &#34;plot_reaction_paths() and then restarting the&#34;,
                          &#34;calculation to avoid lengthy calculation times.&#34;)
            
            for triad in element_plot_triad:
                
                # do a quick first pass at making figures to see which points are projections.
                fig, pred_minerals_from_fields, pred_minerals_from_lines = self.__plot_reaction_path_main(
                                                    triad, T=self.T, P=self.P,
                                                    show_nonparticipating_mineral_lines=False, # no need for this in first pass
                                                    minerals_to_show=[], # no need for this in first pass
                                                    path_margin=self.path_margin,
                                                    flip_xy=flip_xy,
                                                    first_pass=True, # flag for skipping certain calculations/plotting
                                                    res=1) # low res first pass

                if pred_minerals_from_fields == None:
                    pred_minerals_from_fields=[None]*self.moles_product_minerals.shape[0]
                
                fig_list.append(fig)
                pred_minerals_from_fields_list.append(pred_minerals_from_fields)
                pred_minerals_from_lines_list.append(pred_minerals_from_lines)

            # determine which line segments in the reaction path are projections
            # and which are actually in the plane of the diagram.
            # This is the &#34;first pass&#34;
            fig_list_projected_points = []
            for i,triad in enumerate(element_plot_triad):

                projected_points = [&#34;projection&#34;]*self.moles_product_minerals.shape[0]
                for irow in range(0, self.moles_product_minerals.shape[0]):

                    # get names of minerals formed at this xi
                    xirow = list(self.moles_product_minerals.iloc[irow])
                    formed_minerals = [self.moles_product_minerals.columns[1:][ii] for
                                       ii,mineral in enumerate(xirow[1:]) if
                                       mineral&gt;0]
                    
                    available_pred_minerals_from_fields = [l[irow] for l in pred_minerals_from_fields_list]

                    for mineral in formed_minerals:

                        if mineral == pred_minerals_from_fields_list[i][irow]:
                            # if this mineral is in pred_minerals_from_fields_list,
                            # then it is NOT a projection.
                            projected_points[irow] = &#34;real&#34;
                        if mineral in available_pred_minerals_from_fields and mineral in pred_minerals_from_lines_list[i]:
                            # if this mineral is in the irowth location of any of the
                            # lists in pred_minerals_from_lines_list, it is NOT a
                            # projection.
                            projected_points[irow] = &#34;real&#34;

                fig_list_projected_points.append(projected_points)
            
        if isinstance(xyb, list):
            # if xyb is defined, make element_plot_triad have a length of 1
            element_plot_triad = xyb_element_plot_triad
            # give the list of projected points lists a length of 1
            fig_list_projected_points = [fig_list_projected_points[xyb_i]]
            
        fig_list = []
        for i,triad in enumerate(element_plot_triad):
            # re-run figure generation, passing in a list of which points are projected.
            fig, _ , _ = self.__plot_reaction_path_main(
                                triad, T=self.T, P=self.P,
                                path_margin=self.path_margin,
                                flip_xy=flip_xy,
                                show_annotation=show_annotation,
                                annotation_coords=annotation_coords,
                                show_nonparticipating_mineral_lines=show_nonparticipating_mineral_lines,
                                minerals_to_show=minerals_to_show,
                                path_line_type=path_line_type,
                                path_line_color=path_line_color,
                                path_point_fill_color=path_point_fill_color,
                                path_point_line_color=path_point_line_color,
                                projected_point_fill_color=projected_point_fill_color,
                                projected_point_line_color=projected_point_line_color,
                                h_line_color=h_line_color,
                                v_line_color=v_line_color,
                                d_line_color=d_line_color,
                                res=res,
                                plot_width=plot_width,
                                plot_height=plot_height,
                                ppi=ppi,
                                colormap=colormap,
                                borders=borders,
                                projected_points=fig_list_projected_points[i],
                                first_pass=False)

            fig_list.append(fig)
    
    if not fig_list and self.verbose &gt; 0:
        print(&#34;Warning: a reaction path plot could not be generated for this system.&#34;)
    
    if isinstance(save_as, str):
        dummy_sp = Speciation({})
        for i,fig in enumerate(fig_list):
            
            if isinstance(xyb, list):
                name_append = &#34;&#34;
            else:
                name_append = &#34;_{}&#34;.format(i+1)
            _, _ = dummy_sp._save_figure(fig,
                    save_as+name_append, save_format, save_scale,
                    plot_width, plot_height, ppi)
    
    return fig_list</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Mass_Transfer.print_tabs"><code class="name flex">
<span>def <span class="ident">print_tabs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the names of tables contained in a tab file processed by the
the Mass_Transfer class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_tabs(self):
    &#34;&#34;&#34;
    Print the names of tables contained in a tab file processed by the
    the Mass_Transfer class.
    &#34;&#34;&#34;
    if self.tab != None:
        [print(key) for key in self.tab.keys()]
    else:
        print(&#34;A processed TAB file is not associated with this sample.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="AqEquil.MassTransfer.Mixing_Fluid"><code class="flex name class">
<span>class <span class="ident">Mixing_Fluid</span></span>
<span>(</span><span>speciation, sample_name, amount_remaining=1, amount_destroyed=0, molar_volume=1, mass_ratio=1, hide_traceback=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to define the fluid to be mixed with other fluids in
<code><a title="AqEquil.MassTransfer.Prepare_Reaction" href="#AqEquil.MassTransfer.Prepare_Reaction">Prepare_Reaction</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>speciation</code></strong> :&ensp;<code>object</code> of <code>class Speciation</code></dt>
<dd>The speciation object containing the fluid to be mixed.</dd>
<dt><strong><code>sample_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the fluid sample that will be mixed with all other
speciated fluids.</dd>
<dt><strong><code>amount_remaining</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Number of moles of the fluid to be mixed with all others.</dd>
<dt><strong><code>amount_destroyed</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Number of moles of the mixing fluid that has been destroyed.</dd>
<dt><strong><code>molar_volume</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Molar volume of the mixing fluid, in moles/cm3.</dd>
<dt><strong><code>mass_ratio</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Ratio of mass of the mixing fluid to all other fluids.</dd>
<dt><strong><code>hide_traceback</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Hide traceback message when encountering errors handled by this
class? When True, error messages handled by this class will be short
and to the point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mixing_Fluid:
    def __init__(self,
                 speciation,
                 sample_name,
                 amount_remaining=1,
                 amount_destroyed=0,
                 molar_volume=1,
                 mass_ratio=1,
                 hide_traceback=True,
                ):

        &#34;&#34;&#34;
        Class used to define the fluid to be mixed with other fluids in
        `Prepare_Reaction`.

        Parameters
        ----------
        speciation : object of class Speciation
            The speciation object containing the fluid to be mixed.

        sample_name : str
            The name of the fluid sample that will be mixed with all other
            speciated fluids.

        amount_remaining : float, default 1
            Number of moles of the fluid to be mixed with all others.

        amount_destroyed : float, default 0
            Number of moles of the mixing fluid that has been destroyed.

        molar_volume : float, default 1
            Molar volume of the mixing fluid, in moles/cm3.

        mass_ratio : float, default 1
            Ratio of mass of the mixing fluid to all other fluids.

        hide_traceback : bool, default True
            Hide traceback message when encountering errors handled by this
            class? When True, error messages handled by this class will be short
            and to the point.
            
        &#34;&#34;&#34;
        
        self.err_handler = Error_Handler(clean=hide_traceback)

        # Prepare a special reactant to be used in a mixing calculation.
        if isinstance(speciation, Speciation):
            
            self.sample_name = sample_name
            self.speciation_sample_data = speciation.sample_data[sample_name]
            self.T = self.speciation_sample_data[&#34;temperature&#34;]
            self.mass_ratio = mass_ratio
            
            elemental_composition_lines = []
            capture = False
            for i,line in enumerate(speciation.raw_3_pickup_dict_top[sample_name]):
                if &#34;|-&gt;|Composition&#34; in line:
                    capture = True
                    i_start = i
                if &#34;|-&gt;|Reaction&#34; in line:
                    capture = False
                if capture and i &gt; i_start + 3:
                    elemental_composition_lines.append(line)
            
            # ignore last line, which is a divider &#34;|----------...&#34;
            elemental_composition_lines = elemental_composition_lines[:-1]

            fluid_2_dict = {}
            for line in elemental_composition_lines:
                split_line = line.split(&#34;|&#34;)
                element = split_line[2].strip()
                value = float(split_line[3])
                fluid_2_dict[element] = value
            
            self.reactant = Reactant(reactant_name=&#34;Fluid 2&#34;,
                                     reactant_type=&#34;Special reactant&#34;,
                                     special_reactant_dict=fluid_2_dict,
                                     amount_remaining=amount_remaining,
                                     amount_destroyed=amount_destroyed,
                                     molar_volume=molar_volume,
                                     hide_traceback=hide_traceback)
            
            self.formatted_block = self.reactant.formatted_block
            self.reactant_type = &#34;Special reactant&#34;
            
        else:
            self.err_handler.raise_exception((&#34;The speciation parameter was&#34;
                    &#34; not given a Speciation object. A Speciation object is&#34;
                    &#34; produced by the AqEquil.speciate() function.&#34;))

        # handle fluid mixing reaction block

        lines_to_keep = self.formatted_block.split(&#34;\n&#34;)
        raw_p_dict_top = speciation.raw_3_pickup_dict_top

        # grab this fluid&#39;s reaction block
        reaction_block_lines = []
        capture = False
        for line in raw_p_dict_top[sample_name]:
            if &#34;|-&gt;|Reaction&#34; in line:
                capture = True
            if &#34;|-&gt;|Surface area&#34; in line:
                capture = False
            if capture:
                reaction_block_lines.append(line)

        # insert this fluid&#39;s reaction block
        before_lines = []
        after_lines = []
        is_before = True
        for i,line in enumerate(lines_to_keep):
            if &#34;|-&gt;|Reaction&#34; in line:
                is_before=False
            if is_before:
                before_lines.append(line)
            else:
                after_lines.append(line)

        # trim redundant lines
        after_lines = after_lines[5:]

        lines_to_keep = before_lines + reaction_block_lines + after_lines

        self.formatted_block = &#34;\n&#34;.join(lines_to_keep)</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Prepare_Reaction"><code class="flex name class">
<span>class <span class="ident">Prepare_Reaction</span></span>
<span>(</span><span>reactants, gases=[], t_option=None, t_value_1=None, t_value_2=None, t_value_3=None, p_option=0, p_value_1=None, p_value_2=0, xi_range=[0, 1], time_range=[0, 1e+38], pH_range=[-1e+38, 1e+38], Eh_range=[-1e+38, 1e+38], fO2_range=[-1e+38, 1e+38], aw_range=[-1e+38, 1e+38], max_n_steps=900, xi_print_int=1, log_xi_print_int=1, time_print_int=1e+38, log_time_print_int=1e+38, pH_print_interval=1e+38, Eh_print_interval=1e+38, logfO2_print_interval=1e+38, aw_print_interval=1e+38, n_steps_print_interval=100, physical_system_model='closed', kinetic_mode='arbitrary', phase_boundary_search=0, permit_solid_solutions=False, clear_es_solids_read=False, clear_es_solids_initial=False, clear_es_solids_end=False, clear_prs_solids_read=False, clear_prs_solids_end=False, auto_basis_switching_pre_NR=False, auto_basis_switching_post_NR=False, calc_mode_selection=0, ODE_corrector_mode=0, mineral_suppression_option='None', write_tab=-1, fluid_mixing_setup=False, max_finite_difference_order=6, beta_convergence_tolerance=0, del_convergence_tolerance=0, max_n_NR_iter=500, search_find_convergeance_tolerance=0, saturation_tolerance=0, max_n_phase_assemblage_tries=0, zero_order_step_size=0, max_interval_in_xi_between_PRS_transfers=0, filename=None, hide_traceback=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to set the parameters of a reaction between the results of a
speciation calculation and minerals, gases, etc.</p>
<h2 id="parameters">Parameters</h2>
<p>reactants : list
List of reactants defined by the 'Reactant' class. Can be an empty
list if no reactants are desired.</p>
<p>gases : list, default []
List of gases defined by the 'Gas' class. Can be an empty
list if no gases are desired.</p>
<p>t_option : int, default 0
Desired option for handling temperature of the reaction. Valid
choices include:
- 0 for constant temperature
- 1 for linear tracking in Xi
- 2 for linear tracking in time
Fluid mixing tracking is not yet supported.</p>
<p>t_value_1, t_value_2, t_value_3 P: default None, 0, 0, respectively
By default, the temperature of samples in the speciation
calculation will be used, so the user does not need to specify
temperature values here. However, if a user wishes, temperature
values can be defined here that will be applied to all samples in
the speciation. Note that doing so may result in incongruous
results. That said, the values specified here depend on which
option is selected for <code>t_option</code>:
- If 't_option' is 0, then t_value_1 is the value of the constant
temperature (in degrees C), and t_value_2 and t_value_3 are ignored.
- If 't_option' is 1, then t_value_1 is the base value
temperature (in degrees C), t_value_2 is the derivative, and
t_value_3 is ignored.
- If 't_option' is 2, then t_value_1 is the base value
temperature (in degrees C), t_value_2 is the derivative, and
t_value_3 is ignored.</p>
<p>p_option : int, default 0
Desired option for handling pressure of the reaction. Valid
choices include:
- 0 to follow the data file reference pressure curve
- 1 to follow the 1.013-bar/steam-saturation curve
- 2 for constant pressure
- 3 for linear tracking in Xi
- 4 for linear tracking in time</p>
<p>p_value_1, p_value_2 : float default None, 0
Values assigned to desired <code>p_option</code>.
- If <code>p_option</code> is 0 or 1, p_value_1 and p_value_2 are ignored.
- If <code>p_option</code> is 2, p_value_1 represents a constant pressure,
in bars, and p_value_2 is ignored.
- If <code>p_option</code> is 3 or 4, p_value_1 represents the base pressure
value, in bars, and p_value_2 is the derivative.</p>
<p>xi_range : list of two float, default [0, 1]
A list containing the starting and maximum value of Xi,
respectively.</p>
<p>time_range : list of two float, default [0, 1e38]
A list containing the starting and maximum time, respectively.</p>
<p>pH_range : list of two float, default [-1e38, 1e38]
A list containing the minimum and maximum values of pH.</p>
<p>Eh_range : list of two float, default [-1e38, 1e38]
A list containing the minimum and maximum values of Eh.</p>
<p>fO2_range : list of two float, default [-1e38, 1e38]
A list containing the minimum and maximum values of the fugacity
of oxygen, fO2.</p>
<p>aw_range : list of two float, default [-1e38, 1e38]
A list containing the minimum and maximum values of water activity.</p>
<p>max_n_steps : int, default 900
Maximum number of steps of Xi allowed.</p>
<p>xi_print_int : int, default 1
Xi print interval.</p>
<p>log_xi_print_int : int, default 1
Log Xi print interval.</p>
<p>time_print_int : int, default 1e38
Time print interval.</p>
<p>log_time_print_int : int, default 1e38
Log time print interval.</p>
<p>pH_print_interval : int, default 1e38
pH print interval.</p>
<p>Eh_print_interval : int, default 1e38
Eh (v) print interval.</p>
<p>logfO2_print_interval : int, default 1e38
Log fO2 print interval.</p>
<p>aw_print_interval : int, default 1e38
Activity of water (aw) print interval.</p>
<p>n_steps_print_interval : int, default 100
Steps print interval.</p>
<dl>
<dt><strong><code>physical_system_model</code></strong> :&ensp;<code>str</code>, default <code>"closed"</code></dt>
<dd>Selection for the physical system model. Valid options include:
- "closed"
- "titration"
- "fluid-centered flow-through open"</dd>
<dt><strong><code>kinetic_mode</code></strong> :&ensp;<code>str</code>, default <code>"arbitrary"</code></dt>
<dd>Selection for kinetic mode. Valid options include:
- "arbitrary" for arbitrary kinetics, reaction progress mode
- "true" for true kinetics, reaction progress/time mode</dd>
<dt><strong><code>phase_boundary_search</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>Selection for phase boundary searches. Valid options include:
- 0 to search for phase boundaries and constrain the step size to
match.
- 1 to search for phase boundaries and print their locations.
- 2 to not search for phase boundaries.</dd>
<dt><strong><code>permit_solid_solutions</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Permit solid solutions? If False, solid solutions are ignored.</dd>
<dt><strong><code>clear_es_solids_read</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Clear the ES solids read from the input file?</dd>
<dt><strong><code>clear_es_solids_initial</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Clear the ES solids at the initial value of reaction progress?</dd>
<dt><strong><code>clear_es_solids_end</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Clear the ES solids at the end of the run?</dd>
<dt><strong><code>clear_prs_solids_read</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Clear the PRS solids read from the input file?</dd>
<dt><strong><code>clear_prs_solids_end</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Clear the PRS solids at the end of the run? If True, PRS solids will
be cleared unless numerical problems cause early termination.</dd>
<dt><strong><code>auto_basis_switching_pre_NR</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Turn on auto basis switching in pre-Newton-Raphson optimization?</dd>
<dt><strong><code>auto_basis_switching_post_NR</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Turn on auto basis switching after Newton-Raphson iteration?</dd>
<dt><strong><code>calc_mode_selection</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>Calculational mode selection. Valid options include:
- 0 for normal path tracing
- 1 for economy mode (if permissible)
- 2 for super economy mode (if permissible)</dd>
<dt><strong><code>ODE_corrector_mode</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>ODE integrator corrector mode selection. Valid options include:
- 0 to allow stiff and simple correctors
- 1 to allow only simple corrector
- 2 to allow only stiff corrector
- 3 to allow no correctors</dd>
<dt><strong><code>mineral_suppression_option</code></strong> :&ensp;<code>str</code>, default <code>"None"</code></dt>
<dd>Option to suppress formation of minerals. Can be either "None" (no
minerals are suppressed) or "All" (all minerals are suppressed).</dd>
<dt><strong><code>write_tab</code></strong> :&ensp;<code>int</code>, default <code>-1</code></dt>
<dd>Option to write a TAB file. Valid options include:
- -1 do not write a TAB file (default)
- 0 write a TAB file
- 1 write a TAB file prepending TABX file data from a previous run</dd>
<dt><strong><code>fluid_mixing_setup</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, will write an EQ6 input file with Fluid 1 set up for
fluid mixing. If False, a normal EQ6 pickup file will be written.</dd>
</dl>
<p>max_finite_difference_order : int, default 6
Maximum finite-difference order (numerical parameter).</p>
<p>beta_convergence_tolerance : float, default 0
Beta convergence tolerance (numerical parameter).</p>
<p>del_convergence_tolerance : float, default 0
Delta convergence tolerance (numerical parameter).</p>
<p>max_n_NR_iter : int, default 500
Maximum number of N-R iterations (numerical parameter).</p>
<p>search_find_convergeance_tolerance : float, default 0
Search/find convergence tolerance (numerical parameter).</p>
<p>saturation_tolerance : float, default 0
Saturation tolerance (numerical parameter).</p>
<p>max_n_phase_assemblage_tries : int, default 0
Maximum number of phase assemblage tries (numerical parameter).</p>
<p>zero_order_step_size : int, default 0
Zero order step size in Xi (numerical parameter).</p>
<p>max_interval_in_xi_between_PRS_transfers : int, default 0
Maximum interval in Xi between PRS transfers (numerical parameter).</p>
<p>filename : str, default None
Filename where the results of <code><a title="AqEquil.MassTransfer.Prepare_Reaction" href="#AqEquil.MassTransfer.Prepare_Reaction">Prepare_Reaction</a></code> will be written.
This is equivalent to the top half of an EQ3/6 6i file. If None,
no file will be written.</p>
<dl>
<dt><strong><code>hide_traceback</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Hide traceback message when encountering errors handled by this class?
When True, error messages handled by this class will be short and to
the point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Prepare_Reaction:
    def __init__(self,
                 reactants,
                 gases=[],
                 t_option=None,
                 t_value_1=None, # temp
                 t_value_2=None,  # temp or deriv
                 t_value_3=None,  # mass ratio factor
                 p_option=0,
                 p_value_1=None,  # pressure
                 p_value_2=0,  # deriv
                 xi_range=[0, 1],
                 time_range=[0, 1e38],
                 pH_range=[-1e38, 1e38],
                 Eh_range=[-1e38, 1e38],
                 fO2_range=[-1e38, 1e38],
                 aw_range=[-1e38, 1e38],
                 max_n_steps=900,
                 xi_print_int=1,
                 log_xi_print_int=1,
                 time_print_int=1e38,
                 log_time_print_int=1e38,
                 pH_print_interval=1e38,
                 Eh_print_interval=1e38,
                 logfO2_print_interval=1e38,
                 aw_print_interval=1e38,
                 n_steps_print_interval=100,
                 physical_system_model=&#34;closed&#34;,
                 kinetic_mode=&#34;arbitrary&#34;,
                 phase_boundary_search=0,
                 permit_solid_solutions=False,
                 clear_es_solids_read=False,
                 clear_es_solids_initial=False,
                 clear_es_solids_end=False,
                 clear_prs_solids_read=False,
                 clear_prs_solids_end=False,
                 auto_basis_switching_pre_NR=False,
                 auto_basis_switching_post_NR=False,
                 calc_mode_selection=0,
                 ODE_corrector_mode=0,
                 mineral_suppression_option=&#34;None&#34;,
                 write_tab=-1, # do not write a TAB file by default because EQ6 can encounter an access violation when writing a TAB file
                 fluid_mixing_setup=False,
                 max_finite_difference_order=6,
                 beta_convergence_tolerance=0,
                 del_convergence_tolerance=0,
                 max_n_NR_iter=500,
                 search_find_convergeance_tolerance=0,
                 saturation_tolerance=0,
                 max_n_phase_assemblage_tries=0,
                 zero_order_step_size=0,
                 max_interval_in_xi_between_PRS_transfers=0,
                 filename=None,
                 hide_traceback=True,
                ):
        
        &#34;&#34;&#34;
        Class used to set the parameters of a reaction between the results of a
        speciation calculation and minerals, gases, etc.

        Parameters
        ----------
         reactants : list
             List of reactants defined by the &#39;Reactant&#39; class. Can be an empty
             list if no reactants are desired.
             
         gases : list, default []
             List of gases defined by the &#39;Gas&#39; class. Can be an empty
             list if no gases are desired.
         
         t_option : int, default 0
             Desired option for handling temperature of the reaction. Valid
             choices include:
             - 0 for constant temperature
             - 1 for linear tracking in Xi
             - 2 for linear tracking in time
             Fluid mixing tracking is not yet supported.
         
         t_value_1, t_value_2, t_value_3 P: default None, 0, 0, respectively
             By default, the temperature of samples in the speciation
             calculation will be used, so the user does not need to specify
             temperature values here. However, if a user wishes, temperature
             values can be defined here that will be applied to all samples in
             the speciation. Note that doing so may result in incongruous
             results. That said, the values specified here depend on which
             option is selected for `t_option`:
             - If &#39;t_option&#39; is 0, then t_value_1 is the value of the constant
             temperature (in degrees C), and t_value_2 and t_value_3 are ignored.
             - If &#39;t_option&#39; is 1, then t_value_1 is the base value
             temperature (in degrees C), t_value_2 is the derivative, and
             t_value_3 is ignored.
             - If &#39;t_option&#39; is 2, then t_value_1 is the base value
             temperature (in degrees C), t_value_2 is the derivative, and
             t_value_3 is ignored.
         
         p_option : int, default 0
             Desired option for handling pressure of the reaction. Valid
             choices include:
             - 0 to follow the data file reference pressure curve
             - 1 to follow the 1.013-bar/steam-saturation curve
             - 2 for constant pressure
             - 3 for linear tracking in Xi
             - 4 for linear tracking in time
         
         p_value_1, p_value_2 : float default None, 0
             Values assigned to desired `p_option`.
             - If `p_option` is 0 or 1, p_value_1 and p_value_2 are ignored.
             - If `p_option` is 2, p_value_1 represents a constant pressure,
             in bars, and p_value_2 is ignored.
             - If `p_option` is 3 or 4, p_value_1 represents the base pressure
             value, in bars, and p_value_2 is the derivative.
         
         xi_range : list of two float, default [0, 1]
             A list containing the starting and maximum value of Xi,
             respectively.
         
         time_range : list of two float, default [0, 1e38]
             A list containing the starting and maximum time, respectively.
         
         pH_range : list of two float, default [-1e38, 1e38]
             A list containing the minimum and maximum values of pH.
         
         Eh_range : list of two float, default [-1e38, 1e38]
             A list containing the minimum and maximum values of Eh.
         
         fO2_range : list of two float, default [-1e38, 1e38]
             A list containing the minimum and maximum values of the fugacity
             of oxygen, fO2.
         
         aw_range : list of two float, default [-1e38, 1e38]
             A list containing the minimum and maximum values of water activity.
         
         max_n_steps : int, default 900
             Maximum number of steps of Xi allowed.
         
         xi_print_int : int, default 1
             Xi print interval.
         
         log_xi_print_int : int, default 1
             Log Xi print interval.
         
         time_print_int : int, default 1e38
             Time print interval.
         
         log_time_print_int : int, default 1e38
             Log time print interval.
         
         pH_print_interval : int, default 1e38
             pH print interval.
         
         Eh_print_interval : int, default 1e38
             Eh (v) print interval.
         
         logfO2_print_interval : int, default 1e38
             Log fO2 print interval.
         
         aw_print_interval : int, default 1e38
             Activity of water (aw) print interval.
         
         n_steps_print_interval : int, default 100
             Steps print interval.

        physical_system_model : str, default &#34;closed&#34;
            Selection for the physical system model. Valid options include:
            - &#34;closed&#34;
            - &#34;titration&#34;
            - &#34;fluid-centered flow-through open&#34;
        
        kinetic_mode : str, default &#34;arbitrary&#34;
            Selection for kinetic mode. Valid options include:
            - &#34;arbitrary&#34; for arbitrary kinetics, reaction progress mode
            - &#34;true&#34; for true kinetics, reaction progress/time mode 
         
        phase_boundary_search : int, default 0
            Selection for phase boundary searches. Valid options include:
            - 0 to search for phase boundaries and constrain the step size to
            match.
            - 1 to search for phase boundaries and print their locations.
            - 2 to not search for phase boundaries.
        
        permit_solid_solutions : bool, default False
            Permit solid solutions? If False, solid solutions are ignored.
        
        clear_es_solids_read : bool, default False
            Clear the ES solids read from the input file?
        
        clear_es_solids_initial : bool, default False
            Clear the ES solids at the initial value of reaction progress?
        
        clear_es_solids_end : bool, default False
            Clear the ES solids at the end of the run?
        
        clear_prs_solids_read : bool, default False
            Clear the PRS solids read from the input file?
        
        clear_prs_solids_end : bool, default False
            Clear the PRS solids at the end of the run? If True, PRS solids will
            be cleared unless numerical problems cause early termination.
        
        auto_basis_switching_pre_NR : bool, default False
            Turn on auto basis switching in pre-Newton-Raphson optimization?
        
        auto_basis_switching_post_NR : bool, default False
            Turn on auto basis switching after Newton-Raphson iteration?
        
        calc_mode_selection : int, default 0
            Calculational mode selection. Valid options include:
            - 0 for normal path tracing
            - 1 for economy mode (if permissible)
            - 2 for super economy mode (if permissible)
        
        ODE_corrector_mode : int, default 0
            ODE integrator corrector mode selection. Valid options include:
            - 0 to allow stiff and simple correctors
            - 1 to allow only simple corrector
            - 2 to allow only stiff corrector
            - 3 to allow no correctors
        
        mineral_suppression_option : str, default &#34;None&#34;
            Option to suppress formation of minerals. Can be either &#34;None&#34; (no
            minerals are suppressed) or &#34;All&#34; (all minerals are suppressed).
        
        write_tab : int, default -1
            Option to write a TAB file. Valid options include:
            - -1 do not write a TAB file (default)
            - 0 write a TAB file
            - 1 write a TAB file prepending TABX file data from a previous run
        
        fluid_mixing_setup : bool, default False
            If True, will write an EQ6 input file with Fluid 1 set up for
            fluid mixing. If False, a normal EQ6 pickup file will be written.
         
         max_finite_difference_order : int, default 6
             Maximum finite-difference order (numerical parameter).
         
         beta_convergence_tolerance : float, default 0
             Beta convergence tolerance (numerical parameter).
         
         del_convergence_tolerance : float, default 0
             Delta convergence tolerance (numerical parameter).
         
         max_n_NR_iter : int, default 500
             Maximum number of N-R iterations (numerical parameter).
         
         search_find_convergeance_tolerance : float, default 0
             Search/find convergence tolerance (numerical parameter).
         
         saturation_tolerance : float, default 0
             Saturation tolerance (numerical parameter).
         
         max_n_phase_assemblage_tries : int, default 0
             Maximum number of phase assemblage tries (numerical parameter).
         
         zero_order_step_size : int, default 0
             Zero order step size in Xi (numerical parameter).
         
         max_interval_in_xi_between_PRS_transfers : int, default 0
             Maximum interval in Xi between PRS transfers (numerical parameter).
         
         filename : str, default None
             Filename where the results of `Prepare_Reaction` will be written.
             This is equivalent to the top half of an EQ3/6 6i file. If None,
             no file will be written.
             
        hide_traceback : bool, default True
            Hide traceback message when encountering errors handled by this class?
            When True, error messages handled by this class will be short and to
            the point.

        &#34;&#34;&#34;
        
        self.err_handler = Error_Handler(clean=hide_traceback)
        
        if len(reactants) == 1 and not isinstance(reactants, list):
            reactants = list(reactants)
            
        if len(gases) == 0:
            gases = [Gas()]
        elif len(gases) == 1 and not isinstance(gases, list):
            gases = list(gases)
        
        self.reactants=reactants
        self.gases=gases
        self.t_option=t_option
        self.t_value_1=t_value_1
        self.t_value_2=t_value_2
        self.t_value_3=t_value_3
        self.p_option=p_option
        self.p_value_1=p_value_1
        self.p_value_2=p_value_2
        self.start_xi=xi_range[0]
        self.max_xi=xi_range[1]
        self.start_time=time_range[0]
        self.max_time=time_range[1]
        self.min_pH=pH_range[0]
        self.max_pH=pH_range[1]
        self.min_Eh=Eh_range[0]
        self.max_Eh=Eh_range[1]
        self.min_fO2=fO2_range[0]
        self.max_fO2=fO2_range[1]
        self.min_aw=aw_range[0]
        self.max_aw=aw_range[1]
        self.max_n_steps=max_n_steps
        self.xi_print_int=xi_print_int
        self.log_xi_print_int=log_xi_print_int
        self.time_print_int=time_print_int
        self.log_time_print_int=log_time_print_int
        self.pH_print_interval=pH_print_interval
        self.Eh_print_interval=Eh_print_interval
        self.logfO2_print_interval=logfO2_print_interval
        self.aw_print_interval=aw_print_interval
        self.n_steps_print_interval=n_steps_print_interval
        self.max_finite_difference_order=max_finite_difference_order
        self.beta_convergence_tolerance=beta_convergence_tolerance
        self.del_convergence_tolerance=del_convergence_tolerance
        self.max_n_NR_iter=max_n_NR_iter
        self.search_find_convergeance_tolerance=search_find_convergeance_tolerance
        self.saturation_tolerance=saturation_tolerance
        self.max_n_phase_assemblage_tries=max_n_phase_assemblage_tries
        self.zero_order_step_size=zero_order_step_size
        self.max_interval_in_xi_between_PRS_transfers=max_interval_in_xi_between_PRS_transfers
        self.mineral_suppression_option=mineral_suppression_option
        
        self.t_checkbox_1=&#34; &#34;
        self.t_checkbox_2=&#34; &#34;
        self.t_checkbox_3=&#34; &#34;
        self.t_checkbox_4=&#34; &#34;
        self.tval1=0
        self.tval2=0
        self.tval3=0
        self.tval4=0
        self.tval5=0
        self.tval6=0
        self.tval7=0
        self.tval8=0
        self.p_checkbox_1=&#34; &#34;
        self.p_checkbox_2=&#34; &#34;
        self.p_checkbox_3=&#34; &#34;
        self.p_checkbox_4=&#34; &#34;
        self.p_checkbox_5=&#34; &#34;
        self.pval1=0
        self.pval2=0
        self.pval3=0
        self.pval4=0
        self.pval5=0
        self.i1_checkbox_1 = &#34; &#34;
        self.i1_checkbox_2 = &#34; &#34;
        self.i1_checkbox_3 = &#34; &#34;
        self.i2_checkbox_1 = &#34; &#34;
        self.i2_checkbox_2 = &#34; &#34;
        self.i3_checkbox_1 = &#34; &#34;
        self.i3_checkbox_2 = &#34; &#34;
        self.i3_checkbox_3 = &#34; &#34;
        self.i4_checkbox_1 = &#34; &#34;
        self.i4_checkbox_2 = &#34; &#34;
        self.i5_checkbox_1 = &#34; &#34;
        self.i5_checkbox_2 = &#34; &#34;
        self.i6_checkbox_1 = &#34; &#34;
        self.i6_checkbox_2 = &#34; &#34;
        self.i7_checkbox_1 = &#34; &#34;
        self.i7_checkbox_2 = &#34; &#34;
        self.i9_checkbox_1 = &#34; &#34;
        self.i9_checkbox_2 = &#34; &#34;
        self.i10_checkbox_1 = &#34; &#34;
        self.i10_checkbox_2 = &#34; &#34;
        self.i11_checkbox_1 = &#34; &#34;
        self.i11_checkbox_2 = &#34; &#34;
        self.i12_checkbox_1 = &#34; &#34;
        self.i12_checkbox_2 = &#34; &#34;
        self.i13_checkbox_1 = &#34; &#34;
        self.i13_checkbox_2 = &#34; &#34;
        self.i13_checkbox_3 = &#34; &#34;
        self.i14_checkbox_1 = &#34; &#34;
        self.i14_checkbox_2 = &#34; &#34;
        self.i14_checkbox_3 = &#34; &#34;
        self.i14_checkbox_4 = &#34; &#34;
        self.i15_checkbox_1 = &#34; &#34;
        self.i15_checkbox_2 = &#34; &#34;
        self.i18_checkbox_1 = &#34; &#34;
        self.i18_checkbox_2 = &#34; &#34;
        self.i18_checkbox_3 = &#34; &#34;
        self.i20_checkbox_1 = &#34; &#34;
        self.i20_checkbox_2 = &#34; &#34;
        
        tval_var_to_format = None
        pval_var_to_format = None
        
        # set t_option and t_value defaults when there is a mixing calculation
        n_mixing_fluid_reactants=0
        for reactant in reactants:
            if isinstance(reactant, Mixing_Fluid):
                n_mixing_fluid_reactants += 1
                if t_option == None:
                    t_option = 3
                    self.t_option=t_option
                if t_value_1 == None:
                    t_value_1 = None # will be formatted with temp of fluid 1 later
                    self.t_value_1=t_value_1
                if t_value_2 == None:
                    t_value_2 = float(reactant.T) # temp of fluid 2
                    self.t_value_2=t_value_2
                if t_value_3 == None:
                    t_value_3 = reactant.mass_ratio # mass ratio factor
                    self.t_value_3=t_value_3
                
        if n_mixing_fluid_reactants == 0:
            # set t_option and t_value defaults when there is no mixing calculation
            if t_option == None:
                t_option = 0
                self.t_option = 0
#             if t_value_1 == None:
#                 t_value_1 = None
#                 self.t_value_1 = 0
#             if t_value_2 == None:
#                 t_value_2 = 0
#                 self.t_value_2 = 0
#             if t_value_3 == None:
#                 t_value_3 = 0
#                 self.t_value_3 = 0
        elif n_mixing_fluid_reactants == 1:
            pass
        else:
            self.err_handler.raise_exception((&#34;&#34;
                    &#34;There are {} mixing fluids &#34;.format(n_mixing_fluid_reactants)+&#34;&#34;
                    &#34;in the list of reactants. There may only be one.&#34;))
        if t_option == 0:
            self.t_checkbox_1=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval1=t_value_1
            else:
                tval_var_to_format = 1

        elif t_option == 1:
            self.t_checkbox_2=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval2=t_value_1
                self.tval3=t_value_2
            else:
                tval_var_to_format = 2

        elif t_option == 2:
            self.t_checkbox_3=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval4=t_value_1
                self.tval5=t_value_2
            else:
                tval_var_to_format = 4
                
        elif t_option == 3:
            self.t_checkbox_4=&#34;x&#34;
            if isinstance(t_value_1, numbers.Number):
                self.tval6=t_value_1
                self.tval7=t_value_2
                self.tval8=t_value_3
            else:
                self.tval7=t_value_2
                self.tval8=t_value_3
                tval_var_to_format = 6
        else:
            raise Exception(&#34;t_option must be 0, 1, 2, or 3.&#34;)
            
        if p_option == 0:
            self.p_checkbox_1=&#34;x&#34;

        elif p_option == 1:
            self.p_checkbox_2=&#34;x&#34;

        elif p_option == 2:
            self.p_checkbox_3=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval1=p_value_1
            else:
                pval_var_to_format = 1
                
        elif p_option == 3:
            self.p_checkbox_4=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval2=p_value_1
                self.pval3=p_value_2
            else:
                pval_var_to_format = 2
                
        elif p_option == 4:
            self.p_checkbox_5=&#34;x&#34;
            if isinstance(p_value_1, numbers.Number):
                self.pval4=p_value_1
                self.pval5=p_value_2
            else:
                pval_var_to_format = 4

        else:
            raise Exception(&#34;p_option must be 0, 1, 2, 3, or 4.&#34;)
        
        
        if physical_system_model == &#34;closed&#34;:
            self.i1_checkbox_1 = &#34;x&#34;
        elif physical_system_model == &#34;titration&#34;:
            self.i1_checkbox_2 = &#34;x&#34;
        elif physical_system_model == &#34;fluid-centered flow-through open&#34;:
            self.i1_checkbox_3 = &#34;x&#34;
        else:
            msg = (&#34;physical_system_model must either be &#39;closed&#39;, &#39;titration&#39;,&#34;
                &#34; or &#39;fluid-centered flow-through open&#39;.&#34;)
            self.err_handler.raise_exception(msg)

        if kinetic_mode == &#34;arbitrary&#34;:
            self.i2_checkbox_1 = &#34;x&#34;
        elif kinetic_mode == &#34;true&#34;:
            self.i2_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;kinetic_mode must either be &#39;arbitrary&#39; or &#39;true&#39;.&#34;
            self.err_handler.raise_exception(msg)
        
        if phase_boundary_search == 0:
            self.i3_checkbox_1 = &#34;x&#34;
        elif phase_boundary_search == 1:
            self.i3_checkbox_2 = &#34;x&#34;
        elif phase_boundary_search == 2:
            self.i3_checkbox_3 = &#34;x&#34;
        else:
            msg = &#34;phase_boundary_search must be 0, 1, or 2.&#34;
            self.err_handler.raise_exception(msg)
            
        if permit_solid_solutions == False:
            self.i4_checkbox_1 = &#34;x&#34;
        elif permit_solid_solutions == True:
            self.i4_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;permit_solid_solutions must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if clear_es_solids_read == False:
            self.i5_checkbox_1 = &#34;x&#34;
        elif clear_es_solids_read == True:
            self.i5_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_es_solids_read must be True or False.&#34;
            self.err_handler.raise_exception(msg)

        if clear_es_solids_initial == False:
            self.i6_checkbox_1 = &#34;x&#34;
        elif clear_es_solids_initial == True:
            self.i6_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_es_solids_initial must be True or False.&#34;
            self.err_handler.raise_exception(msg)

        if clear_es_solids_end == False:
            self.i7_checkbox_1 = &#34;x&#34;
        elif clear_es_solids_end == True:
            self.i7_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_es_solids_end must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        # there is no iopt8
            
        if clear_prs_solids_read == False:
            self.i9_checkbox_1 = &#34;x&#34;
        elif clear_prs_solids_read == True:
            self.i9_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_prs_solids_read must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if clear_prs_solids_end == False:
            self.i10_checkbox_1 = &#34;x&#34;
        elif clear_prs_solids_end == True:
            self.i10_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;clear_prs_solids_end must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if auto_basis_switching_pre_NR == False:
            self.i11_checkbox_1 = &#34;x&#34;
        elif auto_basis_switching_pre_NR == True:
            self.i11_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;auto_basis_switching_pre_NR must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if auto_basis_switching_post_NR == False:
            self.i12_checkbox_1 = &#34;x&#34;
        elif auto_basis_switching_post_NR == True:
            self.i12_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;auto_basis_switching_post_NR must be True or False.&#34;
            self.err_handler.raise_exception(msg)
            
        if calc_mode_selection == 0:
            self.i13_checkbox_1 = &#34;x&#34;
        elif calc_mode_selection == 1:
            self.i13_checkbox_2 = &#34;x&#34;
        elif calc_mode_selection == 2:
            self.i13_checkbox_3 = &#34;x&#34;
        else:
            msg = &#34;calc_mode_selection must be 0, 1, or 2.&#34;
            self.err_handler.raise_exception(msg)

        if ODE_corrector_mode == 0:
            self.i14_checkbox_1 = &#34;x&#34;
        elif ODE_corrector_mode == 1:
            self.i14_checkbox_2 = &#34;x&#34;
        elif ODE_corrector_mode == 2:
            self.i14_checkbox_3 = &#34;x&#34;
        elif ODE_corrector_mode == 3:
            self.i14_checkbox_4 = &#34;x&#34;
        else:
            msg = &#34;ODE_corrector_mode must be 0, 1, or 2.&#34;
            self.err_handler.raise_exception(msg)

        # The suppress redox option in EQ6 doesn&#39;t work with WORM data.
        # Use redox-isolated elements from the redox suppression
        # option in the AqEquil class instead.
        self.i15_checkbox_1 = &#34;x&#34;

        if write_tab == -1:
            self.i18_checkbox_1 = &#34;x&#34;
        elif write_tab == 0:
            self.i18_checkbox_2 = &#34;x&#34;
        elif write_tab == 1:
            self.i18_checkbox_3 = &#34;x&#34;
        else:
            self.err_handler.raise_exception(&#34;write_tab_option must be -1, 0, &#34;
                    &#34;or 1.&#34;)
            
        
        if fluid_mixing_setup == False:
            self.i20_checkbox_1 = &#34;x&#34;
        elif fluid_mixing_setup == True:
            self.i20_checkbox_2 = &#34;x&#34;
        else:
            msg = &#34;fluid_mixing_setup must be True or False.&#34;
            self.err_handler.raise_exception(msg)

        now = datetime.now()
        self.date_created = now.strftime(&#39;%Y-%m-%d %I:%M %p&#39;)
        
        self.__format_reaction(tval_var_to_format, pval_var_to_format)
        
        if filename != None:
            with open(filename, &#39;w&#39;) as f:
                f.write(pr.formatted_reaction)
        
        
    def __format_reaction(self, tval_var_to_format=None, pval_var_to_format=None):
        reaction_options_formatted = dict(
            date_created=f&#34;{self.date_created:&lt;24}&#34;,
            start_xi=f&#34;{&#39;{:.5E}&#39;.format(self.start_xi):&gt;12}&#34;,
            max_xi=f&#34;{&#39;{:.5E}&#39;.format(self.max_xi):&gt;12}&#34;,
            start_time=f&#34;{&#39;{:.5E}&#39;.format(self.start_time):&gt;12}&#34;,
            max_time=f&#34;{&#39;{:.5E}&#39;.format(self.max_time):&gt;12}&#34;,
            min_pH=f&#34;{&#39;{:.5E}&#39;.format(self.min_pH):&gt;12}&#34;,
            max_pH=f&#34;{&#39;{:.5E}&#39;.format(self.max_pH):&gt;12}&#34;,
            min_Eh=f&#34;{&#39;{:.5E}&#39;.format(self.min_Eh):&gt;12}&#34;,
            max_Eh=f&#34;{&#39;{:.5E}&#39;.format(self.max_Eh):&gt;12}&#34;,
            min_fO2=f&#34;{&#39;{:.5E}&#39;.format(self.min_fO2):&gt;12}&#34;,
            max_fO2=f&#34;{&#39;{:.5E}&#39;.format(self.max_fO2):&gt;12}&#34;,
            min_aw=f&#34;{&#39;{:.5E}&#39;.format(self.min_aw):&gt;12}&#34;,
            max_aw=f&#34;{&#39;{:.5E}&#39;.format(self.max_aw):&gt;12}&#34;,
            max_n_steps=f&#34;{self.max_n_steps:&gt;12}&#34;,
            xi_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.xi_print_int):&gt;12}&#34;,
            log_xi_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.log_xi_print_int):&gt;12}&#34;,
            time_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.time_print_int):&gt;12}&#34;,
            log_time_print_int=f&#34;{&#39;{:.5E}&#39;.format(self.log_time_print_int):&gt;12}&#34;,
            pH_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.pH_print_interval):&gt;12}&#34;,
            Eh_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.Eh_print_interval):&gt;12}&#34;,
            logfO2_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.logfO2_print_interval):&gt;12}&#34;,
            aw_print_interval=f&#34;{&#39;{:.5E}&#39;.format(self.aw_print_interval):&gt;12}&#34;,
            n_steps_print_interval=f&#34;{self.n_steps_print_interval:&gt;12}&#34;,
            max_finite_difference_order=f&#34;{self.max_finite_difference_order:&gt;12}&#34;,
            beta_convergence_tolerance=f&#34;{self.beta_convergence_tolerance:&gt;12}&#34;,
            del_convergence_tolerance=f&#34;{self.del_convergence_tolerance:&gt;12}&#34;,
            max_n_NR_iter=f&#34;{self.max_n_NR_iter:&gt;12}&#34;,
            search_find_convergeance_tolerance=f&#34;{self.search_find_convergeance_tolerance:&gt;12}&#34;,
            saturation_tolerance=f&#34;{self.saturation_tolerance:&gt;12}&#34;,
            max_n_phase_assemblage_tries=f&#34;{self.max_n_phase_assemblage_tries:&gt;12}&#34;,
            zero_order_step_size=f&#34;{self.zero_order_step_size:&gt;12}&#34;,
            max_interval_in_xi_between_PRS_transfers=f&#34;{self.max_interval_in_xi_between_PRS_transfers:&gt;12}&#34;,
            t_checkbox_1=self.t_checkbox_1,
            t_checkbox_2=self.t_checkbox_2,
            t_checkbox_3=self.t_checkbox_3,
            t_checkbox_4=self.t_checkbox_4,
            p_checkbox_1=self.p_checkbox_1,
            p_checkbox_2=self.p_checkbox_2,
            p_checkbox_3=self.p_checkbox_3,
            p_checkbox_4=self.p_checkbox_4,
            p_checkbox_5=self.p_checkbox_5,
            i1_checkbox_1=self.i1_checkbox_1,
            i1_checkbox_2=self.i1_checkbox_2,
            i1_checkbox_3=self.i1_checkbox_3,
            i2_checkbox_1=self.i2_checkbox_1,
            i2_checkbox_2=self.i2_checkbox_2,
            i3_checkbox_1=self.i3_checkbox_1,
            i3_checkbox_2=self.i3_checkbox_2,
            i3_checkbox_3=self.i3_checkbox_3,
            i4_checkbox_1=self.i4_checkbox_1,
            i4_checkbox_2=self.i4_checkbox_2,
            i5_checkbox_1=self.i5_checkbox_1,
            i5_checkbox_2=self.i5_checkbox_2,
            i6_checkbox_1=self.i6_checkbox_1,
            i6_checkbox_2=self.i6_checkbox_2,
            i7_checkbox_1=self.i7_checkbox_1,
            i7_checkbox_2=self.i7_checkbox_2,
            i9_checkbox_1=self.i9_checkbox_1,
            i9_checkbox_2=self.i9_checkbox_2,
            i10_checkbox_1=self.i10_checkbox_1,
            i10_checkbox_2=self.i10_checkbox_2,
            i11_checkbox_1=self.i11_checkbox_1,
            i11_checkbox_2=self.i11_checkbox_2,
            i12_checkbox_1=self.i12_checkbox_1,
            i12_checkbox_2=self.i12_checkbox_2,
            i13_checkbox_1=self.i13_checkbox_1,
            i13_checkbox_2=self.i13_checkbox_2,
            i13_checkbox_3=self.i13_checkbox_3,
            i14_checkbox_1=self.i14_checkbox_1,
            i14_checkbox_2=self.i14_checkbox_2,
            i14_checkbox_3=self.i14_checkbox_3,
            i14_checkbox_4=self.i14_checkbox_4,
            i15_checkbox_1=self.i15_checkbox_1,
            i15_checkbox_2=self.i15_checkbox_2,
            i18_checkbox_1=self.i18_checkbox_1,
            i18_checkbox_2=self.i18_checkbox_2,
            i18_checkbox_3=self.i18_checkbox_3,
            i20_checkbox_1=self.i20_checkbox_1,
            i20_checkbox_2=self.i20_checkbox_2,
        )
        
        # leave {tval1} (or {tval2}, {tval3}...) in pre_6i file so it can be updated after joining 3p
        if tval_var_to_format != None:
            reaction_options_formatted[&#34;tval&#34;+str(tval_var_to_format)] = &#34;{tval}&#34;
            for i in range(1, 9):
                if i == tval_var_to_format:
                    continue
                else:
                    reaction_options_formatted[&#34;tval&#34;+str(i)]=f&#34;{&#39;{:.5E}&#39;.format(getattr(self, &#39;tval&#39;+str(i))):&gt;12}&#34;
        else:
            reaction_options_formatted.update(dict(
                tval1=f&#34;{&#39;{:.5E}&#39;.format(self.tval1):&gt;12}&#34;,
                tval2=f&#34;{&#39;{:.5E}&#39;.format(self.tval2):&gt;12}&#34;,
                tval3=f&#34;{&#39;{:.5E}&#39;.format(self.tval3):&gt;12}&#34;,
                tval4=f&#34;{&#39;{:.5E}&#39;.format(self.tval4):&gt;12}&#34;,
                tval5=f&#34;{&#39;{:.5E}&#39;.format(self.tval5):&gt;12}&#34;,
                tval6=f&#34;{&#39;{:.5E}&#39;.format(self.tval6):&gt;12}&#34;,
                tval7=f&#34;{&#39;{:.5E}&#39;.format(self.tval7):&gt;12}&#34;,
                tval8=f&#34;{&#39;{:.5E}&#39;.format(self.tval8):&gt;12}&#34;,
            ))
            
        # leave {pval1} (or {pval2}, {pval3}...) in pre_6i file so it can be updated after joining 3p
        if pval_var_to_format != None:
            reaction_options_formatted[&#34;pval&#34;+str(pval_var_to_format)] = &#34;{pval}&#34;
            for i in range(1, 6):
                if i == pval_var_to_format:
                    continue
                else:
                    reaction_options_formatted[&#34;pval&#34;+str(i)]=f&#34;{&#39;{:.5E}&#39;.format(getattr(self, &#39;pval&#39;+str(i))):&gt;12}&#34;
        else:
            reaction_options_formatted.update(dict(
                pval1=f&#34;{&#39;{:.5E}&#39;.format(self.pval1):&gt;12}&#34;,
                pval2=f&#34;{&#39;{:.5E}&#39;.format(self.pval2):&gt;12}&#34;,
                pval3=f&#34;{&#39;{:.5E}&#39;.format(self.pval3):&gt;12}&#34;,
                pval4=f&#34;{&#39;{:.5E}&#39;.format(self.pval4):&gt;12}&#34;,
                pval5=f&#34;{&#39;{:.5E}&#39;.format(self.pval5):&gt;12}&#34;,
            ))

        
        reactant_blocks = &#34;&#34;.join([r.formatted_block for r in self.reactants])
        gas_lines = &#34;&#34;.join([r.formatted_line for r in self.gases])
        reaction_options_formatted.update(dict(reactant_blocks=reactant_blocks))
        reaction_options_formatted.update(dict(gas_lines=gas_lines))
        
        if self.mineral_suppression_option == &#34;None&#34;:
            mineral_suppress_option_value = &#34;None    &#34;
        elif self.mineral_suppression_option == &#34;All&#34;:
            mineral_suppress_option_value = &#34;All     &#34;
        else:
            msg = (&#34;Error in Prepare_Reaction(): `mineral_suppression_option` &#34;
                   &#34;must be &#39;None&#39; or &#39;All&#39;.&#34;)
            self.err_handler.raise_exception(msg)
            
        min_supp_temp = copy.copy(mineral_suppress_template)
        min_supp_dict = dict(mineral_suppress_option=mineral_suppress_option_value)
        min_supp_temp = min_supp_temp.format(**min_supp_dict)
        
        reaction_options_formatted.update(
                dict(mineral_suppress_lines=min_supp_temp)
                )
        
        reaction_template = copy.copy(template)
        self.formatted_reaction = reaction_template.format(**reaction_options_formatted)</code></pre>
</details>
</dd>
<dt id="AqEquil.MassTransfer.Reactant"><code class="flex name class">
<span>class <span class="ident">Reactant</span></span>
<span>(</span><span>reactant_name, reactant_type='Pure mineral', reactant_status='Reacting', amount_remaining=1, amount_destroyed=0, molar_volume=0, surface_area_option=0, surface_area_value=0, surface_area_factor=0, f_rate_law='Relative rate equation', f_eq1=1, f_eq2=0, f_eq3=0, b_rate_law='Partial equilibrium', b_eq1=1, b_eq2=0, b_eq3=0, special_reactant_dict={}, hide_traceback=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to define reactants for <code><a title="AqEquil.MassTransfer.Prepare_Reaction" href="#AqEquil.MassTransfer.Prepare_Reaction">Prepare_Reaction</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reactant_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the reactant.</dd>
<dt><strong><code>reactant_type</code></strong> :&ensp;<code>str</code>, default <code>"Pure mineral"</code></dt>
<dd>Reactant type. Valid types include
- Pure mineral
- Solid solution
- Special reactant
- Aqueous species
- Gas species
- Generic ion exchanger</dd>
<dt><strong><code>reactant_status</code></strong> :&ensp;<code>str</code>, default <code>"Reacting"</code></dt>
<dd>Status of the reactant. Valid statuses include
- Reacting
- Saturated, reacting
- Exhausted
- Saturated, not reacting</dd>
<dt><strong><code>amount_remaining</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Moles of reactant remaining.</dd>
<dt><strong><code>amount_destroyed</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Moles of reactant destroyed.</dd>
<dt><strong><code>surface_area_option</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>Option for reactant surface area. Valid options include:
- 0, for Constant surface area (in cm2)
- 1, for Constant specific surface area (in cm2/g). Surface area
changes in proportion to the reactant mass.
- 2, for n**2/3 growth law- current surface area (in cm2)</dd>
<dt><strong><code>surface_area_value</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Value assigned to choice of surface area option.
- If <code>surface_area_option</code> is 0, value is in cm2.
- If <code>surface_area_option</code> is 1, value is in cm2/g.
- If <code>surface_area_option</code> is 2, value is in cm2.</dd>
<dt><strong><code>surface_area_factor</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Value assigned to surface area factor.</dd>
<dt><strong><code>f_rate_law</code></strong> :&ensp;<code>str</code>, default <code>"Relative rate equation"</code></dt>
<dd>Type of forward rate law. Valid types include
- Use backward rate law
- Relative rate equation
The TST rate equation is not yet supported.</dd>
<dt><strong><code>f_eq1</code></strong>, <strong><code>f_eq2</code></strong>, <strong><code>f_eq3</code></strong> :&ensp;<code>float</code>, default <code>1, 0, 0, respectively</code></dt>
<dd>Coefficients of the forward rate law defined for <code>f_rate_law</code>.
If <code>f_rate_law</code> is "Relative rate equation", then:
- f_eq1 is dXi(n)/dXi (mol/mol)
- f_eq2 is d2Xi(n)/dXi2 (mol/mol2)
- f_eq3 is d3Xi(n)/dXi3 (mol/mol3)</dd>
<dt><strong><code>b_rate_law</code></strong> :&ensp;<code>str</code>, default <code>"Partial equilibrium"</code></dt>
<dd>Type of backward rate law. Valid types include
- Use forward rate law
- Partial equilibrium
- Relative rate equation
The TST rate equation is not yet supported.</dd>
<dt><strong><code>b_eq1</code></strong>, <strong><code>b_eq2</code></strong>, <strong><code>b_eq3</code></strong> :&ensp;<code>float</code>, default <code>1, 0, 0, respectively</code></dt>
<dd>Coefficients of the backward rate law defined for <code>b_rate_law</code>.
If <code>b_rate_law</code> is "Relative rate equation", then:
- the value of b_eq1 represents dXi(n)/dXi (mol/mol)
- the value of b_eq2 represents d2Xi(n)/dXi2 (mol/mol2)
- the value of b_eq3 represents d3Xi(n)/dXi3 (mol/mol3)</dd>
<dt><strong><code>hide_traceback</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Hide traceback message when encountering errors handled by this class?
When True, error messages handled by this class will be short and to
the point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reactant:
    def __init__(self,
                 reactant_name,
                 reactant_type=&#34;Pure mineral&#34;,
                 reactant_status=&#34;Reacting&#34;,
                 amount_remaining=1,
                 amount_destroyed=0,
                 molar_volume=0,
                 surface_area_option=0,
                 surface_area_value=0,
                 surface_area_factor=0,
                 f_rate_law=&#34;Relative rate equation&#34;,
                 f_eq1=1,
                 f_eq2=0,
                 f_eq3=0,
                 b_rate_law=&#34;Partial equilibrium&#34;,
                 b_eq1=1,
                 b_eq2=0,
                 b_eq3=0,
                 special_reactant_dict={},
                 hide_traceback=True,
                 ):
        
        &#34;&#34;&#34;
        Class used to define reactants for `Prepare_Reaction`.

        Parameters
        ----------
        reactant_name : str
            Name of the reactant.

        reactant_type : str, default &#34;Pure mineral&#34;
            Reactant type. Valid types include
            - Pure mineral
            - Solid solution
            - Special reactant
            - Aqueous species
            - Gas species
            - Generic ion exchanger

        reactant_status : str, default &#34;Reacting&#34;
            Status of the reactant. Valid statuses include
            - Reacting
            - Saturated, reacting
            - Exhausted
            - Saturated, not reacting

        amount_remaining : float, default 1
            Moles of reactant remaining.

        amount_destroyed : float, default 0
            Moles of reactant destroyed.

        surface_area_option : int, default 0
            Option for reactant surface area. Valid options include:
            - 0, for Constant surface area (in cm2)
            - 1, for Constant specific surface area (in cm2/g). Surface area
            changes in proportion to the reactant mass.
            - 2, for n**2/3 growth law- current surface area (in cm2)

        surface_area_value : float, default 0
            Value assigned to choice of surface area option.
            - If `surface_area_option` is 0, value is in cm2.
            - If `surface_area_option` is 1, value is in cm2/g.
            - If `surface_area_option` is 2, value is in cm2.

        surface_area_factor : float, default 0
            Value assigned to surface area factor.

        f_rate_law : str, default &#34;Relative rate equation&#34;
            Type of forward rate law. Valid types include
            - Use backward rate law
            - Relative rate equation
            The TST rate equation is not yet supported.

        f_eq1, f_eq2, f_eq3 : float, default 1, 0, 0, respectively
            Coefficients of the forward rate law defined for `f_rate_law`.
            If `f_rate_law` is &#34;Relative rate equation&#34;, then:
            - f_eq1 is dXi(n)/dXi (mol/mol)
            - f_eq2 is d2Xi(n)/dXi2 (mol/mol2)
            - f_eq3 is d3Xi(n)/dXi3 (mol/mol3)

        b_rate_law : str, default &#34;Partial equilibrium&#34;
            Type of backward rate law. Valid types include
            - Use forward rate law
            - Partial equilibrium
            - Relative rate equation
            The TST rate equation is not yet supported.
            
        b_eq1, b_eq2, b_eq3 : float, default 1, 0, 0, respectively
            Coefficients of the backward rate law defined for `b_rate_law`.
            If `b_rate_law` is &#34;Relative rate equation&#34;, then:
            - the value of b_eq1 represents dXi(n)/dXi (mol/mol)
            - the value of b_eq2 represents d2Xi(n)/dXi2 (mol/mol2)
            - the value of b_eq3 represents d3Xi(n)/dXi3 (mol/mol3)
        
        hide_traceback : bool, default True
            Hide traceback message when encountering errors handled by this class?
            When True, error messages handled by this class will be short and to
            the point.

        &#34;&#34;&#34;
    
        self.err_handler = Error_Handler(clean=hide_traceback)
        
        if f_rate_law not in [&#34;Use backward rate law&#34;, &#34;Relative rate equation&#34;]:
            self.err_handler.raise_exception((&#34;f_rate_law must be either &#34;
                    &#34;&#39;Use backward rate law&#39; or &#39;Relative rate equation&#39;.&#34;))
        if b_rate_law not in [&#34;Use forward rate law&#34;, &#34;Partial equilibrium&#34;, &#34;Relative rate equation&#34;]:
            self.err_handler.raise_exception((&#34;b_rate_law must be either &#34;
                    &#34;&#39;Use forward rate law&#39;, &#39;Partial equilibrium&#39;, or &#39;Relative rate equation&#39;.&#34;))
        
        self.reactant_name=reactant_name
        self.reactant_type=reactant_type
        self.reactant_status=reactant_status
        self.amount_remaining=amount_remaining
        self.amount_destroyed=amount_destroyed
        self.molar_volume=molar_volume
        self.sa_val_1=0
        self.sa_val_2=0
        self.sa_val_3=0
        self.sa_checkbox_1= &#34; &#34;
        self.sa_checkbox_2= &#34; &#34;
        self.sa_checkbox_3= &#34; &#34;
        
        self.special_reactant_dict=special_reactant_dict
        
        if surface_area_option == 0:
            self.sa_checkbox_1 = &#34;x&#34;
            self.sa_val_1 = surface_area_value
        elif surface_area_option == 1:
            self.sa_checkbox_2 = &#34;x&#34;
            self.sa_val_2 = surface_area_value
        elif surface_area_option == 2:
            self.sa_checkbox_3 = &#34;x&#34;
            self.sa_val_3 = surface_area_value
        self.sa_factor=surface_area_factor
        
        self.f_rate_law=f_rate_law
        self.f_eq1=f_eq1
        self.f_eq2=f_eq2
        self.f_eq3=f_eq3
        self.b_rate_law=b_rate_law
        self.b_eq1=b_eq1
        self.b_eq2=b_eq2
        self.b_eq3=b_eq3
        
        self.__format_rate_block(&#34;forward&#34;)
        self.__format_rate_block(&#34;backward&#34;)

        self.__format_block()


    def __format_block(self):
        
        rb_dict_formatted = dict(
                reactant_name = f&#34;{self.reactant_name:&lt;24}&#34;,
                reactant_type = f&#34;{self.reactant_type:&lt;24}&#34;,
                reactant_status = f&#34;{self.reactant_status:&lt;24}&#34;,
                amount_remaining = f&#34;{&#39;{:.5E}&#39;.format(self.amount_remaining):&gt;12}&#34;,
                amount_destroyed = f&#34;{&#39;{:.5E}&#39;.format(self.amount_destroyed):&gt;12}&#34;,
                sa_checkbox_1 = self.sa_checkbox_1,
                sa_checkbox_2 = self.sa_checkbox_2,
                sa_checkbox_3 = self.sa_checkbox_3,
                sa_val_1 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_1):&gt;12}&#34;,
                sa_val_2 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_2):&gt;12}&#34;,
                sa_val_3 = f&#34;{&#39;{:.5E}&#39;.format(self.sa_val_3):&gt;12}&#34;,
                sa_factor = f&#34;{&#39;{:.5E}&#39;.format(self.sa_factor):&gt;12}&#34;,
                f_rate_law = f&#34;{self.f_rate_law:&lt;24}&#34;,
                b_rate_law = f&#34;{self.b_rate_law:&lt;24}&#34;,
                f_rate_block = self.formatted_f_rate_block,
                b_rate_block = self.formatted_b_rate_block,
                )

        if self.reactant_type.lower() == &#34;special reactant&#34;:
            elem_lines = []
            for key in list(self.special_reactant_dict.keys()):
                sp_elem_line = copy.copy(srb_stoich_template)
                elem_name = f&#34;{str(key):&lt;8}&#34;
                elem_value = f&#34;{&#39;{:.15E}&#39;.format(float(self.special_reactant_dict[key])):&gt;22}&#34;
                sp_elem_line = sp_elem_line.format(**{&#34;elem&#34;:elem_name, &#34;elem_val&#34;:elem_value})
                elem_lines.append(sp_elem_line)
            elem_lines = &#34;&#34;.join(elem_lines)
            
            srb_dict_formatted = dict(
                    molar_volume = f&#34;{&#39;{:.5E}&#39;.format(self.molar_volume):&gt;12}&#34;,
                    srb_stoich = elem_lines,
                    )
            
            sp_reactant_block_template = copy.copy(srb_template)
            sp_reactant_block_formatted = sp_reactant_block_template.format(**srb_dict_formatted)
            rb_dict_formatted[&#34;sr_block&#34;] = sp_reactant_block_formatted
        else:
            rb_dict_formatted[&#34;sr_block&#34;] = &#34;&#34;
   
        reactant_block_template = copy.copy(rb_template)
        self.formatted_block = reactant_block_template.format(**rb_dict_formatted)
    
    def __format_rate_block(self, direction):
        if direction == &#34;forward&#34;:
            d=&#34;f&#34;
            od=&#34;b&#34;
            odirection=&#34;backward&#34;
        else:
            d=&#34;b&#34;
            od=&#34;f&#34;
            odirection=&#34;forward&#34;

        eq1 = getattr(self, d+&#34;_eq1&#34;)
        eq2 = getattr(self, d+&#34;_eq2&#34;)
        eq3 = getattr(self, d+&#34;_eq3&#34;)

        if getattr(self, d+&#34;_rate_law&#34;) == &#34;Relative rate equation&#34;:
            rate_block = copy.deepcopy(relative_rate_equation_template)
            
            rate_options_formatted = dict(
                eq1=f&#34;{&#39;{:.5E}&#39;.format(eq1):&gt;12}&#34;,
                eq2=f&#34;{&#39;{:.5E}&#39;.format(eq2):&gt;12}&#34;,
                eq3=f&#34;{&#39;{:.5E}&#39;.format(eq3):&gt;12}&#34;,
            )
            
            rate_block = rate_block.format(**rate_options_formatted)
            setattr(self, &#34;formatted_&#34;+d+&#34;_rate_block&#34;, rate_block)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;Linear rate equation&#34;:
            # Note: &#34;Linear rate equation&#34; is valid in EQ6, but I cannot find any
            # EQ6 input files formatted for this option. My guess is that linear
            # rate equations can be imposed by only specifying the first parameter
            # of a relative rate equation.
            self.err_handler.raise_exception(&#34;The &#39;Linear rate equation&#39; option is not supported at this time.&#34;)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;TST rate equation&#34;:
            self.err_handler.raise_exception(&#34;TST rate equations are not supported at this time.&#34;)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;Partial equilibrium&#34;:
            setattr(self, &#34;formatted_&#34;+d+&#34;_rate_block&#34;, &#34;&#34;)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;Use backward rate law&#34;:
            setattr(self, &#34;formatted_&#34;+d+&#34;_rate_block&#34;, &#34;&#34;)
        elif getattr(self, d+&#34;_rate_law&#34;) == &#34;Use forward rate law&#34;:
            setattr(self, &#34;formatted_&#34;+d+&#34;_rate_block&#34;, &#34;&#34;)
        else:
            msg = (&#34;Valid rate laws for the &#34;+direction+&#34; rate law includes &#34;
                &#34;&#39;Relative rate equation&#39;, &#39;TST rate equation&#39;, &#34;
                &#34;&#39;Linear rate equation&#39;, or &#39;Use &#34;+odirection+&#34; rate law&#39;&#34;)
            self.err_handler.raise_exception(msg)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AqEquil" href="index.html">AqEquil</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="AqEquil.MassTransfer.join_mixes" href="#AqEquil.MassTransfer.join_mixes">join_mixes</a></code></li>
<li><code><a title="AqEquil.MassTransfer.react" href="#AqEquil.MassTransfer.react">react</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AqEquil.MassTransfer.Gas" href="#AqEquil.MassTransfer.Gas">Gas</a></code></h4>
</li>
<li>
<h4><code><a title="AqEquil.MassTransfer.Mass_Transfer" href="#AqEquil.MassTransfer.Mass_Transfer">Mass_Transfer</a></code></h4>
<ul class="">
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.mine_6o_table" href="#AqEquil.MassTransfer.Mass_Transfer.mine_6o_table">mine_6o_table</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_aqueous_species" href="#AqEquil.MassTransfer.Mass_Transfer.plot_aqueous_species">plot_aqueous_species</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_elements" href="#AqEquil.MassTransfer.Mass_Transfer.plot_elements">plot_elements</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_energy" href="#AqEquil.MassTransfer.Mass_Transfer.plot_energy">plot_energy</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_mass_contribution" href="#AqEquil.MassTransfer.Mass_Transfer.plot_mass_contribution">plot_mass_contribution</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_pH" href="#AqEquil.MassTransfer.Mass_Transfer.plot_pH">plot_pH</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_product_minerals" href="#AqEquil.MassTransfer.Mass_Transfer.plot_product_minerals">plot_product_minerals</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.plot_reaction_paths" href="#AqEquil.MassTransfer.Mass_Transfer.plot_reaction_paths">plot_reaction_paths</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.print_tabs" href="#AqEquil.MassTransfer.Mass_Transfer.print_tabs">print_tabs</a></code></li>
<li><code><a title="AqEquil.MassTransfer.Mass_Transfer.process_tab" href="#AqEquil.MassTransfer.Mass_Transfer.process_tab">process_tab</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AqEquil.MassTransfer.Mixing_Fluid" href="#AqEquil.MassTransfer.Mixing_Fluid">Mixing_Fluid</a></code></h4>
</li>
<li>
<h4><code><a title="AqEquil.MassTransfer.Prepare_Reaction" href="#AqEquil.MassTransfer.Prepare_Reaction">Prepare_Reaction</a></code></h4>
</li>
<li>
<h4><code><a title="AqEquil.MassTransfer.Reactant" href="#AqEquil.MassTransfer.Reactant">Reactant</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>